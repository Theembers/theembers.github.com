<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>my-house</title>
      <link href="/2020/01/21/my-house/"/>
      <url>/2020/01/21/my-house/</url>
      
        <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过还是能看看解密后的内容.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">需要密码才可以看哦.</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="a70fb7d0d0c8b5ace92089265c0f2f8b1d79432edd5b87e78192615963f6c3db">bd6095bf6f902e63a54ebf2ca6239355323895d6d4c3ecb461c920c0ebf7643c33c822662e2b4f6da03165e33d355c1974395cd0119379202e6ce6a639b195a10d73c159e430694ca7f869a4ee543171580f6a3f47b656f0c773e1c30c54961ad29badabcf23f45866c58b3310036b3afeb329842dc496b347f5b603726aceb85d338a9a6454af99222df2d61f098bf9123f8135527335ca67c489d2114e2f6e66d31ce45a418bea3349b632f795867d8c752443c2feb30b58d0f9176207bece26a2284df34adcb3565c22f5d50815b5199b10eb9ac83047d5321f0af03e2ec6dc93af005265f898571f6a82cb75eeafe2c77aab9034eeedae32c1616a85c8dbdef17ceb6575b0aa928b8382a5823c92f2e9f2a474d7ce2570b268d70efb0752e9f9fe418565080305997d8f6b4bba659688a0d42a9e8ec32f42729be76ffd4a62e9fa32f72aae121c62b3eb262b328f2a0a13a9ec003b69de97a11e0012f6a8ab0f707e109a1b7532dcfbbb038630d0b79a312699e4bd8c1b34c70841ce048621dca9f289d985dc113c5279fd9338a73b0f5985af19b0508f90d2550340db4edd23e4cc0af2a3a2d6801f61c5b1900d5d4f83f1615a578ce9d73c1e3c25cd0186cb15f128c440a4c9f2856b1a9bb3cb6a31f60082428e60518501423f422b042d47cdb5bd1b0f62739c1388e944903b905fb2a2440b59b8616902728a77fbb8b407a0ba91e032dbac373399aa6ee6f60dcb8643cc360745e3b362568857db355d9bf894add50f5053527dfbc48dcce092669601ef5e57a5dd0310e77777a27e9092d49e79b3db21ee64857d429fabc5ed15ba5c4ddd4c147085259d9c1404ce7daf0905bd35c51c645a685721e4afd89fccd5ce02f67118c57e78faf0c676dae84831a8957b1404c7206abd4725c23a58bbffa7ba00564bac37b600694de3e94a388247226fe8e4d019fc36aed13cde07b1146190d3b92abd7f9f79e97fa1ee0d862afd1b4e3b119c947cacf237893388bbefdc923b9d257af3d1ffd04dc417094165b1c97dee14755d6ee9f0ab77e7d9375a5b01e7d8d3b01b0af3f97ffd93928e181ed98cff52a299c02ac8382197aa451edd5016fec17e13dbf43a8ed65233db6527ea90854c7fb9301613c8da87a6f642d00213cf147305e96199659ac3bf7ebc7800eb150bc12bd332f18ebff6f0c30bc91bea5a8341b3c03ec4e4a4468cccb25098f2b4d45cb1108912953f2e77c7b600645a78b2b7dd917a4469f4e19991b66072100d47acbd71d4be0b537748296bc9981014f2ef2a5938d3de7ab8cddad31a55c963b8ab3027e7df07448542aada080df34f4b02a342ef008e32870dbc8a499c1ac6310d5a89bb6178a52b6274f83f6af5cc21d2baad3ab5d04e07349dd1e0f11737e5a8d793e1d1344f7d2e5e0671dbb585c4ccb63db26d96fdfc68c2cbaf941d4dca64e3f46e0854c9c9586b0361475bbcbba013eeb700ee75f0354e64623532d9c25cd52044e5eaaba30a9c7d5332ec1e470eb026ddad2f12ef75b792f0c5d79e4168b72ef2d5576f7a8f2a16b363f5c352606a9e723bf2fec88ca1644719f5615c4179d54748e38efa456a511e26f855ffe5b7e16e8049d91186b1c6afe2bc74ac5ae7b6bc148dec44d560a943fbf929d49d7655a3fe5bdc5147f6c990e1d235302ccb4394b9621d7b52c84254d65bd3ebce6391370cd58210c77355bd6dfaafad4b5b70b2338644aba3211fbfb28c9588e02268d42d0d37d89125ed09d06d20eaa940c8068b85aec92577032fbd006f2684c72a439668bf53a418bfaf72853f33958c2b95f5ea3327</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 碎碎念 </category>
          
          <category> 家装 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 家装 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-note[1]-JAVA源码-线程、线程池、AQS、JUC</title>
      <link href="/2020/01/21/java-note-1/"/>
      <url>/2020/01/21/java-note-1/</url>
      
        <content type="html"><![CDATA[<p><strong>源码部分只包含重点代码，其余代码忽略</strong></p><h2 id="线程与线程池"><a class="headerlink" href="#线程与线程池"></a> 线程与线程池</h2><h3 id="thread"><a class="headerlink" href="#thread"></a> thread</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Thread类实现了Runnable接口，所以说线程可以通过继承Thread来实现。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 守护线程</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> daemon = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 要被执行的方法</span></span><br><span class="line">    <span class="keyword">private</span> Runnable target;</span><br><span class="line">    <span class="comment">// 与本线程有关的ThreadLocal值，该映射由ThreadLocal类维护，注意这一点！这里是关于ThreadLocal为什么会内存泄漏的原因之一</span></span><br><span class="line">    ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="threadlocal"><a class="headerlink" href="#threadlocal"></a> ThreadLocal</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                T result = (T)e.value;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> setInitialValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">            map.set(<span class="keyword">this</span>, value);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            createMap(t, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">        t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * ThreadLocal 维护在它自己内部类ThreadLocalMap中，这是一个类似HashMap的数据结构。</span></span><br><span class="line"><span class="comment">     * 其内部 Entry 对象继承了弱引用类型 WeakReference 也就是说这个对象会在下一次GC时被回收。注意这里是ThreadLocal为什么会内存泄漏之二。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line">        ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">            table = <span class="keyword">new</span> Entry[INITIAL_CAPACITY];</span><br><span class="line">            <span class="keyword">int</span> i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>);</span><br><span class="line">            table[i] = <span class="keyword">new</span> Entry(firstKey, firstValue);</span><br><span class="line">            size = <span class="number">1</span>;</span><br><span class="line">            setThreshold(INITIAL_CAPACITY);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">            <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">            Object value;</span><br><span class="line"></span><br><span class="line">            Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">                <span class="keyword">super</span>(k);</span><br><span class="line">                value = v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正如代码注释山标记了两个“注意”，ThreadLocalMap在Thread中存在一个强引用链，而在ThreadLocal中则是一个弱引用链。如果此时如下图所示，发生了GC会导致弱引用中的Key值被回收，而此时当前线程并没有停止，所以强引用链依旧存在，但是并不能通过get方法获取到value（因为key被回收变成了null）。所以value会一直存在于内存中（如果当前线程一直存活），最后导致内存泄漏。</p><p><img src="https://image-1257148187.cos.ap-chengdu.myqcloud.com/picgo_img/20200122140356.png" alt=""></p><h3 id="executorservice-线程池"><a class="headerlink" href="#executorservice-线程池"></a> ExecutorService 线程池</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 工作队列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue;</span><br><span class="line"><span class="comment">// 可重入锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="comment">// 工作线程对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashSet&lt;Worker&gt; workers = <span class="keyword">new</span> HashSet&lt;Worker&gt;();</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程对象</span></span><br><span class="line"><span class="comment"> * 继承了AQS,说明它自生是带有锁机制的，他所代表的线程状态（即work自己的状态）都是AQS机制的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread thread;</span><br><span class="line">    <span class="comment">/** Initial task to run.  Possibly null. */</span></span><br><span class="line">    Runnable firstTask;</span><br><span class="line">    <span class="comment">/** Per-thread task counter */</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> completedTasks;</span><br><span class="line"></span><br><span class="line">    Worker(Runnable firstTask) &#123;</span><br><span class="line">            setState(-<span class="number">1</span>); <span class="comment">// inhibit interrupts until runWorker AQS 初始状态</span></span><br><span class="line">            <span class="keyword">this</span>.firstTask = firstTask;</span><br><span class="line">            <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        runWorker(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当前有效的线程数 &amp; 当前线程池的状态</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Proceed in 3 steps:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 1. If fewer than corePoolSize threads are running, try to</span></span><br><span class="line"><span class="comment">         * start a new thread with the given command as its first</span></span><br><span class="line"><span class="comment">         * task.  The call to addWorker atomically checks runState and</span></span><br><span class="line"><span class="comment">         * workerCount, and so prevents false alarms that would add</span></span><br><span class="line"><span class="comment">         * threads when it shouldn't, by returning false.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 2. If a task can be successfully queued, then we still need</span></span><br><span class="line"><span class="comment">         * to double-check whether we should have added a thread</span></span><br><span class="line"><span class="comment">         * (because existing ones died since last checking) or that</span></span><br><span class="line"><span class="comment">         * the pool shut down since entry into this method. So we</span></span><br><span class="line"><span class="comment">         * recheck state and if necessary roll back the enqueuing if</span></span><br><span class="line"><span class="comment">         * stopped, or start a new thread if there are none.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 3. If we cannot queue task, then we try to add a new</span></span><br><span class="line"><span class="comment">         * thread.  If it fails, we know we are shut down or saturated</span></span><br><span class="line"><span class="comment">         * and so reject the task.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="comment">// workerCountOf() 获取当前线程数,如果线程数小于核心线程数，则创建新线程（Worker）</span></span><br><span class="line">        <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">            <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            c = ctl.get(); <span class="comment">// 执行到这里说明addWorker()操作失败，比如被其他command抢先拉满了核心线程数。</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// isRunning() 获取当前线程池状态是否为执行中，并且加入工作队列成功</span></span><br><span class="line">        <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">            <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">            <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">                <span class="comment">// 如果当前线程池不在执行状态，但是任务从工作队列移除成功了，则调用拒绝策略</span></span><br><span class="line">                reject(command);</span><br><span class="line">            <span class="comment">// 如果工作线程总数为0，就创建新工作线程（至少启动一个线程。）   </span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">                addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>)) <span class="comment">// 到这说明队列满了，那么就创建扩展线程执行，注意addWorker()第二个参数。</span></span><br><span class="line">            <span class="comment">// 到这说明用拓展线程也失败了，则调用拒绝策略</span></span><br><span class="line">            reject(command);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建执行线程</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">        retry: <span class="comment">// 重试点</span></span><br><span class="line">        <span class="comment">// CAS 操作</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">            <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">            <span class="comment">// 如果 线程池 停止 并且 没有新任务 队列空 则返回 （说白了就是线程停止并且完全没事干了）</span></span><br><span class="line">            <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; !(rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span> &amp;&amp; !workQueue.isEmpty()))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="comment">// 获取工作线程数</span></span><br><span class="line">                <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">                <span class="comment">// 当前工作线程数大于容量（CAPACITY 表示线程池理论容量）或者大于核心/最大设置线程数时 返回</span></span><br><span class="line">                <span class="keyword">if</span> (wc &gt;= CAPACITY ||  wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="comment">// cas 添加线程数。成功 则跳出循环（跳出到最外层循环）</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                    <span class="keyword">break</span> retry;</span><br><span class="line">                c = ctl.get();  <span class="comment">// Re-read ctl</span></span><br><span class="line">                <span class="keyword">if</span> (runStateOf(c) != rs) <span class="comment">// cas 判断当前线程状态是否与上次的状态一致，不一致则到最外层重试。</span></span><br><span class="line">                    <span class="keyword">continue</span> retry;</span><br><span class="line">                <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">        Worker w = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 初始化一个工作对象</span></span><br><span class="line">            w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">            <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">            <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 上锁</span></span><br><span class="line">                <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">                mainLock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// Recheck while holding lock.</span></span><br><span class="line">                    <span class="comment">// Back out on ThreadFactory failure or if</span></span><br><span class="line">                    <span class="comment">// shut down before lock acquired.</span></span><br><span class="line">                    <span class="keyword">int</span> rs = runStateOf(ctl.get());</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (rs &lt; SHUTDOWN || (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                        <span class="comment">// 把worker对象加到workers链中</span></span><br><span class="line">                        workers.add(w);</span><br><span class="line">                        <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                        <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                            largestPoolSize = s;</span><br><span class="line">                        workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    mainLock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 如果添加成功 那就开始调用 worker的start()方法，后续这个线程会从工作队列中获取任务自己执行。</span></span><br><span class="line"><span class="comment">                 * 可以看Worker的run方法，调用的runWorker(Worker this)，以及 getTask()从队列中获取任务。</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                    t.start();</span><br><span class="line">                    workerStarted = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">                addWorkerFailed(w);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> workerStarted;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 拒绝策略</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">reject</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">        handler.rejectedExecution(command, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>由此可见：</p><ol><li>线程池初始化线程其实超麻烦的，所以在一些核心场景下可以考虑优先初始化热身（把线程拉满）</li><li>keepAliveTime是表示 当前线程池有任务要执行，但是现在开启的线程池太多了，导致一些现场始终抢不到任务，所以超过这个时间没抢到任务的线程就会被回收</li><li>任务被执行完后（工作队列没任务了），则会主动调取processWorkerExit()方法来回出发回收线程操作。并且会保证只存活核心线程数或者只有一个线程（ONLY_ONE）</li></ol><p>附上线程池工作流程图：</p><center><p><img src="https://i.loli.net/2018/09/06/5b90b431ce0bf.png" alt="线程池工作流程.png"><span class="image-caption">线程池工作流程.png</span></p></center><h2 id="aqs"><a class="headerlink" href="#aqs"></a> AQS</h2><p>AQS -&gt; AbstractQueuedSynchronizer 是一种实现锁和以来等待队列的同步器框架。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractQueuedSynchronizer</span> <span class="keyword">extends</span> <span class="title">AbstractOwnableSynchronizer</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="comment">/** Marker to indicate a node is waiting in shared mode */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</span><br><span class="line">        <span class="comment">/** Marker to indicate a node is waiting in exclusive mode */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** waitStatus value to indicate thread has cancelled */</span></span><br><span class="line">        <span class="comment">// 用于标记线程被终止的状态值</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</span><br><span class="line">        <span class="comment">/** waitStatus value to indicate successor's thread needs unparking */</span></span><br><span class="line">        <span class="comment">// 用于标记线下需要被唤醒的状态值</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">/** waitStatus value to indicate thread is waiting on condition */</span></span><br><span class="line">        <span class="comment">// 用于标记线程为等待状态</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * waitStatus value to indicate the next acquireShared should</span></span><br><span class="line"><span class="comment">         * unconditionally propagate</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 表示可以传播下一个共享状态</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br><span class="line">        <span class="comment">// 共享状态 使用 volatile 修饰 保证了状态在多线程场景下的可见性</span></span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Node 节点的两端引用</span></span><br><span class="line">        <span class="keyword">volatile</span> Node prev;</span><br><span class="line">        <span class="keyword">volatile</span> Node next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前node排队时的线程实例 </span></span><br><span class="line">        <span class="keyword">volatile</span> Thread thread;</span><br><span class="line"></span><br><span class="line">        Node nextWaiter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://image-1257148187.cos.ap-chengdu.myqcloud.com/UTOOLS1583335209100.png" alt="AQS数据模型"><span class="image-caption">AQS数据模型</span></p><h2 id="juc"><a class="headerlink" href="#juc"></a> JUC</h2><h3 id="concurrenthashmap"><a class="headerlink" href="#concurrenthashmap"></a> ConcurrentHashMap</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 继承 AbstractMap 并实现 ConcurrentMap 接口</span></span><br><span class="line"><span class="comment"> * AbstractMap 实现了 map 对象 的基本方法 （HashMap 也继承了这个抽象类）</span></span><br><span class="line"><span class="comment"> * ConcurrentMap 定义了 并发 Map 的一些方法。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentHashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">ConcurrentMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>; <span class="comment">// 最大可能容量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">16</span>; <span class="comment">// 默认容量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>; <span class="comment">// 最大数组长度</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The default concurrency level for this table. Unused but</span></span><br><span class="line"><span class="comment">     * defined for compatibility with previous versions of this class.</span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CONCURRENCY_LEVEL = <span class="number">16</span>; <span class="comment">// 默认并发级别，在jdk1.8中有说明 不被使用，只是作为和之前的版本兼容</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> LOAD_FACTOR = <span class="number">0.75f</span>; <span class="comment">// 默认负载因子</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>; <span class="comment">// 链表转红黑树的阈值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MOVED     = -<span class="number">1</span>; <span class="comment">// 表示正在转移</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEBIN   = -<span class="number">2</span>; <span class="comment">// 表示已经转换成树</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RESERVED  = -<span class="number">3</span>; <span class="comment">// hash for transient reservations</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_BITS = <span class="number">0x7fffffff</span>; <span class="comment">// usable bits of normal node hash</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用来控制表初始化和扩容的，默认值为0，当在初始化的时候指定了大小，这会将这个大小保存在sizeCtl中，大小为数组的0.75</span></span><br><span class="line"><span class="comment">     * 当为负的时候，说明表正在初始化或扩张，</span></span><br><span class="line"><span class="comment">     *     -1表示初始化</span></span><br><span class="line"><span class="comment">     *     -(1+n) n:表示活动的扩张线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> sizeCtl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Node 与 hashMap 一致</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">            <span class="keyword">final</span> K key;</span><br><span class="line">            <span class="keyword">volatile</span> V val;</span><br><span class="line">            <span class="keyword">volatile</span> Node&lt;K,V&gt; next;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 红黑树节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">            TreeNode&lt;K,V&gt; left;</span><br><span class="line">            TreeNode&lt;K,V&gt; right;</span><br><span class="line">            TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">            <span class="keyword">boolean</span> red;</span><br><span class="line"></span><br><span class="line">            TreeNode(<span class="keyword">int</span> hash, K key, V val, Node&lt;K,V&gt; next,</span><br><span class="line">                    TreeNode&lt;K,V&gt; parent) &#123;</span><br><span class="line">                <span class="keyword">super</span>(hash, key, val, next);</span><br><span class="line">                <span class="keyword">this</span>.parent = parent;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] table; <span class="comment">// node 数组 2的幂，初始化懒载</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] nextTable; <span class="comment">// 扩容时用来使用</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 先看 put 再看 get</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> putVal(key, value, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// kv都不可以为null</span></span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="comment">// 获取key的hash值</span></span><br><span class="line">        <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">        <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 死亡for循环！</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">            Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line">            <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>) <span class="comment">// table为空则初始化 </span></span><br><span class="line">                tab = initTable(); <span class="comment">// 这里不提供 initTable() 的源码 ，但需要知道的是 与 HashMap 不一样，这里的 initTable()使用的是CAS操作。</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 首节点 cas 插入</span></span><br><span class="line">                <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</span><br><span class="line">                             <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">                    <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果正在迁移（resize ing..） 则进行 helpTransfer()方法进行插入。helpTransfer 此处不提供源码，原理是通过cas操作直接把node 插入 nextTable 里。</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">                tab = helpTransfer(tab, f);</span><br><span class="line">            <span class="comment">// 常规加锁插入节点， 除了加锁 过程与 hashmap 大致相同    </span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                V oldVal = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// 给当前节点加锁，所以锁粒度是节点，注意与1.7中segment的不同！</span></span><br><span class="line">                <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                            binCount = <span class="number">1</span>;</span><br><span class="line">                            <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                                K ek;</span><br><span class="line">                                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                    ((ek = e.key) == key ||</span><br><span class="line">                                     (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                    oldVal = e.val;</span><br><span class="line">                                    <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                        e.val = value;</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                                Node&lt;K,V&gt; pred = e;</span><br><span class="line">                                <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                    pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                              value, <span class="keyword">null</span>);</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                            Node&lt;K,V&gt; p;</span><br><span class="line">                            binCount = <span class="number">2</span>;</span><br><span class="line">                            <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                           value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                oldVal = p.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    p.val = value;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                        treeifyBin(tab, i);</span><br><span class="line">                    <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                        <span class="keyword">return</span> oldVal;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get方法是无锁操作，所以它是支持并发的，但不代表线程安全（即 在时间序列上的读写请求顺序是不能保证顺序的，得看哪个线程先抢到锁）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="keyword">int</span> n, eh; K ek;</span><br><span class="line">        <span class="keyword">int</span> h = spread(key.hashCode());</span><br><span class="line">        <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">            (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((eh = e.hash) == h) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))</span><br><span class="line">                    <span class="keyword">return</span> e.val;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> (p = e.find(h, key)) != <span class="keyword">null</span> ? p.val : <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                    ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek))))</span><br><span class="line">                    <span class="keyword">return</span> e.val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> dev </category>
          
          <category> java </category>
          
          <category> jdk </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jdk </tag>
            
            <tag> 源码解析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-note[0]-JAVA源码-基本类型</title>
      <link href="/2020/01/19/java-note-0/"/>
      <url>/2020/01/19/java-note-0/</url>
      
        <content type="html"><![CDATA[<h2 id="string-stringbuffer-stringbuilder"><a class="headerlink" href="#string-stringbuffer-stringbuilder"></a> String &amp; StringBuffer &amp; StringBuilder</h2><ul><li><p>String</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用 char 数组作为数据存储（在jdk1.9改用byte[]。优化存储空间占用，一个char占用两个byte空间）</span></span><br><span class="line"><span class="comment"> * 使用 final 修饰，说明value[]不可变。</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 如果是通过构造函数创建字符串类型，那么值是通过传入的魔法值进行获取的，也就是说当前实例的value是常量池的引用。</span></span><br><span class="line"><span class="comment"> * 所以说 使用 `new String("123")` 这种方式会产生两个字符串，一个在常量池中，一个在堆里。</span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = <span class="string">""</span>.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(String original)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = original.value;</span><br><span class="line">    <span class="keyword">this</span>.hash = original.hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>StringBuffer</p><p>继承父类 AbstractStringBuilder value 与 String 不同，是没有被 final 修饰的。所以在连续拼接时，不会像 String 那样需要创建新的对象。在效率上更高。（效率提升来自于省略了对象实例化过程）</p><p>初始 capacity = 16</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> StringBuilder <span class="title">append</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.append(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>[] value;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> AbstractStringBuilder <span class="title">append</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> appendNull();</span><br><span class="line">    <span class="keyword">int</span> len = str.length();</span><br><span class="line">    ensureCapacityInternal(count + len);</span><br><span class="line">    str.getChars(<span class="number">0</span>, len, value, count);</span><br><span class="line">    count += len;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Create a copy, don't share the array</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(value, <span class="number">0</span>, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>StringBuilder</p><p>相对于StringBuilder，他的一系列方法都使用 synchronized 进行加锁控制。<br>使用 toStringCache 作为 toString 方法的缓存器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">char</span>[] toStringCache;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title">append</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    toStringCache = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">super</span>.append(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 没被修改的时候, 就可以直接把toStringCache作为new String的参数. 然后把这个String返回就行了。</span></span><br><span class="line"><span class="comment"> * 也就是cache有效的时候, 就不必进行arraycopy的复制操作. cache失效了才进行arraycopy的复制操作。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (toStringCache == <span class="keyword">null</span>) &#123;</span><br><span class="line">        toStringCache = Arrays.copyOfRange(value, <span class="number">0</span>, count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(toStringCache, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="collection"><a class="headerlink" href="#collection"></a> Collection</h2><p><img src="https://image-1257148187.cos.ap-chengdu.myqcloud.com/picgo_img/20200120135632.png" alt="java基本集合框架"><span class="image-caption">java基本集合框架</span></p><h3 id="list"><a class="headerlink" href="#list"></a> List</h3><h4 id="arraylist"><a class="headerlink" href="#arraylist"></a> ArrayList</h4>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * DEFAULT_CAPACITY 为默认容量，但是在初始化时使用 EMPTY_ELEMENTDATA 或者 DEFAULTCAPACITY_EMPTY_ELEMENTDATA 进行初始化，</span></span><br><span class="line"><span class="comment"> * 所以此时真实容量大小为空（empty）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当 elementData 为空时 比较 minCapacity 和 DEFAULT_CAPACITY 的值，取最大的。</span></span><br><span class="line"><span class="comment"> * 也就是， 有值的时候最小容量为 DEFAULT_CAPACITY = 10</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateCapacity</span><span class="params">(Object[] elementData, <span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minCapacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化 初始化容器</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// minCapacity (所需的容积大小) 大于 现在的容积大小时进行扩容。</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 扩容</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>); <span class="comment">// 新容量=老容量+老容量的一半</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="comment">// 如果所需的容量大于 MAX_ARRAY_SIZE (VM 限制的 大小 `MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8`)</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 巨型容量扩容</span></span><br><span class="line"><span class="comment"> * 初始化为 Integer.MAX_VALUE</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="linkedlist"><a class="headerlink" href="#linkedlist"></a> LinkedList</h4>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractSequentialList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">Deque</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><p>LinkedList 实现了 List 和 Deque 接口，所以可以作为列表和双端队列使用。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 静态内部 node 类</span></span><br><span class="line"><span class="comment">* 双向链表节点</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item = element;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">        <span class="keyword">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 获取 元素</span></span><br><span class="line"><span class="comment">* 如果 index 值小于链表长度 size 的一半，从头开始查询，否则从尾开始查询</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="keyword">return</span> node(index).item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert isElementIndex(index);</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">        Node&lt;E&gt; x = first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">            x = x.next;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;E&gt; x = last;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">            x = x.prev;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 插入 元素</span></span><br><span class="line"><span class="comment">* 先查找再替换，并返回旧值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    Node&lt;E&gt; x = node(index);</span><br><span class="line">    E oldVal = x.item;</span><br><span class="line">    x.item = element;</span><br><span class="line">    <span class="keyword">return</span> oldVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="vector"><a class="headerlink" href="#vector"></a> Vector</h4><p>与 ArrayList 相似，但是 Vector 是同步的(它的public方法都使用了 synchronized 修饰)。所以说 Vector 是线程安全的动态数组。它的操作与 ArrayList 几乎一样。</p><h4 id="stack"><a class="headerlink" href="#stack"></a> Stack</h4>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Stack 继承了 Vector 实现一个后进先出的堆栈。</span></span><br><span class="line"><span class="comment"> * 它的 pop() 和 peek() 方法也使用了 synchronized 修饰</span></span><br><span class="line"><span class="comment"> * push() 调用父级 Vector 的 addElement 方法 也是同步的</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stack</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Vector</span>&lt;<span class="title">E</span>&gt; </span>&#123;...&#125;</span><br></pre></td></tr></table></figure><h4 id="iterator-接口-listiterator-接口"><a class="headerlink" href="#iterator-接口-listiterator-接口"></a> Iterator 接口 &amp; ListIterator 接口</h4><p>Iterator 是一个接口，它是集合的迭代器。集合可以通过 Iterator 去遍历集合中的元素。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断集合里是否存在下一个元素。如果有，hasNext() 方法返回 true</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 返回集合里下一个元素</span></span><br><span class="line"><span class="function">E <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 删除集合里上一次next方法返回的元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 循环遍历（since 1.8）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; action)</span></span>;</span><br></pre></td></tr></table></figure><p>ListIterator 接口继承 Iterator 接口，提供了专门操作 List 的方法。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断集合里是否存在上一个元素。如果有，hasPrevious() 方法返回 true</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">hasPrevious</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 返回上一个元素</span></span><br><span class="line"><span class="function">E <span class="title">previous</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(E e)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span></span>;</span><br></pre></td></tr></table></figure><p>以上两个接口相比较会发现，ListIterator 增加了向前迭代的功能（ Iterator 只能向后迭代），ListIterator 还可以通过 add() 方法向 List 集合中添加元素（Iterator 只能删除元素）。</p><h3 id="queue"><a class="headerlink" href="#queue"></a> Queue</h3><h4 id="linkedlist-2"><a class="headerlink" href="#linkedlist-2"></a> LinkedList</h4><p>如上</p><h4 id="arraydeque"><a class="headerlink" href="#arraydeque"></a> ArrayDeque</h4>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 底层是Object数组</span></span><br><span class="line"><span class="keyword">transient</span> Object[] elements;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_INITIAL_CAPACITY = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认初始大小为16</span></span><br><span class="line"><span class="comment"> * 在如果是指定的大小，会通过 calculateSize(int numElements) 方法转换为对应的 2 的次方加1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayDeque</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    elements = <span class="keyword">new</span> Object[<span class="number">16</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayDeque</span><span class="params">(<span class="keyword">int</span> numElements)</span> </span>&#123;</span><br><span class="line">    allocateElements(numElements);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">allocateElements</span><span class="params">(<span class="keyword">int</span> numElements)</span> </span>&#123;</span><br><span class="line">    elements = <span class="keyword">new</span> Object[calculateSize(numElements)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateSize</span><span class="params">(<span class="keyword">int</span> numElements)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> initialCapacity = MIN_INITIAL_CAPACITY;</span><br><span class="line">    <span class="comment">// Find the best power of two to hold elements.</span></span><br><span class="line">    <span class="comment">// Tests "&lt;=" because arrays aren't kept full.</span></span><br><span class="line">    <span class="keyword">if</span> (numElements &gt;= initialCapacity) &#123;</span><br><span class="line">        initialCapacity = numElements;</span><br><span class="line">        initialCapacity |= (initialCapacity &gt;&gt;&gt;  <span class="number">1</span>);</span><br><span class="line">        initialCapacity |= (initialCapacity &gt;&gt;&gt;  <span class="number">2</span>);</span><br><span class="line">        initialCapacity |= (initialCapacity &gt;&gt;&gt;  <span class="number">4</span>);</span><br><span class="line">        initialCapacity |= (initialCapacity &gt;&gt;&gt;  <span class="number">8</span>);</span><br><span class="line">        initialCapacity |= (initialCapacity &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">        initialCapacity++; <span class="comment">// +1</span></span><br><span class="line">        <span class="comment">// 如果元素太大超过了 integer 的最大值 则会变成负数</span></span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)   <span class="comment">// Too many elements, must back off</span></span><br><span class="line">            initialCapacity &gt;&gt;&gt;= <span class="number">1</span>;<span class="comment">// Good luck allocating 2 ^ 30 elements</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> initialCapacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="priorityqueue"><a class="headerlink" href="#priorityqueue"></a> PriorityQueue</h4><p>优先队列PriorityQueue是Queue接口的实现，可以对其中元素进行排序，可以放基本数据类型的包装类（如：Integer，Long等）或自定义的类对于基本数据类型的包装器类，优先队列中元素默认排列顺序是升序排列但对于自己定义的类来说，需要自己定义比较器（Comparator）。</p><h3 id="set"><a class="headerlink" href="#set"></a> Set</h3><h4 id="hashset"><a class="headerlink" href="#hashset"></a> HashSet</h4>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashSet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="comment">// 底层使用HashMap存储数据，数据存在key部分，HashMap的value部分使用PRESENT填充</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Dummy value to associate with an Object in the backing Map</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Constructs a new, empty set; the backing &lt;tt&gt;HashMap&lt;/tt&gt; instance has</span></span><br><span class="line"><span class="comment">    * default initial capacity (16) and load factor (0.75).</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 传入集合的size/负载因子+1，如果小于16 则初始化为16。</span></span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;(Math.max((<span class="keyword">int</span>) (c.size()/.<span class="number">75f</span>) + <span class="number">1</span>, <span class="number">16</span>));</span><br><span class="line">        addAll(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 带 dummy 的构造函数是实例化一个LinkedHashMap作为底层数据存储，主要是实现LinkedHashSet</span></span><br><span class="line"><span class="comment">     * dummy只是为了区分构造函数，没有实际意义</span></span><br><span class="line"><span class="comment">     */</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">    &#125;</span><br><span class="line">    HashSet(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor, <span class="keyword">boolean</span> dummy) &#123;</span><br><span class="line">        map = <span class="keyword">new</span> LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="treeset-sortedset"><a class="headerlink" href="#treeset-sortedset"></a> TreeSet &amp; SortedSet</h4><p>reeSet时SortedSet接口的实现类，TreeSet可以保证元素处于排序状态，它采用红黑树的数据结构来存储集合元素。<br>TreeSet支持两种排序方法：自然排序和定制排序，默认采用自然排序。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NavigableMap接口继承了SortedMap</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> NavigableMap&lt;E,Object&gt; m;</span><br></pre></td></tr></table></figure><h2 id="map"><a class="headerlink" href="#map"></a> Map</h2><h3 id="hashmap"><a class="headerlink" href="#hashmap"></a> HashMap</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 默认最小容量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line">    <span class="comment">// 最大容量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 负载因子</span></span><br><span class="line"><span class="comment">     * 表示Hsah表中元素的填满的程度.若:加载因子越大,填满的元素越多,好处是,空间利用率高了,但:冲突的机会加大了.反之,加载因子越小,填满的元素越少,好处是:冲突的机会减小了,但:空间浪费多了.</span></span><br><span class="line"><span class="comment">     * 冲突的机会越大,则查找的成本越高.反之,查找的成本越小.因而,查找时间就越小. </span></span><br><span class="line"><span class="comment">     * 因此,必须在 "冲突的机会"与"空间利用率"之间寻找一种平衡与折衷. 这种平衡与折衷本质上是数据结构中有名的"时-空"矛盾的平衡与折衷.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line">    <span class="comment">// 链表转树结构的阈值</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line">    <span class="comment">// 树转链表的阈值</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line">    <span class="comment">// 最小树容量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line">    <span class="comment">// 下一个要调整大小的大小值（容量*负载系数）</span></span><br><span class="line">    <span class="keyword">int</span> threshold;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 静态内部类，链表节点的数据结构。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next; <span class="comment">// 单向链表</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Node 重写了hash算法以及equals方法</span></span><br><span class="line"><span class="comment">     * 注意！这里是Node内部类的hash，不是指HashMap的hash方法</span></span><br><span class="line"><span class="comment">     * Objects.hashCode(o) 的实现是如果o==null则返回0，否则调用o自身的hashCode()方法的返回值</span></span><br><span class="line"><span class="comment">     * hashCode与equals的重写绝大多数是同时的，因为约定：</span></span><br><span class="line"><span class="comment">     * equals相同则hash值相同，hash相同不一定equals。此处主要是因为前半部分约定。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">            <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp; Objects.equals(value, e.getValue()))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * HashMap的hash算法</span></span><br><span class="line"><span class="comment"> * 关于 hash算法的知识补充：</span></span><br><span class="line"><span class="comment"> * https://www.cnblogs.com/zxporz/p/11204233.html</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这里可以看出，get()和containsKey()方法都是通过调用getNode()方法来获取或判断key的存在的。</span></span><br><span class="line"><span class="comment"> * 所以平时使用时这种：</span></span><br><span class="line"><span class="comment"> * if(map.containsKey(key))&#123;</span></span><br><span class="line"><span class="comment"> *    map.get(key);</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> * 这种代码实际上是要两次getNode()的，所以建议取值时还是不用通过和containsKey()方法判断了。</span></span><br><span class="line"><span class="comment"> * 如果是要做有就get没有就put的话可以先get再判断是否为空，如果是则put的形式。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first; </span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果头节点是TreeNode则使用红黑树的便利方式，否则用链表便利</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getNode(hash(key), key) != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// map实例的isEmpty方法只是判断size是不是等于0，在平时使用时还要考虑map==null的情况防止空指针异常。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Implements Map.put and related methods.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hash</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> onlyIfAbsent 如果为true，不会覆盖已有值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> evict if false, the table is in creation mode.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回旧值或者null</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * // 以下是允许LinkedHashMap后处理的回调空实现</span></span><br><span class="line"><span class="comment"> * // Callbacks to allow LinkedHashMap post-actions</span></span><br><span class="line"><span class="comment"> * void afterNodeAccess(Node&lt;K,V&gt; p) &#123; &#125;</span></span><br><span class="line"><span class="comment"> * void afterNodeInsertion(boolean evict) &#123; &#125;</span></span><br><span class="line"><span class="comment"> * void afterNodeRemoval(Node&lt;K,V&gt; p) &#123; &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,<span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 如果链长（binCount）大于 TREEIFY_THRESHOLD - 1 则转为红黑树</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 如果size大于下一个扩容点则扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ? (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    </span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 红黑树</span></span><br><span class="line"><span class="comment"> * 输入树箱。扩展LinkedHashMap.Entry（反过来扩展Node），因此可以用作常规节点或链接节点的扩展。</span></span><br><span class="line"><span class="comment"> * 红黑树算法：</span></span><br><span class="line"><span class="comment"> * https://segmentfault.com/a/1190000012728513</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">    TreeNode&lt;K,V&gt; left;</span><br><span class="line">    TreeNode&lt;K,V&gt; right;</span><br><span class="line">    TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">    <span class="keyword">boolean</span> red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="linkedhashmap"><a class="headerlink" href="#linkedhashmap"></a> LinkedHashMap</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 双向链表维护key的顺序。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>.<span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        Entry&lt;K,V&gt; before, after;</span><br><span class="line">        Entry(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="keyword">super</span>(hash, key, value, next);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; head;</span><br><span class="line"><span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; tail;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The iteration ordering method for this linked hash map: &lt;tt&gt;true&lt;/tt&gt;</span></span><br><span class="line"><span class="comment"> * for access-order, &lt;tt&gt;false&lt;/tt&gt; for insertion-order.</span></span><br><span class="line"><span class="comment"> * true 表示访问顺序 false表示插入顺序</span></span><br><span class="line"><span class="comment"> * 访问顺序是在调用get()put()等操作时会把该元素移到链表末尾，以此可以实现LRU算法。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> accessOrder;</span><br></pre></td></tr></table></figure><h3 id="hashtable"><a class="headerlink" href="#hashtable"></a> HashTable</h3><p>数据结构与HashMap一致，所有公共方法都使用synchronized修饰。但它是一个被抛弃的类，它的hash算法以及链表的结构没有像JDK1.8的HashMap那样优化。</p><h3 id="treemap"><a class="headerlink" href="#treemap"></a> TreeMap</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 看到NavigableMap就应该知道，TreeMap是一个自排序的集合map对象。 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">NavigableMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span>&#123;</span><br><span class="line">  <span class="comment">// 通过制定 Comparator 自定义排序规则否则默认使用元素类型的compareTo()方法进行排序。</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;? <span class="keyword">super</span> K&gt; comparator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> dev </category>
          
          <category> java </category>
          
          <category> jdk </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jdk </tag>
            
            <tag> 源码解析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring cloud - 微服务架构核心关键点</title>
      <link href="/2019/12/11/spring-cloud-0/"/>
      <url>/2019/12/11/spring-cloud-0/</url>
      
        <content type="html"><![CDATA[<h2 id="微服务架构核心关键点"><a class="headerlink" href="#微服务架构核心关键点"></a> 微服务架构核心关键点</h2><p><img src="https://image-1257148187.cos.ap-chengdu.myqcloud.com/picgo_img/20191211095215.png" alt="微服务架构核心关键点"><span class="image-caption">微服务架构核心关键点</span></p>]]></content>
      
      
      <categories>
          
          <category> dev </category>
          
          <category> spring cloud </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>redis数据基础-思维导图</title>
      <link href="/2019/12/03/redis-0/"/>
      <url>/2019/12/03/redis-0/</url>
      
        <content type="html"><![CDATA[<p><img src="https://image-1257148187.cos.ap-chengdu.myqcloud.com/picgo_img/20191203164848.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> dev </category>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 常用命令 (updating)</title>
      <link href="/2019/11/23/git-help/"/>
      <url>/2019/11/23/git-help/</url>
      
        <content type="html"><![CDATA[<h4 id="仓库"><a class="headerlink" href="#仓库"></a> 仓库</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在当前目录新建一个Git代码库</span></span><br><span class="line">$ git init</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个目录，将其初始化为Git代码库</span></span><br><span class="line">$ git init [project-name]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载一个项目和它的整个代码历史</span></span><br><span class="line">$ git <span class="built_in">clone</span> [url]</span><br></pre></td></tr></table></figure><h4 id="配置"><a class="headerlink" href="#配置"></a> 配置</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示当前的Git配置</span></span><br><span class="line">$ git config --list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编辑Git配置文件</span></span><br><span class="line">$ git config -e [--global]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置提交代码时的用户信息</span></span><br><span class="line">$ git config [--global] user.name <span class="string">"[name]"</span></span><br><span class="line">$ git config [--global] user.email <span class="string">"[email address]"</span></span><br></pre></td></tr></table></figure><h4 id="增加删除文件"><a class="headerlink" href="#增加删除文件"></a> 增加/删除文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加指定文件到暂存区</span></span><br><span class="line">$ git add [file1] [file2] ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加指定目录到暂存区，包括子目录</span></span><br><span class="line">$ git add [dir]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加当前目录的所有文件到暂存区</span></span><br><span class="line">$ git add .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加每个变化前，都会要求确认</span></span><br><span class="line"><span class="comment"># 对于同一个文件的多处变化，可以实现分次提交</span></span><br><span class="line">$ git add -p</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除工作区文件，并且将这次删除放入暂存区</span></span><br><span class="line">$ git rm [file1] [file2] ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止追踪指定文件，但该文件会保留在工作区</span></span><br><span class="line">$ git rm --cached [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 改名文件，并且将这个改名放入暂存区</span></span><br><span class="line">$ git mv [file-original] [file-renamed]</span><br></pre></td></tr></table></figure><h4 id="代码提交"><a class="headerlink" href="#代码提交"></a> 代码提交</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 提交暂存区到仓库区</span></span><br><span class="line">$ git commit -m [message]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交暂存区的指定文件到仓库区</span></span><br><span class="line">$ git commit [file1] [file2] ... -m [message]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交工作区自上次commit之后的变化，直接到仓库区</span></span><br><span class="line">$ git commit -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交时显示所有diff信息</span></span><br><span class="line">$ git commit -v</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用一次新的commit，替代上一次提交</span></span><br><span class="line"><span class="comment"># 如果代码没有任何新变化，则用来改写上一次commit的提交信息</span></span><br><span class="line">$ git commit --amend -m [message]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重做上一次commit，并包括指定文件的新变化</span></span><br><span class="line">$ git commit --amend [file1] [file2] ...</span><br></pre></td></tr></table></figure><h4 id="分支"><a class="headerlink" href="#分支"></a> 分支</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出所有本地分支</span></span><br><span class="line">$ git branch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有远程分支</span></span><br><span class="line">$ git branch -r</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有本地分支和远程分支</span></span><br><span class="line">$ git branch -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个分支，但依然停留在当前分支</span></span><br><span class="line">$ git branch [branch-name]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个分支，并切换到该分支</span></span><br><span class="line">$ git checkout -b [branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个分支，指向指定commit</span></span><br><span class="line">$ git branch [branch] [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个分支，与指定的远程分支建立追踪关系</span></span><br><span class="line">$ git branch --track [branch] [remote-branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到指定分支，并更新工作区</span></span><br><span class="line">$ git checkout [branch-name]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到上一个分支</span></span><br><span class="line">$ git checkout -</span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立追踪关系，在现有分支与指定的远程分支之间</span></span><br><span class="line">$ git branch --<span class="built_in">set</span>-upstream [branch] [remote-branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并指定分支到当前分支</span></span><br><span class="line">$ git merge [branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 选择一个commit，合并进当前分支</span></span><br><span class="line">$ git cherry-pick [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除分支</span></span><br><span class="line">$ git branch -d [branch-name]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除远程分支</span></span><br><span class="line">$ git push origin --delete [branch-name]</span><br><span class="line">$ git branch -dr [remote/branch]</span><br></pre></td></tr></table></figure><h4 id="标签"><a class="headerlink" href="#标签"></a> 标签</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出所有tag</span></span><br><span class="line">$ git tag</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个tag在当前commit</span></span><br><span class="line">$ git tag [tag]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个tag在指定commit</span></span><br><span class="line">$ git tag [tag] [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除本地tag</span></span><br><span class="line">$ git tag -d [tag]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除远程tag</span></span><br><span class="line">$ git push origin :refs/tags/[tagName]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看tag信息</span></span><br><span class="line">$ git show [tag]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交指定tag</span></span><br><span class="line">$ git push [remote] [tag]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交所有tag</span></span><br><span class="line">$ git push [remote] --tags</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个分支，指向某个tag</span></span><br><span class="line">$ git checkout -b [branch] [tag]</span><br></pre></td></tr></table></figure><h4 id="查看信息"><a class="headerlink" href="#查看信息"></a> 查看信息</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示有变更的文件</span></span><br><span class="line">$ git status</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示当前分支的版本历史</span></span><br><span class="line">$ git <span class="built_in">log</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示commit历史，以及每次commit发生变更的文件</span></span><br><span class="line">$ git <span class="built_in">log</span> --<span class="built_in">stat</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 搜索提交历史，根据关键词</span></span><br><span class="line">$ git <span class="built_in">log</span> -S [keyword]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某个commit之后的所有变动，每个commit占据一行</span></span><br><span class="line">$ git <span class="built_in">log</span> [tag] HEAD --pretty=format:%s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某个commit之后的所有变动，其"提交说明"必须符合搜索条件</span></span><br><span class="line">$ git <span class="built_in">log</span> [tag] HEAD --grep feature</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某个文件的版本历史，包括文件改名</span></span><br><span class="line">$ git <span class="built_in">log</span> --follow [file]</span><br><span class="line">$ git whatchanged [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示指定文件相关的每一次diff</span></span><br><span class="line">$ git <span class="built_in">log</span> -p [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示过去5次提交</span></span><br><span class="line">$ git <span class="built_in">log</span> -5 --pretty --oneline</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示所有提交过的用户，按提交次数排序</span></span><br><span class="line">$ git shortlog -sn</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示指定文件是什么人在什么时间修改过</span></span><br><span class="line">$ git blame [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示暂存区和工作区的差异</span></span><br><span class="line">$ git diff</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示暂存区和上一个commit的差异</span></span><br><span class="line">$ git diff --cached [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示工作区与当前分支最新commit之间的差异</span></span><br><span class="line">$ git diff HEAD</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示两次提交之间的差异</span></span><br><span class="line">$ git diff [first-branch]...[second-branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示今天你写了多少行代码</span></span><br><span class="line">$ git diff --shortstat <span class="string">"@&#123;0 day ago&#125;"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某次提交的元数据和内容变化</span></span><br><span class="line">$ git show [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某次提交发生变化的文件</span></span><br><span class="line">$ git show --name-only [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某次提交时，某个文件的内容</span></span><br><span class="line">$ git show [commit]:[filename]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示当前分支的最近几次提交</span></span><br><span class="line">$ git reflog</span><br></pre></td></tr></table></figure><h4 id="远程同步"><a class="headerlink" href="#远程同步"></a> 远程同步</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载远程仓库的所有变动</span></span><br><span class="line">$ git fetch [remote]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示所有远程仓库</span></span><br><span class="line">$ git remote -v</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某个远程仓库的信息</span></span><br><span class="line">$ git remote show [remote]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 增加一个新的远程仓库，并命名</span></span><br><span class="line">$ git remote add [shortname] [url]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取回远程仓库的变化，并与本地分支合并</span></span><br><span class="line">$ git pull [remote] [branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上传本地指定分支到远程仓库</span></span><br><span class="line">$ git push [remote] [branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 强行推送当前分支到远程仓库，即使有冲突</span></span><br><span class="line">$ git push [remote] --force</span><br><span class="line"></span><br><span class="line"><span class="comment"># 推送所有分支到远程仓库</span></span><br><span class="line">$ git push [remote] --all</span><br></pre></td></tr></table></figure><h4 id="撤销"><a class="headerlink" href="#撤销"></a> 撤销</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 恢复暂存区的指定文件到工作区</span></span><br><span class="line">$ git checkout [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 恢复某个commit的指定文件到暂存区和工作区</span></span><br><span class="line">$ git checkout [commit] [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 恢复暂存区的所有文件到工作区</span></span><br><span class="line">$ git checkout .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</span></span><br><span class="line">$ git reset [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重置暂存区与工作区，与上一次commit保持一致</span></span><br><span class="line">$ git reset --hard</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</span></span><br><span class="line">$ git reset [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</span></span><br><span class="line">$ git reset --hard [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重置当前HEAD为指定commit，但保持暂存区和工作区不变</span></span><br><span class="line">$ git reset --keep [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个commit，用来撤销指定commit</span></span><br><span class="line"><span class="comment"># 后者的所有变化都将被前者抵消，并且应用到当前分支</span></span><br><span class="line">$ git revert [commit]</span><br><span class="line"></span><br><span class="line">暂时将未提交的变化移除，稍后再移入</span><br><span class="line">$ git stash</span><br><span class="line">$ git stash pop</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> dev </category>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IoT 数据采集框架 (IoT-DC)</title>
      <link href="/2019/11/18/iot-framework-dc/"/>
      <url>/2019/11/18/iot-framework-dc/</url>
      
        <content type="html"><![CDATA[<h2 id="iot-dc-framework"><a class="headerlink" href="#iot-dc-framework"></a> IoT-DC framework</h2><blockquote><p>a IoT data collector framework and power by springboot+netty+rabbitmq/kafka</p><p>一个基于 springboot+netty+rabbitmq 实现的 物联网设备(IoT) 数据接入的项目</p></blockquote><blockquote><p><strong>src</strong>: <a href="https://github.com/Theembers/iot-dc" target="_blank" rel="noopener">https://github.com/Theembers/iot-dc</a></p><p><strong>thanks for star! 😃 ⭐⭐⭐⭐⭐</strong></p></blockquote><p>the obsolete version (branch:s-0.1) will be not update yet (except bug fix), the master will be rebuild as new one. thanks follow!</p><p>旧版本以封版（分支s-0.1）不再更新（除了bug修改），master 分支将启用新的设计，敬请期待！</p><p><a href="https://github.com/Theembers/iot-dc/tree/s-0.1" target="_blank" rel="noopener">branch:s-0.1</a></p><p>🎉 new framework had be done! you can running with <code>iot-example</code>-<code>me.theembers.iot.TestCollector</code> to debug it.</p><p>🎉 新版本框架已基本完成！可以通过 <code>iot-example</code>-<code>me.theembers.iot.TestCollector</code> 运行调试。</p><h2 id="iot-platform-framework-iot平台总体架构设计"><a class="headerlink" href="#iot-platform-framework-iot平台总体架构设计"></a> IoT platform framework (IoT平台总体架构设计)</h2><p><img src="https://image-1257148187.cos.ap-chengdu.myqcloud.com/picgo_img/20190926173357.jpg" alt="设备总体接入架构"><span class="image-caption">设备总体接入架构</span></p><h2 id="about-the-new-iot-dc-framework-关于新版-iot-dc-framework"><a class="headerlink" href="#about-the-new-iot-dc-framework-关于新版-iot-dc-framework"></a> about the new IoT-DC Framework (关于新版 IoT-DC Framework)</h2><p>抽离了netty的实现逻辑，保留了基础框架</p><ul><li>iot-framework-dc 抽象了基础的接入逻辑模型。如下图：</li></ul><p><img src="https://image-1257148187.cos.ap-chengdu.myqcloud.com/picgo_img/20191111134357.jpg" alt="iot-framework-dc 模型"><span class="image-caption">iot-framework-dc 模型</span></p><ul><li><p>router 模型 &amp; device shadow 模型</p><p>路由器 (router)，把接入的数据分发到符合规则 (rule) 的处理器 (processor) 中进行处理。<br><img src="https://image-1257148187.cos.ap-chengdu.myqcloud.com/picgo_img/20191111131757.jpg" alt="router 模型"><span class="image-caption">router 模型</span></p></li><li><p>processor-link 模型</p><p>router 通过选择器 (Selector) 选择出的导航 (Route) 维护了一个调度者 (Dispatcher) 调度者负责管理被使用的 processor链 以及 processor 的调用 规则:</p></li></ul><p><img src="https://image-1257148187.cos.ap-chengdu.myqcloud.com/picgo_img/processor-link-1.jpg" alt="processor-link 模型"><span class="image-caption">processor-link 模型</span></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 执行</span></span><br><span class="line"><span class="comment"> * 如果 当前processor是头节点，调用 headIn （ 调用 beforeTransform &amp; transForm）</span></span><br><span class="line"><span class="comment"> * 否则 （中间节点 或者 尾节点） 调用 receive（接收）</span></span><br><span class="line"><span class="comment"> * 最终 如果 是尾结点 则 调用 tailOut （调用 afterTransform） 并 退出循环</span></span><br><span class="line"><span class="comment"> * 到 //1 则 调用 buildSlotData （构建插槽）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> shadow</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sourceData</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">(Shadow shadow, SourceData sourceData)</span> </span>&#123;</span><br><span class="line">    Output output = <span class="keyword">null</span>;</span><br><span class="line">    SlotData slotData = <span class="keyword">null</span>;</span><br><span class="line">    Iterator&lt;Processor&gt; processors = <span class="keyword">this</span>.link.iterator();</span><br><span class="line">    <span class="keyword">while</span> (processors.hasNext()) &#123;</span><br><span class="line">        Processor p = processors.next();</span><br><span class="line">        <span class="keyword">if</span> (p == getFirst()) &#123;</span><br><span class="line">            output = p.headIn(shadow, sourceData);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            output = p.receive(shadow, slotData);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p == getLast()) &#123;</span><br><span class="line">            output = p.tailOut(shadow, output);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        slotData = p.passOn(shadow, output); <span class="comment">// 1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>iot-dc-netty-server 是之前的netty实现，目前（2019-11-07）只是迁移了老模块的代码，后期会修改结构，所以暂不做架构说明。新分支侧着架构设计，所以具体实现可能要延后实现。</li></ul>]]></content>
      
      
      <categories>
          
          <category> iot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iot </tag>
            
            <tag> framework </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>领域模型驱动设计[0]</title>
      <link href="/2019/11/01/Domain-Driven-Design-0/"/>
      <url>/2019/11/01/Domain-Driven-Design-0/</url>
      
        <content type="html"><![CDATA[<ul><li><p>模型和设计的核心（实现）互相影响<br>设计的核心就是对与现实业务需求的实现，而实现需求的逻辑则是模型的定义。<br>实现使得模型有用，而模型可解释实现。</p></li><li><p>模型是团队交流中枢<br>语义统一，减少沟通偏差和成本。</p></li><li><p>模型浓缩知识</p></li></ul><h2 id="ddd中的基本概念"><a class="headerlink" href="#ddd中的基本概念"></a> DDD中的基本概念</h2><ul><li><p>实体（Entity）<br>当一个对象由其标识(而不是属性)区分时，这种对象称为实体(Entity)。比如当两个对象的标识不同时，即使两个对象的其他属性全都相同，我们也认为他们是两个完全不同的实体。</p></li><li><p>值对象（Value Object）<br>当一个对象用于对事物进行描述而没有唯一标识时，那么它被称作值对象。因为在领域中并不是任何时候一个事物都需要有一个唯一的标识，也就是说我们并不关心具体是哪个事物，只关心这个事物是什么。比如下单流程中，对于配送地址来说，只要是地址信息相同，我们就认为是同一个配送地址。由于不具有唯一标示，我们也不能说&quot;这一个&quot;值对象或者&quot;那一个&quot;值对象。</p></li><li><p>领域服务（Domain Service）<br>一些重要的领域行为或操作，它们不太适合建模为实体对象或者值对象，它们本质上只是一些操作，并不是具体的事物，另一方面这些操作往往又会涉及到多个领域对象的操作，它们只负责来协调这些领域对象完成操作而已，那么我们可以归类它们为领域服务。它实现了全部业务逻辑并且通过各种校验手段保证业务的正确性。同时呢，它也能避免在应用层出现领域逻辑。理解起来，领域服务有点facade的味道。</p></li><li><p>聚合及聚合根（Aggregate，Aggregate Root）<br>聚合是通过定义领域对象之间清晰的所属关系以及边界来实现领域模型的内聚，以此来避免形成错综复杂的、难以维护的对象关系网。聚合定义了一组具有内聚关系的相关领域对象的集合，我们可以把聚合看作是一个修改数据的单元。<br>聚合根属于实体对象，它是领域对象中一个高度内聚的核心对象。(聚合根具有全局的唯一标识，而实体只有在聚合内部有唯一的本地标识，值对象没有唯一标识，不存在这个值对象或那个值对象的说法)<br>若一个聚合仅有一个实体，那这个实体就是聚合根；但要有多个实体，我们就要思考聚合内哪个对象有独立存在的意义且可以和外部领域直接进行交互。</p></li><li><p>工厂（Factory）<br>DDD中的工厂也是一种封装思想的体现。引入工厂的原因是：有时创建一个领域对象是一件相对比较复杂的事情，而不是简单的new操作。工厂的作用是隐藏创建对象的细节。事实上大部分情况下，领域对象的创建都不会相对太复杂，故我们仅需使用简单的构造函数创建对象就可以。隐藏创建对象细节的好处是显而易见的，这样就可以不会让领域层的业务逻辑泄露到应用层，同时也减轻应用层负担，它只要简单调用领域工厂来创建出期望的对象就可以了。</p></li><li><p>仓储（Repository）<br>资源仓储封装了基础设施来提供查询和持久化聚合操作。这样能够让我们始终关注在模型层面，把对象的存储和访问都委托给资源库来完成。它不是数据库的封装，而是领域层与基础设施之间的桥梁。DDD 关心的是领域内的模型，而不是数据库的操作。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> dev </category>
          
          <category> DDD </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>spring-cloud-bus-config 消息总线&amp;配置中心</title>
      <link href="/2019/10/12/spring-cloud-bus-config/"/>
      <url>/2019/10/12/spring-cloud-bus-config/</url>
      
        <content type="html"><![CDATA[<h2 id="场景意义"><a class="headerlink" href="#场景意义"></a> 场景&amp;意义</h2><p>在不重启服务的情况下更新配置，但逐一调用服务的api去修改是很不科学的。所以可以利用消息队列发布订阅的模型，让所有为服务来订阅这个事件，当这个事件发生改变了，就可以通知所有微服务去更新它们的内存中的配置信息。</p><p>spring-cloud-bus 消息总线就就是在spring-cloud-config-server端发出refresh，触发所有微服务更新配置。</p><h2 id="搭建demo项目"><a class="headerlink" href="#搭建demo项目"></a> 搭建demo项目</h2><ul><li>spring cloud<ul><li>eureka</li><li>config-bus (集成了config 配置中心 &amp; bus 消息总线)</li><li>web-api</li></ul></li></ul><p><img src="https://image-1257148187.cos.ap-chengdu.myqcloud.com/picgo_img/20191016130547.png" alt="demo项目结构说明"><span class="image-caption">demo项目结构说明</span></p><h2 id="更新配置加载"><a class="headerlink" href="#更新配置加载"></a> 更新配置&amp;加载</h2><ol><li>commit&amp;push git配置 到git服务器</li><li>调用refresh接口刷新服务器配置</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># springboot 2.x</span></span><br><span class="line"> curl -X POST <span class="string">"192.168.9.97:8868/actuator/bus-refresh"</span></span><br><span class="line"></span><br><span class="line"> <span class="comment"># springboot 1.x</span></span><br><span class="line"> curl -X GET <span class="string">"192.168.9.97:8868/bus/refresh"</span></span><br></pre></td></tr></table></figure><h2 id="灰度更新"><a class="headerlink" href="#灰度更新"></a> 灰度更新</h2><p>灰度更新是为了在多节点集群中，只更新部分服务的配置用于参数测试，而其他服务依旧使用之前的配置。<br>spring cloud bus 通过 destination 参数指定需要更新对服务来刷新配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># springboot 2.X</span></span><br><span class="line">curl -X POST <span class="string">"192.168.9.97:8868/actuator/bus-refresh/&#123;destination&#125;"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#springboot 1.X</span></span><br><span class="line">curl -X GET <span class="string">"192.168.9.97:8868/bus/refresh?destination=&#123;ApplicationContext ID&#125;"</span></span><br></pre></td></tr></table></figure><p>destination 参数为 ApplicationContext ID 例如本例中的 <code>api-gateway:8869</code> 或者 <code>api-gateway:**</code></p><h2 id="通过配置-git-仓库-webhooks-来自动调用接口"><a class="headerlink" href="#通过配置-git-仓库-webhooks-来自动调用接口"></a> 通过配置 Git 仓库 WebHooks 来自动调用接口</h2><p>git 配置修改后自动回调。</p><p><img src="https://image-1257148187.cos.ap-chengdu.myqcloud.com/picgo_img/20191016133403.png" alt="git 回调配置"><span class="image-caption">git 回调配置</span></p>]]></content>
      
      
      <categories>
          
          <category> dev </category>
          
          <category> spring cloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring-cloud-bus </tag>
            
            <tag> spring-cloud-config </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小雪第三阶段-生日快乐~ヽ(=^･ω･^=)</title>
      <link href="/2019/10/05/cat-in-the-house-2/"/>
      <url>/2019/10/05/cat-in-the-house-2/</url>
      
        <content type="html"><![CDATA[<p><img src="https://image-1257148187.cos.ap-chengdu.myqcloud.com/picgo_img/20191012170551.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
          <category> 碎碎念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cat </tag>
            
            <tag> 雪糕 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring cloud health - 如何实现规范的自定义健康检查指标</title>
      <link href="/2019/08/12/spring-cloud-health-1/"/>
      <url>/2019/08/12/spring-cloud-health-1/</url>
      
        <content type="html"><![CDATA[<h2 id="引"><a class="headerlink" href="#引"></a> 引</h2><p>Spring Boot Actuator 有几个预定义的健康指标比如 DataSourceHealthIndicator, DiskSpaceHealthIndicator, MongoHealthIndicator, RedisHealthIndicator, CassandraHealthIndicator等。它使用这些健康指标作为健康检查的一部分。</p><p>本文对比较常用数据源健康指标 DataSourceHealth 相关的源码进行研究解读，以此作为自定义 HealthIndicator 的编程基础。已实现规范的HealthIndicator编程模式。</p><h2 id="datasourcehealthindicator-源码核心部分"><a class="headerlink" href="#datasourcehealthindicator-源码核心部分"></a> DataSourceHealthIndicator 源码核心部分</h2><p><img src="https://image-1257148187.cos.ap-chengdu.myqcloud.com/picgo_img/20190812104113.png" alt="DataSourceHealthIndicator UML结构"><span class="image-caption">DataSourceHealthIndicator UML结构</span></p><p>根据UML图可知：</p><ul><li><p>实现 InitializingBean 接口 并实现 afterPropertiesSet() 方法<br><img src="https://image-1257148187.cos.ap-chengdu.myqcloud.com/picgo_img/20190812104445.png" alt=""><br>如果 dataSource 为null 则抛出 IllegalStateException 异常</p></li><li><p>继承 AbstractHealthIndicator 抽象类 并实现doHealthCheck() 方法<br><img src="https://image-1257148187.cos.ap-chengdu.myqcloud.com/picgo_img/20190812105030.png" alt=""><br>如果 dataSource 为null 则 标记 up 并显示 database unknow. 否则执行 doDataSourceHealthCheck()<br><img src="https://image-1257148187.cos.ap-chengdu.myqcloud.com/picgo_img/20190812105620.png" alt=""></p></li></ul><h2 id="datasourcehealthindicatorautoconfiguration-源码核心部分"><a class="headerlink" href="#datasourcehealthindicatorautoconfiguration-源码核心部分"></a> DataSourceHealthIndicatorAutoConfiguration 源码核心部分</h2><p><img src="https://image-1257148187.cos.ap-chengdu.myqcloud.com/picgo_img/20190812111404.png" alt="DataSourceHealthIndicatorAutoConfiguration UML结构"><span class="image-caption">DataSourceHealthIndicatorAutoConfiguration UML结构</span></p><p><img src="https://image-1257148187.cos.ap-chengdu.myqcloud.com/picgo_img/20190812111220.png" alt=""></p><p>注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">// 某个class位于类路径上，才会实例化一个Bean 这里是JdbcTemplate和AbstractRoutingDataSource存在时才实例化</span></span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(&#123; JdbcTemplate.class, AbstractRoutingDataSource.class &#125;)</span><br><span class="line"><span class="comment">// 仅仅在当前上下文中存在某个对象时，才会实例化一个Bean 这里是DataSource 的bean存在是</span></span><br><span class="line"><span class="meta">@ConditionalOnBean</span>(DataSource.class)</span><br><span class="line"><span class="comment">// Actuator 中自定义的 EnabledHealthIndicator 中 包含 "x" 时实例化Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnEnabledHealthIndicator</span>(<span class="string">"db"</span>)</span><br><span class="line"><span class="meta">@AutoConfigureBefore</span>(HealthIndicatorAutoConfiguration.class)</span><br><span class="line"><span class="meta">@AutoConfigureAfter</span>(DataSourceAutoConfiguration.class)</span><br></pre></td></tr></table></figure><p>以此可以看出，Actuator 的 healthy 是依赖于 config 配置的实例化机制，通过bean加载所需的资源进行验证。</p><p>所以对于自定义的检测指标可按照这种方式进行编程。</p>]]></content>
      
      
      <categories>
          
          <category> dev </category>
          
          <category> spring cloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Cloud Health </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IOT[1]-MQTT相关介绍</title>
      <link href="/2019/08/02/iot-1-mqtt/"/>
      <url>/2019/08/02/iot-1-mqtt/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a class="headerlink" href="#简介"></a> 简介</h2><p>MQTT 全称为 Message Queuing Telemetry Transport（消息队列遥测传输）是一种基于发布/订阅范式的“轻量级”消息协议，由 IBM 发布。</p><ul><li>MQTT 可以被解释为一种低开销，低带宽占用的即时通讯协议，可以用极少的代码和带宽的为连接远程设备提供实时可靠的消息服务，它适用于硬件性能低下的远程设备以及网络状况糟糕的环境下，因此 MQTT 协议在 IoT（Internet of things，物联网），小型设备应用，移动应用等方面有较广泛的应用。</li><li>IoT 设备要运作，就必须连接到互联网，设备才能相互协作，以及与后端服务协同工作。而互联网的基础网络协议是 TCP/IP，MQTT 协议是基于 TCP/IP 协议栈而构建的，因此它已经慢慢的已经成为了 IoT 通讯的标准。</li></ul><h2 id="基本特性"><a class="headerlink" href="#基本特性"></a> 基本特性</h2><ul><li>MQTT是一种<strong>发布/订阅</strong>的传输协议<br>MQTT 协议提供一对多的消息发布，可以解除应用程序耦合，信息冗余小。该协议需要客户端和服务端，而协议中主要有三种身份：发布者（Publisher）、代理（Broker，服务器）、订阅者（Subscriber）。其中，消息的发布者和订阅者都是客户端，消息代理是服务器，而消息发布者可以同时是订阅者，实现了生产者与消费者的脱耦。</li><li>基于 TCP/IP 提供网络连接，提供有序、无损、双向连接</li><li>对负载内容屏蔽的消息传输（安全性）</li><li>具体有三种消息发布的服务质量：<ul><li>至多一次，消息发布完全依赖底层 TCP/IP 网络。会发生消息丢失或重复。这一级别可用于如下情况，环境传感器数据，丢失一次读记录无所谓，因为不久后还会有第二次发送。</li><li>至少一次，确保消息到达，但消息重复可能会发生。</li><li>只有一次，确保消息到达一次。这一级别可用于如下情况，在计费系统中，消息重复或丢失会导致不正确的结果。</li></ul></li><li>小型传输，开销小，固定长度的头部是 2 字节，协议交换最小化，以降低网络流量<br>整体上协议可拆分为：固定头部+可变头部+消息体，这就是为什么在介绍里说它非常适合&quot;在物联网领域，传感器与服务器的通信，信息的收集&quot;。</li><li>使用Last Will和Testament特性通知有关各方客户端异常中断的机制<br>Last Will：即遗言机制，用于通知同一主题下的其他设备发送遗言的设备已经断开了连接。<br>Testament：遗嘱机制，功能类似于Last Will。</li></ul><h2 id="基本概念"><a class="headerlink" href="#基本概念"></a> 基本概念</h2><h3 id="mqtt-客户端"><a class="headerlink" href="#mqtt-客户端"></a> MQTT 客户端</h3><ul><li>发布消息</li><li>订阅消息</li><li>退订或删除消息</li><li>断开与服务器连接</li></ul><h3 id="mqtt-服务端-broker消息代理"><a class="headerlink" href="#mqtt-服务端-broker消息代理"></a> MQTT 服务端 Broker（消息代理）</h3><ul><li>接受来自客户端的网络连接</li><li>接受客户端发布的应用信息</li><li>处理来自客户端的订阅和退订请求</li><li>向订阅的客户转发应用程序消息</li></ul><h3 id="主题topic"><a class="headerlink" href="#主题topic"></a> 主题（topic）</h3><p>连接到一个应用程序消息的标签，该标签与服务器的订阅相匹配。服务器会将消息发送给订阅所匹配标签的每个客户端。</p><p>要订阅的主题。一个主题可以有多个级别，级别之间用斜杠字符分隔。例如，/world 和 emq/emqtt/emqx 是有效的主题。</p><p>订阅者的Topic name支持通配符#和+ ：</p><ul><li>#支持一个主题内任意级别话题</li><li>+只匹配一个主题级别的通配符</li></ul><p>客户端成功订阅某个主题后，代理会返回一条 SUBACK 消息，其中包含一个或多个 returnCode 参数</p><h3 id="主题筛选器topic-filter"><a class="headerlink" href="#主题筛选器topic-filter"></a> 主题筛选器（Topic Filter）</h3><p>一个对主题名通配符筛选器，在订阅表达式中使用，表示订阅所匹配到的多个主题。</p><h3 id="qos消息传递的服务质量水平"><a class="headerlink" href="#qos消息传递的服务质量水平"></a> QoS（消息传递的服务质量水平）</h3><p>服务质量，标志表明此主题范围内的消息传送到客户端所需的一致程度。</p><ul><li>值 0：不可靠，消息基本上仅传送一次，如果当时客户端不可用，则会丢失该消息。</li><li>值 1：消息应传送至少 1 次。</li><li>值 2：消息仅传送一次。</li></ul><h3 id=""><a class="headerlink" href="#"></a> </h3>]]></content>
      
      
      <categories>
          
          <category> iot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iot </tag>
            
            <tag> mqtt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IOT[0]-设备接入&amp;数据流转架构设计图</title>
      <link href="/2019/08/01/iot-0/"/>
      <url>/2019/08/01/iot-0/</url>
      
        <content type="html"><![CDATA[<p><img src="https://image-1257148187.cos.ap-chengdu.myqcloud.com/picgo_img/20190801162249.jpg" alt="IOT设备接入&amp;数据流转架构设计图"><span class="image-caption">IOT设备接入&amp;数据流转架构设计图</span></p>]]></content>
      
      
      <categories>
          
          <category> iot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iot </tag>
            
            <tag> framework </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring cloud health - actuator相关</title>
      <link href="/2019/07/15/spring-cloud-health/"/>
      <url>/2019/07/15/spring-cloud-health/</url>
      
        <content type="html"><![CDATA[<h2 id="eureka-health-前置"><a class="headerlink" href="#eureka-health-前置"></a> Eureka Health 前置</h2><ul><li>spring boot/cloud 版本 2.0.1</li><li>JDK 1.8</li></ul><p>默认情况下注册到eureka server的服务是通过心跳来告知自己是UP还是DOWN，并不是通过spring-boot-actuator模块的/health端点来实现的。<br>默认的心跳实现方式可以有效的检查eureka客户端进程是否正常运作，但是无法保证客户端应用能够正常提供服务。由于大多数微服务应用都会有一些其他的外部资源依赖，比如数据库，REDIS缓存等，如果我们的应用与这些外部资源无法连通的时候，实际上已经不能提供正常的对外服务了，但因为客户端心跳依然在运行，所以它还是会被服务消费者调用，而这样的调用实际上并不能获得预期的后果。</p><p>我们可以通过在eureka客户端中配置:<code>eureka.client.healthcheck.enabled=true</code>，就可以改变eureka server对客户端健康检测的方式，改用actuator的/health端点来检测。</p><h2 id="关于-spring-boot-starter-actuator"><a class="headerlink" href="#关于-spring-boot-starter-actuator"></a> 关于 spring-boot-starter-actuator</h2><h3 id="依赖"><a class="headerlink" href="#依赖"></a> 依赖</h3><p><code>org.springframework.boot:spring-boot-starter-actuator</code></p><h3 id="api"><a class="headerlink" href="#api"></a> API</h3><p><code>http://ip:port/[project-content-path]/actuator/**</code></p><p><strong>以前的版本是没有/actuator前缀的，2.0以后的版本都加了/actuator前缀</strong></p><p>默认情况下，actuator只暴露了 <code>/health</code> 和 <code>/info</code> 两个接口，其他接口可以在yml中添加如下配置打开：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line"><span class="attr">  endpoints:</span></span><br><span class="line"><span class="attr">    web:</span></span><br><span class="line"><span class="attr">      exposure:</span></span><br><span class="line"><span class="attr">        include:</span> <span class="string">"*"</span></span><br></pre></td></tr></table></figure><ul><li><p>查看支持的api列表：<code>http://ip:port/[project-content-path]/actuator</code><br>返回：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"_links"</span>: &#123;</span><br><span class="line">    <span class="attr">"self"</span>: &#123;</span><br><span class="line">      <span class="attr">"href"</span>: <span class="string">"http://192.168.9.73:19342/actuator"</span>,</span><br><span class="line">      <span class="attr">"templated"</span>: <span class="literal">false</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"archaius"</span>: &#123;</span><br><span class="line">      <span class="attr">"href"</span>: <span class="string">"http://192.168.9.73:19342/actuator/archaius"</span>,</span><br><span class="line">      <span class="attr">"templated"</span>: <span class="literal">false</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"auditevents"</span>: &#123;</span><br><span class="line">      <span class="attr">"href"</span>: <span class="string">"http://192.168.9.73:19342/actuator/auditevents"</span>, </span><br><span class="line">      <span class="attr">"templated"</span>: <span class="literal">false</span> 显示应用暴露的审计事件 (比如认证进入、失败)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"beans"</span>: &#123;</span><br><span class="line">      <span class="attr">"href"</span>: <span class="string">"http://192.168.9.73:19342/actuator/beans"</span>,</span><br><span class="line">      <span class="attr">"templated"</span>: <span class="literal">false</span> 加载的bean列表</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"health"</span>: &#123;</span><br><span class="line">      <span class="attr">"href"</span>: <span class="string">"http://192.168.9.73:19342/actuator/health"</span>,</span><br><span class="line">      <span class="attr">"templated"</span>: <span class="literal">false</span> 健康状态 up down</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"conditions"</span>: &#123;</span><br><span class="line">      <span class="attr">"href"</span>: <span class="string">"http://192.168.9.73:19342/actuator/conditions"</span>,</span><br><span class="line">      <span class="attr">"templated"</span>: <span class="literal">false</span> 显示在配置和自动配置类上评估的条件以及它们匹配或不匹配的原因</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"configprops"</span>: &#123;</span><br><span class="line">      <span class="attr">"href"</span>: <span class="string">"http://192.168.9.73:19342/actuator/configprops"</span>,</span><br><span class="line">      <span class="attr">"templated"</span>: <span class="literal">false</span> 显示所有的配置列表 @ConfigurationProperties</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"env"</span>: &#123;</span><br><span class="line">      <span class="attr">"href"</span>: <span class="string">"http://192.168.9.73:19342/actuator/env"</span>,</span><br><span class="line">      <span class="attr">"templated"</span>: <span class="literal">false</span> 环境变量信息</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"env-toMatch"</span>: &#123;</span><br><span class="line">      <span class="attr">"href"</span>: <span class="string">"http://192.168.9.73:19342/actuator/env/&#123;toMatch&#125;"</span>,</span><br><span class="line">      <span class="attr">"templated"</span>: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"info"</span>: &#123;</span><br><span class="line">      <span class="attr">"href"</span>: <span class="string">"http://192.168.9.73:19342/actuator/info"</span>,</span><br><span class="line">      <span class="attr">"templated"</span>: <span class="literal">false</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"loggers"</span>: &#123;</span><br><span class="line">      <span class="attr">"href"</span>: <span class="string">"http://192.168.9.73:19342/actuator/loggers"</span>,</span><br><span class="line">      <span class="attr">"templated"</span>: <span class="literal">false</span> 日志埋点信息</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"loggers-name"</span>: &#123;</span><br><span class="line">      <span class="attr">"href"</span>: <span class="string">"http://192.168.9.73:19342/actuator/loggers/&#123;name&#125;"</span>,</span><br><span class="line">      <span class="attr">"templated"</span>: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"heapdump"</span>: &#123;</span><br><span class="line">      <span class="attr">"href"</span>: <span class="string">"http://192.168.9.73:19342/actuator/heapdump"</span>,</span><br><span class="line">      <span class="attr">"templated"</span>: <span class="literal">false</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"threaddump"</span>: &#123;</span><br><span class="line">      <span class="attr">"href"</span>: <span class="string">"http://192.168.9.73:19342/actuator/threaddump"</span>,</span><br><span class="line">      <span class="attr">"templated"</span>: <span class="literal">false</span> 执行线程转储</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"metrics-requiredMetricName"</span>: &#123;</span><br><span class="line">      <span class="attr">"href"</span>: <span class="string">"http://192.168.9.73:19342/actuator/metrics/&#123;requiredMetricName&#125;"</span>,</span><br><span class="line">      <span class="attr">"templated"</span>: <span class="literal">true</span> 显示当前应用程序的“指标”信息</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"metrics"</span>: &#123;</span><br><span class="line">      <span class="attr">"href"</span>: <span class="string">"http://192.168.9.73:19342/actuator/metrics"</span>,</span><br><span class="line">      <span class="attr">"templated"</span>: <span class="literal">false</span> 显示当前应用程序的“指标”信息名称列表（requiredMetricName 列表）</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"scheduledtasks"</span>: &#123;</span><br><span class="line">      <span class="attr">"href"</span>: <span class="string">"http://192.168.9.73:19342/actuator/scheduledtasks"</span>,</span><br><span class="line">      <span class="attr">"templated"</span>: <span class="literal">false</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"httptrace"</span>: &#123;</span><br><span class="line">      <span class="attr">"href"</span>: <span class="string">"http://192.168.9.73:19342/actuator/httptrace"</span>,</span><br><span class="line">      <span class="attr">"templated"</span>: <span class="literal">false</span> 最近的<span class="number">100</span>个（默认）http请求信息</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"mappings"</span>: &#123;</span><br><span class="line">      <span class="attr">"href"</span>: <span class="string">"http://192.168.9.73:19342/actuator/mappings"</span>,</span><br><span class="line">      <span class="attr">"templated"</span>: <span class="literal">false</span> 显示所有@RequestMapping路径的整理列表</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"refresh"</span>: &#123;</span><br><span class="line">      <span class="attr">"href"</span>: <span class="string">"http://192.168.9.73:19342/actuator/refresh"</span>,</span><br><span class="line">      <span class="attr">"templated"</span>: <span class="literal">false</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"features"</span>: &#123;</span><br><span class="line">      <span class="attr">"href"</span>: <span class="string">"http://192.168.9.73:19342/actuator/features"</span>,</span><br><span class="line">      <span class="attr">"templated"</span>: <span class="literal">false</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"service-registry"</span>: &#123;</span><br><span class="line">      <span class="attr">"href"</span>: <span class="string">"http://192.168.9.73:19342/actuator/service-registry"</span>,</span><br><span class="line">      <span class="attr">"templated"</span>: <span class="literal">false</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"hystrix.stream"</span>: &#123;</span><br><span class="line">      <span class="attr">"href"</span>: <span class="string">"http://192.168.9.73:19342/actuator/hystrix.stream"</span>,</span><br><span class="line">      <span class="attr">"templated"</span>: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>更多说明：<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/production-ready-endpoints.html" target="_blank" rel="noopener">https://docs.spring.io/spring-boot/docs/current/reference/html/production-ready-endpoints.html</a></p></blockquote></li></ul><h2 id="health-相关"><a class="headerlink" href="#health-相关"></a> /health 相关</h2><p><code>http://ip:port/[project-content-path]/actuator/health</code><br>默认只会显示status状态值 up 或者 down，如果需要显示详细详细需要在配置中设置：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line"><span class="attr">  endpoint:</span></span><br><span class="line"><span class="attr">    health:</span></span><br><span class="line"><span class="attr">      show-details:</span> <span class="string">always</span> </span><br><span class="line">      <span class="comment"># 默认为 'never' 永远不显示</span></span><br><span class="line">      <span class="comment"># 'when-authorized' 详细信息仅向授权用户显示。可以使用配置授权角色 management.endpoint.health.roles。</span></span><br><span class="line">      <span class="comment"># always 始终显示</span></span><br></pre></td></tr></table></figure><h3 id="healthindicators-健康指标"><a class="headerlink" href="#healthindicators-健康指标"></a> HealthIndicators 健康指标</h3><ul><li>默认自带以下健康检测项目：</li></ul><table><thead><tr><th style="text-align:left">名称</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">CassandraHealthIndicator</td><td style="text-align:left">Checks that a Cassandra database is up.</td></tr><tr><td style="text-align:left">CouchbaseHealthIndicator</td><td style="text-align:left">Checks that a Couchbase cluster is up.</td></tr><tr><td style="text-align:left">DiskSpaceHealthIndicator</td><td style="text-align:left">Checks for low disk space.</td></tr><tr><td style="text-align:left">DataSourceHealthIndicator</td><td style="text-align:left">Checks that a connection to DataSource can be obtained.</td></tr><tr><td style="text-align:left">ElasticsearchHealthIndicator</td><td style="text-align:left">Checks that an Elasticsearch cluster is up.</td></tr><tr><td style="text-align:left">InfluxDbHealthIndicator</td><td style="text-align:left">Checks that an InfluxDB server is up.</td></tr><tr><td style="text-align:left">JmsHealthIndicator</td><td style="text-align:left">Checks that a JMS broker is up.</td></tr><tr><td style="text-align:left">MailHealthIndicator</td><td style="text-align:left">Checks that a mail server is up.</td></tr><tr><td style="text-align:left">MongoHealthIndicator</td><td style="text-align:left">Checks that a Mongo database is up.</td></tr><tr><td style="text-align:left">Neo4jHealthIndicator</td><td style="text-align:left">Checks that a Neo4j server is up.</td></tr><tr><td style="text-align:left">RabbitHealthIndicator</td><td style="text-align:left">Checks that a Rabbit server is up.</td></tr><tr><td style="text-align:left">RedisHealthIndicator</td><td style="text-align:left">Checks that a Redis server is up.</td></tr><tr><td style="text-align:left">SolrHealthIndicator</td><td style="text-align:left">Checks that a Solr server is up.</td></tr></tbody></table><ul><li><p>自定义 HealthIndicator</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtendedHealthIndicator</span> <span class="keyword">implements</span> <span class="title">HealthIndicator</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Health <span class="title">health</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> errorCode = check(); <span class="comment">// perform some specific health check 执行自定义的检测逻辑。</span></span><br><span class="line">        <span class="keyword">if</span> (errorCode != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Health.down().withDetail(<span class="string">"Error Code"</span>, errorCode).build();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Health.up().build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">check</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 假装检测到异常</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>/health</code> api中会多返回一个名为Extended的项，如图：<br><img src="https://image-1257148187.cos.ap-chengdu.myqcloud.com/picgo_img/20190715150821.png" alt=""></p><p>同时在eureka中：<br><img src="https://image-1257148187.cos.ap-chengdu.myqcloud.com/picgo_img/20190715151120.png" alt=""></p><h3 id="响应式-healthindicator"><a class="headerlink" href="#响应式-healthindicator"></a> 响应式 HealthIndicator</h3><p>响应式编程相关 spring reactor.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtendedReactiveHealthIndicator</span> <span class="keyword">implements</span> <span class="title">ReactiveHealthIndicator</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono&lt;Health&gt; <span class="title">health</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> doHealthCheck() <span class="comment">//perform some specific health check that returns a Mono&lt;Health&gt;</span></span><br><span class="line">                .onErrorResume(ex -&gt; Mono.just(<span class="keyword">new</span> Health.Builder().down(ex).build())));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="loggers-相关"><a class="headerlink" href="#loggers-相关"></a> /loggers 相关</h2><ul><li><p>查看<br><code>http://ip:port/[project-content-path]/actuator/loggers</code><br>查看应用中可配置的loggers的列表和相关的日志等级。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"levels"</span>: [</span><br><span class="line">    <span class="string">"OFF"</span>,</span><br><span class="line">    <span class="string">"ERROR"</span>,</span><br><span class="line">    <span class="string">"WARN"</span>,</span><br><span class="line">    <span class="string">"INFO"</span>,</span><br><span class="line">    <span class="string">"DEBUG"</span>,</span><br><span class="line">    <span class="string">"TRACE"</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"loggers"</span>: &#123;</span><br><span class="line">    <span class="attr">"ROOT"</span>: &#123;</span><br><span class="line">      <span class="attr">"configuredLevel"</span>: <span class="string">"INFO"</span>,</span><br><span class="line">      <span class="attr">"effectiveLevel"</span>: <span class="string">"INFO"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"com"</span>: &#123;</span><br><span class="line">      <span class="attr">"configuredLevel"</span>: <span class="literal">null</span>,</span><br><span class="line">      <span class="attr">"effectiveLevel"</span>: <span class="string">"INFO"</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>查看某一项<br><code>http://ip:port/[project-content-path]/actuator/loggers</code></p></li><li><p>运行时改变日志等级<br>使用POST请求可以修改某一项的日志等级,例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">POST http://ip:port/[project-content-path]/actuator/loggers/ROOT</span><br><span class="line">body:</span><br><span class="line">&#123;</span><br><span class="line"> &quot;configuredLevel&quot;: &quot;INFO&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> dev </category>
          
          <category> spring cloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Cloud Health </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ElasticSearch[7]-映射(mapping)</title>
      <link href="/2019/07/10/es-7/"/>
      <url>/2019/07/10/es-7/</url>
      
        <content type="html"><![CDATA[<p>当ES在文档中探测到新的字符串字段将默认设置为全文string字段并使用标准分析器（standard）分析。为了使用更适合的分析器或者不做任何处理，则需要使用映射（mapping）。</p><p>之前提到每个文档都有一个类型（type），每个类型都有一个映射（mapping）或者模式定义（schema definition）一个映射定义了字段类型，每个字段的数据类型，以及字段被Elasticsearch处理的方式。映射还用于设置关联到类型上的元数据。</p><h2 id="查看映射"><a class="headerlink" href="#查看映射"></a> 查看映射</h2><p><code>GET /{index}/_mapping/{type}</code></p><p>例如：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">GET /gb/_mapping/tweet</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"gb"</span>: &#123;</span><br><span class="line">    <span class="attr">"mappings"</span>: &#123;</span><br><span class="line">      <span class="attr">"tweet"</span>: &#123;</span><br><span class="line">        <span class="attr">"properties"</span>: &#123;</span><br><span class="line">          <span class="attr">"date"</span>: &#123;</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"date"</span>,</span><br><span class="line">            <span class="attr">"format"</span>: <span class="string">"strict_date_optional_time||epoch_millis"</span></span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="attr">"name"</span>: &#123;</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"string"</span></span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="attr">"tweet"</span>: &#123;</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"string"</span></span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="attr">"user_id"</span>: &#123;</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"long"</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="自定义字段映射"><a class="headerlink" href="#自定义字段映射"></a> 自定义字段映射</h2><p>自定义字段映射可以：</p><ul><li>区分全文（full text）字符串字段和准确字符串字段。</li><li>使用特定语言的分析器</li><li>优化部分匹配字段</li><li>指定自定义日期格式</li><li>…</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"tag"</span>: &#123;</span><br><span class="line">    <span class="attr">"type"</span>: <span class="string">"string"</span>,</span><br><span class="line">    <span class="attr">"index"</span>: <span class="string">"not_analyzed"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>type用于标记tag为string类型</p></li><li><p>index如下：</p><table><thead><tr><th style="text-align:left">index的值</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">analyzed 默认值</td><td style="text-align:left">首先分析这个字符串，然后索引。</td></tr><tr><td style="text-align:left">not_analyzed</td><td style="text-align:left">索引这个字段，使之可以被搜索，但是索引内容和指定值一样。</td></tr><tr><td style="text-align:left">no</td><td style="text-align:left">不索引这个字段。这个字段不能为搜索到。</td></tr></tbody></table><blockquote><p>其他简单类型（ long 、 double 、 date 等等）也接受 index 参数，但相应的值只能是 no 和 not_analyzed ，它们的值不能被分析。</p></blockquote></li><li><p>analyzer<br>对于 analyzed 类型的字符串字段，使用 analyzer 参数来指定哪一种分析器将在搜索和索引的时候使用。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"tweet"</span>: &#123;</span><br><span class="line">    <span class="attr">"type"</span>: <span class="string">"string"</span>,</span><br><span class="line">    <span class="attr">"analyzer"</span>: <span class="string">"english"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="更新映射"><a class="headerlink" href="#更新映射"></a> 更新映射</h2><p>可以在第一次创建索引的时候指定映射的类型。也可以晚些时候为新类型添加映射（或者为已有的类型更新映射）。</p><p><strong>可以向已有映射中增加字段，但不能修改它。如果一个字段在映射中已经存在，这可能意味着那个字段的数据已经被索引。如果你改变了字段映射，那已经被索引的数据将错误并且不能被正确的搜索到。</strong></p><h2 id="复合对象的索引结构"><a class="headerlink" href="#复合对象的索引结构"></a> 复合对象的索引结构</h2><p>对于复杂对象的mapping ：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"gb"</span>: &#123;</span><br><span class="line">    <span class="attr">"tweet"</span>: &#123;</span><br><span class="line">      <span class="attr">"properties"</span>: &#123;</span><br><span class="line">        <span class="attr">"tweet"</span>: &#123;</span><br><span class="line">          <span class="attr">"type"</span>: <span class="string">"string"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"user"</span>: &#123;</span><br><span class="line">          <span class="attr">"type"</span>: <span class="string">"object"</span>,</span><br><span class="line">          <span class="attr">"properties"</span>: &#123;</span><br><span class="line">            <span class="attr">"id"</span>: &#123;</span><br><span class="line">              <span class="attr">"type"</span>: <span class="string">"string"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"gender"</span>: &#123;</span><br><span class="line">              <span class="attr">"type"</span>: <span class="string">"string"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"age"</span>: &#123;</span><br><span class="line">              <span class="attr">"type"</span>: <span class="string">"long"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"name"</span>: &#123;</span><br><span class="line">              <span class="attr">"type"</span>: <span class="string">"object"</span>,</span><br><span class="line">              <span class="attr">"properties"</span>: &#123;</span><br><span class="line">                <span class="attr">"full"</span>: &#123;</span><br><span class="line">                  <span class="attr">"type"</span>: <span class="string">"string"</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">"first"</span>: &#123;</span><br><span class="line">                  <span class="attr">"type"</span>: <span class="string">"string"</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">"last"</span>: &#123;</span><br><span class="line">                  <span class="attr">"type"</span>: <span class="string">"string"</span></span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"tweet"</span>: <span class="string">"Elasticsearch is very flexible"</span>,</span><br><span class="line">  <span class="attr">"user"</span>: &#123;</span><br><span class="line">    <span class="attr">"id"</span>: <span class="string">"@johnsmith"</span>,</span><br><span class="line">    <span class="attr">"gender"</span>: <span class="string">"male"</span>,</span><br><span class="line">    <span class="attr">"age"</span>: <span class="number">26</span>,</span><br><span class="line">    <span class="attr">"name"</span>: &#123;</span><br><span class="line">      <span class="attr">"full"</span>: <span class="string">"John Smith"</span>,</span><br><span class="line">      <span class="attr">"first"</span>: <span class="string">"John"</span>,</span><br><span class="line">      <span class="attr">"last"</span>: <span class="string">"Smith"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 其索引方式为平铺的单层结构：</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"tweet"</span>: [elasticsearch, flexible, very],</span><br><span class="line">  <span class="attr">"user.id"</span>: [@johnsmith],</span><br><span class="line">  <span class="attr">"user.gender"</span>: [male],</span><br><span class="line">  <span class="attr">"user.age"</span>: [<span class="number">26</span>],</span><br><span class="line">  <span class="attr">"user.name.full"</span>: [john, smith],</span><br><span class="line">  <span class="attr">"user.name.first"</span>: [john],</span><br><span class="line">  <span class="attr">"user.name.last"</span>: [smith]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"followers"</span>: [</span><br><span class="line">    &#123; <span class="attr">"age"</span>: <span class="number">35</span>, <span class="attr">"name"</span>: <span class="string">"Mary White"</span>&#125;,</span><br><span class="line">    &#123; <span class="attr">"age"</span>: <span class="number">26</span>, <span class="attr">"name"</span>: <span class="string">"Alex Jones"</span>&#125;,</span><br><span class="line">    &#123; <span class="attr">"age"</span>: <span class="number">19</span>, <span class="attr">"name"</span>: <span class="string">"Lisa Smith"</span>&#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 其索引方式为平铺的单层结构：</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"followers.age"</span>: [<span class="number">19</span>, <span class="number">26</span>, <span class="number">35</span>],</span><br><span class="line">  <span class="attr">"followers.name"</span>: [alex, jones, lisa, smith, mary, white]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> dev </category>
          
          <category> ElasticSearch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ElasticSearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL[3]-收藏：不知道是哪里来的MySQL优化导图</title>
      <link href="/2019/07/09/db-5/"/>
      <url>/2019/07/09/db-5/</url>
      
        <content type="html"><![CDATA[<p>图是高清的 自己转存看吧~</p><p><img src="https://image-1257148187.cos.ap-chengdu.myqcloud.com/picgo_img/20190709161458.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> dev </category>
          
          <category> database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ElasticSearch[6]-分析(analysis)</title>
      <link href="/2019/07/08/es-6/"/>
      <url>/2019/07/08/es-6/</url>
      
        <content type="html"><![CDATA[<h2 id="分析和分析器"><a class="headerlink" href="#分析和分析器"></a> 分析和分析器</h2><p>分析(analysis)是这样一个过程：</p><ol><li>标记化一个文本块为适用于倒排索引单独的词(term)</li><li>标准化这些词为标准形式，提高它们的“可搜索性”或“查全率”</li></ol><p>这个过程由分析器完成，一个分析器包含：</p><ul><li>字符过滤器<br>首先字符串经过字符串过滤器(character filter),用来在标记化前处理字符串，比如去除HTML标签或者转换“&amp;”为“and”</li><li>分词器<br>分词器(tokenizer)根据内建的算法机制对字符串进行词切分，形成单独的词。</li><li>标记过滤<br>标记过滤(token filters)可以修改词（比如大小写转换）、去掉词（比如去掉停用词“the”“and”“a”）、增加词（比如同义词）</li></ul><h3 id="内建分析器"><a class="headerlink" href="#内建分析器"></a> 内建分析器</h3><p>实例文本：<code>&quot;Set the shape to semi-transparent by calling set_trans(5)&quot;</code></p><ul><li>标准分析器<br>它根据Unicode Consortium的定义的单词边界(word boundaries)来切分文本，然后去掉大部分标点符号。最后，把所有词转为小写。<br><code>set, the, shape, to, semi, transparent, by, calling, set_trans, 5</code></li><li>简单分析器<br>将非单个字母的文本切分，然后把每个词转为小写。<br><code>set, the, shape, to, semi, transparent, by, calling, set, trans</code></li><li>空格分析器<br>依据空格切分文本。它不转换小写。<br><code>Set, the, shape, to, semi-transparent, by, calling, set_trans(5)</code></li><li>语言分析器<br>特定语言分析器适用于很多语言。它们能够考虑到特定语言的特性。<br>例如， english 分析器自带一套英语停用词库——像 and 或 the 这些与语义无关的通用词。这些词被移除后，因为语法规则的存在，英语单词的主体含义依旧能被理解。<br><code>set, shape, semi, transpar, call, set_tran, 5</code><br><em>注意 “transparent” 、 “calling” 和 “set_trans” 是如何转为词干的。</em></li></ul><blockquote><p>当我们索引(index)一个文档，全文字段会被分析为单独的词来创建倒排索引。不过，当我们在全文字段搜索(search)时，我们要让查询字符串经过同样的分析流程处理，以确保这些词在索引中存在。<br>全文查询我们将在稍后讨论，理解每个字段是如何定义的，这样才可以让它们做正确的事：<br>当你查询全文(full text)字段，查询将使用相同的分析器来分析查询字符串，以产生正确的词列表。<br>当你查询一个确切值(exact value)字段，查询将不分析查询字符串，但是你可以自己指定。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> dev </category>
          
          <category> ElasticSearch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ElasticSearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ElasticSearch[5]-正片：映射(mapping)&amp;分词(analysis)前置</title>
      <link href="/2019/07/08/es-5/"/>
      <url>/2019/07/08/es-5/</url>
      
        <content type="html"><![CDATA[<h2 id="定义"><a class="headerlink" href="#定义"></a> 定义</h2><ul><li>映射(mapping)机制用于进行字段类型确认，将每个字段匹配为一种确定的数据类型(string,number,booleans,date等)。</li><li>分析(analysis)机制用于进行全文文本(Full Text)的分词，以建立供搜索用的反向索引。</li></ul><h2 id="映射-分词"><a class="headerlink" href="#映射-分词"></a> 映射 &amp; 分词</h2><p>ElasticSearch 会对每一个type进行mapping：通过以下指令可以查看</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">GET /&#123;index&#125;/_mapping/&#123;type&#125;/</span><br><span class="line"></span><br><span class="line"># 返回(示例)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"gb"</span>: &#123;</span><br><span class="line">    <span class="attr">"mappings"</span>: &#123;</span><br><span class="line">      <span class="attr">"tweet"</span>: &#123;</span><br><span class="line">        <span class="attr">"properties"</span>: &#123;</span><br><span class="line">          <span class="attr">"date"</span>: &#123;</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"date"</span>,</span><br><span class="line">            <span class="attr">"format"</span>: <span class="string">"dateOptionalTime"</span></span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="attr">"name"</span>: &#123;</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"string"</span></span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="attr">"tweet"</span>: &#123;</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"string"</span></span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="attr">"user_id"</span>: &#123;</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"long"</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出 ES对每一个字段进行猜想动态生成了字段和类型的映射关系。比如date字段的类型date，而在_all字段中date的值则是string。那么问题来了，假如使用以下方式进行检索：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET /_search?q=2019</span><br><span class="line">GET /_search?q=date:2019</span><br></pre></td></tr></table></figure><p>将会得到不一样的结果，因为date类型和string类型的索引方式是不一样的，索引会导致查询结果不一致。</p><blockquote><p>你会期望每一种核心数据类型(strings, numbers, booleans及dates)以不同的方式进行索引，而这点也是现实：在Elasticsearch中他们是被区别对待的。<br>但是更大的区别在于确切值(exact values)(比如 string 类型)及全文文本(full text)之间。<br>这两者的区别才真的很重要 - 这是区分搜索引擎和其他数据库的根本差异。<br>——《ES权威指南（第三版）》</p></blockquote><h2 id="确切值exact-values-全文文本full-text"><a class="headerlink" href="#确切值exact-values-全文文本full-text"></a> 确切值(Exact values) &amp; 全文文本(Full text)</h2><p>Elasticsearch 中的数据可以大致分为两种类型：确切值 及 全文文本。</p><p>确切值 类似于一种结构化的数据值，（是什么就是什么，类似于equals），所以的大小写区别、前缀一致等形式的&quot;等价&quot;都是不成立了。<br>而 全文本 则是一种类似与 非结构化的数据值。（实际上是一种高度结构化的数据）<br>因此，对于确切值来说，他的查询时很简单的，要么匹配，要么不匹配。不会像全文本一样需要对其进行语言的分析以及相关度高低来进行评判。<br>为此，ElasticSearch 使用了全文本分析（analyzes），然后建立 <strong>倒排索引</strong>。</p><h2 id="倒排索引"><a class="headerlink" href="#倒排索引"></a> 倒排索引</h2><p>倒排索引由文档中出现的唯一的单词列表，以及对于每一个单词在文档中的位置组成。</p><p>实例：<br>例如，我们有两个文档，每个文档 content 字段包含：</p><ol><li>The quick brown fox jumped over the lazy dog</li><li>Quick brown foxes leap over lazy dogs in summer<br>为了创建倒排索引，我们首先切分每个文档的 content 字段为单独的单词（我们把它们叫做词(terms)或者表征(tokens)）（译者注：关于 terms 和 tokens 的翻译比较生硬，只需知道语句分词后的个体叫做这两个。），把所有的唯一词放入列表并排序，结果是这个样子的：<br><img src="https://image-1257148187.cos.ap-chengdu.myqcloud.com/picgo_img/20190708104904.png" alt=""><br>现在，如果我们想搜索 “quick brown” ，我们只需要找到每个词在哪个文档中出现即可：<br><img src="https://image-1257148187.cos.ap-chengdu.myqcloud.com/picgo_img/20190708104931.png" alt=""></li></ol><p>但是这里依然存在一些问题，之前说的全文搜索应当是一种符合语义的，所以对于其中一些单词的语义、词性的相似度进行比较。所以考虑到这些因素之后的相似度比较就不再那么单纯了。<br>此时就需要一个标准化的过程：<strong>分词（(analysis)）</strong></p>]]></content>
      
      
      <categories>
          
          <category> dev </category>
          
          <category> ElasticSearch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ElasticSearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ElasticSearch[4]-正片：搜索</title>
      <link href="/2019/07/03/es-4/"/>
      <url>/2019/07/03/es-4/</url>
      
        <content type="html"><![CDATA[<h2 id="映射-分析-领域特定语言查询dsl"><a class="headerlink" href="#映射-分析-领域特定语言查询dsl"></a> 映射 &amp; 分析 &amp; 领域特定语言查询（dsl）</h2><table><thead><tr><th style="text-align:left">概念</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">映射(Mapping)</td><td style="text-align:left">数据在每个字段中的解释说明</td></tr><tr><td style="text-align:left">分析(Analysis)</td><td style="text-align:left">全文是如何处理的可以被搜索的</td></tr><tr><td style="text-align:left">领域特定语言查询(Query DSL)</td><td style="text-align:left">Elasticsearch使用的灵活的、强大的查询语言</td></tr></tbody></table><h2 id="多索引-多类别"><a class="headerlink" href="#多索引-多类别"></a> 多索引 &amp; 多类别</h2><p>通过限制搜索的不同索引或类型，可以在集群中跨所有文档搜索。</p><p>指定索引的搜索，可以是通配符的形式，也可以是多个索引：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/&#123;index&#125;,&#123;index&#125;/&#123;type&#125;,&#123;type&#125;/_search</span><br><span class="line"></span><br><span class="line"># 通配符</span><br><span class="line">/g*,u*/x*,y*/_search</span><br></pre></td></tr></table></figure><h2 id="分页"><a class="headerlink" href="#分页"></a> 分页</h2><p>ES接受 from 和 size 参数进行分页查询：</p><ul><li>from 跳过开始的结果数 默认0</li><li>size 结果数 默认10</li></ul><p>例如：<code>/_search?from=10&amp;size=20</code></p><h3 id="分页搜索方式"><a class="headerlink" href="#分页搜索方式"></a> 分页搜索方式</h3><p>ES的搜索可能会涉及到多个分片，Elasticsearch 会转发搜索请求到这个索引的主分片或每个分片的复<br>制分片上，然后聚集每个分片的结果。假如搜索的size是10，那么ES会去检索每个分片上各自符合条件的数据进行排序，并返回10个结果，最后会在请求节点上对所有的结果进行排序并返回，以此保证最终结果的顺序正确。</p><blockquote><p>在集群系统中深度分页<br>为了理解为什么深度分页是有问题的，假设在一个有5个主分片的索引中搜索。当请求结果的第一页（结果1到10）时，每个分片产生自己最顶端10个结果然后返回它们给请求节点(requesting node)，它再排序这所有的50个结果以选出顶端的10个结果。现在假设请求第1000页——结果10001到10010。工作方式都相同，不同的是每个分片都必须产生顶端的10010个结果。然后请求节点排序这50050个结果并丢弃50040个！可以看到在分布式系统中，排序结果的花费随着分页的深入而成倍增长。这也是为什么网络搜索引擎中任何语句不能返回多于1000个结果的原因。</p></blockquote><h2 id="简易搜索-复杂搜索"><a class="headerlink" href="#简易搜索-复杂搜索"></a> 简易搜索 &amp; 复杂搜索</h2><p>search API有两种表单：</p><ul><li>一种是“简易版”的查询字符串(query string)将所有参数通过查询字符串定义</li><li>另一种版本使用JSON完整的表示请求体(request body)，这种富搜索语言叫做结构化查询语句（DSL）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 查询 type类型的‘name’字段为tom的文档</span><br><span class="line">GET /_all/&#123;type&#125;/_search?q=name:tom</span><br><span class="line"></span><br><span class="line"># 包含与不包含：‘+’，‘-’</span><br><span class="line">GET /_all/&#123;type&#125;/_search?q=+name:tom-name:jerry</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># name 包含 ‘tom’或‘jerry’</span><br><span class="line"># date 晚于 1993-01-20</span><br><span class="line">q=+name:(tom,jerry)+date:&gt;1993-01-20</span><br></pre></td></tr></table></figure><blockquote><p>这这搜索方式搜索不便之处在于：容易出现语法错误而导致返回错误的搜索结果以及慢查询。<br>因此，一般在生产环境中我们通常会使用请求体搜索API。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> dev </category>
          
          <category> ElasticSearch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ElasticSearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ElasticSearch[3]-分布式中CRUD机制</title>
      <link href="/2019/07/02/es-3/"/>
      <url>/2019/07/02/es-3/</url>
      
        <content type="html"><![CDATA[<h2 id="分片路由"><a class="headerlink" href="#分片路由"></a> 分片路由</h2><p>ES通过hash取模的算法来分配索引或创建一个文档该如何存储在哪一个分片中。</p><p><code>shard = hash(routing) % number_of_primary_shards</code></p><p>routing 值是一个任意字符串，它默认是 _id 但也可以自定义。routing 字符串通过哈希函数生成一个数字，然后除以主切片的数量得到一个余数(remainder)，余数的范围永远是 0 到 number_of_primary_shards - 1 ，这个数字就是特定文档所在的分片。</p><blockquote><p>这也是为什么之前所说的 主分片在的数量只能在索引创建时定义且不可修改。如果修改了那么所有的路由值将失效，文档讲无法找到。除非重构索引。</p></blockquote><h2 id="主分片与复制分片的交互"><a class="headerlink" href="#主分片与复制分片的交互"></a> 主分片与复制分片的交互</h2><p>假设有以下三个node的集群模式：</p><p><img src="https://image-1257148187.cos.ap-chengdu.myqcloud.com/picgo_img/20190702101230.png" alt=""></p><p>请求可以发送到集群中的任意一个node上，每个node都有处理请求的能力，并且每个node都知道任意文档所在的node，所以也可以将请求转发到对应的node。</p><blockquote><p>所以，基于以上的能力，可以把请求循环或者其他负载均衡的方式平均发送到所有的节点上。以实现负载。</p></blockquote><h2 id="crud文档"><a class="headerlink" href="#crud文档"></a> CRUD文档</h2><p>写操作(新增、修改、删除)必须在主分片上完成才能同步到相关的复制分片上。</p><p><img src="https://image-1257148187.cos.ap-chengdu.myqcloud.com/picgo_img/20190702140030.png" alt=""></p><ol><li>客户端请求发送到node1</li><li>node1 根据 _id确定文档属于shard0，转发请求到node3</li><li>node3处理请求后转发到node1和node2上的复制分片，当所有复制分片报告成功，node3报告成功给node1(请求接受节点)，node1报告给客户端</li></ol><p>有很多可选的请求参数允许你更改这一过程：</p><ul><li>replication<br>默认replication=sync，即复制完成后才返回客户端报告，也可以修改为 async 这时客户端是无法确认是否完成复制的</li><li>consistency<br>默认主分片在尝试写入时需要规定数量(quorum)或过半的分片(可以是主节点或复制节点)可用。这是防止数据被写入到错的网络分区。<br><code>int((primary + number_of_replicas) / 2) + 1</code><br>consistency 允许的值为 one （只有一个主分片）， all （所有主分片和复制分片）或者默认的 quorum 或过半分片。</li><li>timeout</li></ul><h2 id="检索文档"><a class="headerlink" href="#检索文档"></a> 检索文档</h2><p>文档能够从主分片或任意一个复制分片被检索。</p><p><img src="https://image-1257148187.cos.ap-chengdu.myqcloud.com/picgo_img/20190702141657.png" alt=""></p><ol><li>客户端给 node1 发送get请求。</li><li>节点使用文档的 _id 确定文档属于分片0 。分片0 对应的复制分片在三个节点上都有。此时，它转发请求到 node2 。</li><li>node2 返回文档(document)给 node1 然后返回给客户端。</li></ol><p>为了负载均衡，接受请求的node依然会循环把请求转发到其他分片上(即便当前节点已经存在该文档的分片)。<br><strong>如果请求在复制分片中未查到文档，则会再转发到主分片所在的节点进行查询。这样就避免了出现所要查询的数据在主分片尚未来得及复制到复制分片而导致的一致性问题。</strong></p>]]></content>
      
      
      <categories>
          
          <category> dev </category>
          
          <category> ElasticSearch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ElasticSearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ElasticSearch[2]-数据方面的基础概念</title>
      <link href="/2019/07/01/es-2/"/>
      <url>/2019/07/01/es-2/</url>
      
        <content type="html"><![CDATA[<h2 id="文档document"><a class="headerlink" href="#文档document"></a> 文档(document)</h2><p>大多数实体或对象(object)可以序列化位JSON格式的。在ES中，文档(document)特指最顶层的对象(root object)序列化成的JSON数据，并通过唯一标识存储在ES中。</p><h3 id="文档元数据metadata"><a class="headerlink" href="#文档元数据metadata"></a> 文档元数据(metadata)</h3><p>元数据(metadata)是关于文档的信息。</p><table><thead><tr><th style="text-align:center">节点</th><th style="text-align:left">意义</th></tr></thead><tbody><tr><td style="text-align:center">_index</td><td style="text-align:left">文档存储的地方</td></tr><tr><td style="text-align:center">_type</td><td style="text-align:left">文档代表的对象的类型</td></tr><tr><td style="text-align:center">_id</td><td style="text-align:left">文档的唯一标识</td></tr></tbody></table><ul><li>index(索引)<br>即索引，是存储和索引关联数据的地方。实际上数据真正存储在shards中，index只是一个把一个或多个shards分组在一起的逻辑空间。<br>索引的创建只需选择一个索引名称：不可以&quot;_&quot;开头，全部小写，不包含逗号。</li><li>type(类型)<br>相同类型(type)的文档表示相同的“事物”。<br>每个类型(type)都有自己的映射(mapping)或者结构定义，所有类型下的文档被存储在同一个索引下，但是类型的mapping会告诉ES不同的文档如何被索引。<br>_type 的名字可以是大写或小写，不能包含下划线或逗号。</li><li>_id<br>id仅仅是一个字符串，它与 _index 和 _type 组合时，就可以在Elasticsearch中唯一标识一个文档。当创建一个文档，可以自定义 _id ，也可以让ES自动生成。</li></ul><h2 id="索引文档"><a class="headerlink" href="#索引文档"></a> 索引文档</h2><p>文档通过其 _index，_type，_id 唯一确定。</p><h3 id="put-post-创建更新-文档"><a class="headerlink" href="#put-post-创建更新-文档"></a> PUT &amp; POST 创建/更新 文档</h3><p>这里要提到一个机制，在 restful api风格中，put一般表示更新资源，post表示对创建资源。在ES中，put可以理解为：若指定的index、type、id可以找到一个已存在的数据，则对其进行更新操作，否则进行创建。<br>而post因为其id是由ES自动生成的所有始终是创建。</p><p>请求格式如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">PUT /&#123;index&#125;/&#123;type&#125;/&#123;id&#125;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"field"</span>: <span class="string">"value"</span>,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">POST /&#123;index&#125;/&#123;type&#125;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"field"</span>: <span class="string">"value"</span>,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>响应内容：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  "_index": "index_name", &lt;- index名称</span><br><span class="line">  "_type": "type_name", &lt;- type 名称</span><br><span class="line">  "_id": "wM0OSFhDQXGZAWDf0-drSA", &lt;- 如果是PUT 则是传入的ID，如果是POST 则是自动生成的ID字符串</span><br><span class="line">  "_version": 1, &lt;- 版本号</span><br><span class="line">  "created": true &lt;- true表示当前文档是新创建的。false表示已经存在只是更新了该文档，这时也伴随着_version的增加</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Elasticsearch中每个文档都有版本号，每当文档变化（包括删除,以及PUT的数据已存在）都会使 _version 增加。</p><h3 id="get-检索文档"><a class="headerlink" href="#get-检索文档"></a> GET 检索文档</h3><p>请求格式：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET /&#123;index&#125;/&#123;type&#125;/&#123;id&#125;?pretty </span><br><span class="line"></span><br><span class="line">在任意的查询字符串中增加 pretty 参数会让Elasticsearch美化输</span><br><span class="line">出(pretty-print)JSON响应以便更加容易阅读。但_source 字段不会被美化，它的样子与我</span><br><span class="line">们输入的一致</span><br></pre></td></tr></table></figure><p>响应：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"_index"</span> : <span class="string">"index_name"</span>,</span><br><span class="line">  <span class="attr">"_type"</span> : <span class="string">"type_name"</span>,</span><br><span class="line">  <span class="attr">"_id"</span> : <span class="string">"wM0OSFhDQXGZAWDf0-drSA"</span>,</span><br><span class="line">  <span class="attr">"_version"</span> : <span class="number">1</span>,</span><br><span class="line">  <span class="attr">"found"</span> : <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"_source"</span> : &#123;</span><br><span class="line">    <span class="attr">"title"</span>: <span class="string">"My first blog entry"</span>,</span><br><span class="line">    <span class="attr">"text"</span>: <span class="string">"Just trying this out..."</span>,</span><br><span class="line">    <span class="attr">"date"</span>: <span class="string">"2014/01/01"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">"found" : true, &lt;- true 表示找到了数据，false表示未找到数据，此外，HTTP响应状态码也会变成 '404 Not Found' 代替 '200 OK'</span><br></pre></td></tr></table></figure><h3 id="get-检索文档的一部分"><a class="headerlink" href="#get-检索文档的一部分"></a> GET 检索文档的一部分</h3><ol><li>可以使用 _source 参数,值可以是多个字段使用逗号分隔 如下：</li></ol>  <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">GET /website/blog/123?_source=title,text</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"_index"</span> : <span class="string">"website"</span>,</span><br><span class="line">  <span class="attr">"_type"</span> : <span class="string">"blog"</span>,</span><br><span class="line">  <span class="attr">"_id"</span> : <span class="string">"123"</span>,</span><br><span class="line">  <span class="attr">"_version"</span> : <span class="number">1</span>,</span><br><span class="line">  <span class="attr">"exists"</span> : <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"_source"</span> : &#123;</span><br><span class="line">    <span class="attr">"title"</span>: <span class="string">"My first blog entry"</span> ,</span><br><span class="line">    <span class="attr">"text"</span>: <span class="string">"Just trying this out..."</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>只想得到 _source 字段而不要其他的元数据 如下：</li></ol>  <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GET /website/blog/123/_source</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"title"</span>: <span class="string">"My first blog entry"</span>,</span><br><span class="line">  <span class="attr">"text"</span>: <span class="string">"Just trying this out..."</span>,</span><br><span class="line">  <span class="attr">"date"</span>: <span class="string">"2014/01/01"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="head-检查文档是否存在"><a class="headerlink" href="#head-检查文档是否存在"></a> HEAD 检查文档是否存在</h3><p>HEAD 请求不会返回响应体，只有HTTP头，可以通过 Status Code 判断是否存在资源：200存在/404不存在</p><h3 id="重谈关于-put-更新创建-文档"><a class="headerlink" href="#重谈关于-put-更新创建-文档"></a> 重谈：关于 PUT 更新/创建 文档</h3><p>前边已经说过，在ES的机制中 PUT 同时具有创建和更新两种操作，但是为了保证对数据的管理与请求的意愿是一致的。可以通过两种方式保证。</p><ul><li><p>使用 op_type 查询参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PUT /&#123;index&#125;/&#123;type&#125;/&#123;id&#125;?op_type=create</span><br><span class="line">&#123; ... &#125;</span><br></pre></td></tr></table></figure></li><li><p>是在URL后加 /_create 做为端点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PUT /&#123;index&#125;/&#123;type&#125;/&#123;id&#125;/_create</span><br><span class="line">&#123; ... &#125;</span><br></pre></td></tr></table></figure><p>此时，如果正常创建，ES会返回正常的元数据且响应状态码是 201 Created。如果包含相同的 _index 、 _type 和 _id 的文档已经存在，将返回 409 Conflict 响应状态码以及错误信息：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"error"</span> : <span class="string">"DocumentAlreadyExistsException[[website][4] [blog][123]:</span></span><br><span class="line"><span class="string">  document already exists]"</span>,</span><br><span class="line">  <span class="attr">"status"</span> : <span class="number">409</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="delete-删除文档"><a class="headerlink" href="#delete-删除文档"></a> DELETE 删除文档</h3><p>请求格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE /&#123;index&#125;/&#123;type&#125;/&#123;id&#125;</span><br></pre></td></tr></table></figure><p>返回：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">如果找到文档，返回状态 200 ok 响应体：</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"found"</span> : <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"_index"</span> : <span class="string">"website"</span>,</span><br><span class="line">  <span class="attr">"_type"</span> : <span class="string">"blog"</span>,</span><br><span class="line">  <span class="attr">"_id"</span> : <span class="string">"123"</span>,</span><br><span class="line">  <span class="attr">"_version"</span> : <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line">如果未找到文档，返回状态 404 Not Found 响应体：</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"found"</span> : <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">"_index"</span> : <span class="string">"website"</span>,</span><br><span class="line">  <span class="attr">"_type"</span> : <span class="string">"blog"</span>,</span><br><span class="line">  <span class="attr">"_id"</span> : <span class="string">"123"</span>,</span><br><span class="line">  <span class="attr">"_version"</span> : <span class="number">4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>尽管文档不存在 “found” 的值是 false 但是 _version 依旧会增加。这是内部记录的一部分，它确保在多节点间不同操作可以有正确的顺序。</strong></p><h2 id="关于并发操作的问题-本版控制"><a class="headerlink" href="#关于并发操作的问题-本版控制"></a> 关于并发操作的问题 本版控制</h2><p>类似关系型数据库，在高并发的场景下，会出现幻读进而造成数据丢失的情况。</p><p>ES使用<strong>乐观锁</strong>的机制，使用 _version 字段保证所有修改都被正确排序。当一个旧版本出现在新版本之后，它会被简单的忽略。并且可以指定文档的 version 来做想要的更改。如果那个版本号不是现在的，请求就失败了。</p><p>也可以使用外部的本版控制系统，比如使用timestamp，可以在查询字符串后边添加 version_type=external 来使用这些版本号。外部版本号与之前说的内部版本号在处理的时候有些不同。它不再检查 _version 是否与请求中指定的一致，而是检查是否小于指定的版本。如果请求成功，外部版本号就会被存储到 _version 中。比如：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">创建一个包含外部版本号5的新博客：</span><br><span class="line">PUT /website/blog/2?version=5&amp;version_type=external</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"title"</span>: <span class="string">"My first external blog entry"</span>,</span><br><span class="line">  <span class="attr">"text"</span>: <span class="string">"Starting to get the hang of this..."</span></span><br><span class="line">&#125;</span><br><span class="line">在响应中，能看到当前的 _version 号码是5：</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"_index"</span>: <span class="string">"website"</span>,</span><br><span class="line">  <span class="attr">"_type"</span>: <span class="string">"blog"</span>,</span><br><span class="line">  <span class="attr">"_id"</span>: <span class="string">"2"</span>,</span><br><span class="line">  <span class="attr">"_version"</span>: <span class="number">5</span>,</span><br><span class="line">  <span class="attr">"created"</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">现在更新这个文档，指定一个新 version 号码为10：</span><br><span class="line">PUT /website/blog/2?version=10&amp;version_type=external</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"title"</span>: <span class="string">"My first external blog entry"</span>,</span><br><span class="line">  <span class="attr">"text"</span>: <span class="string">"This is a piece of cake..."</span></span><br><span class="line">&#125;</span><br><span class="line">请求成功的设置了当前 _version 为10：</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"_index"</span>: <span class="string">"website"</span>,</span><br><span class="line">  <span class="attr">"_type"</span>: <span class="string">"blog"</span>,</span><br><span class="line">  <span class="attr">"_id"</span>: <span class="string">"2"</span>,</span><br><span class="line">  <span class="attr">"_version"</span>: <span class="number">10</span>,</span><br><span class="line">  <span class="attr">"created"</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">如果重新运行这个请求，就会返回一个像之前一样的冲突错误，因为指定的外部版本号不大于当前在ES中的版本。</span><br></pre></td></tr></table></figure><h2 id="局部更新"><a class="headerlink" href="#局部更新"></a> 局部更新</h2><ul><li><p>通过 /_update api 更新文档，请求表单接受一个局部文档参数 doc：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">POST /website/blog/1/_update</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"doc"</span> : &#123;</span><br><span class="line">    <span class="attr">"tags"</span> : [ <span class="string">"testing"</span> ],</span><br><span class="line">    <span class="attr">"views"</span>: <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用脚本局部更新,</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span></span><br><span class="line">views 字段 +1：</span><br><span class="line">POST /website/blog/1/_update</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"script"</span> : <span class="string">"ctx._source.views+=1"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span></span><br><span class="line">tags数组字段 添加新元素 search：</span><br><span class="line">POST /website/blog/1/_update</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"script"</span> : <span class="string">"ctx._source.tags+=new_tag"</span>,</span><br><span class="line">  <span class="attr">"params"</span> : &#123;</span><br><span class="line">    <span class="attr">"new_tag"</span> : <span class="string">"search"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span></span><br><span class="line">使用 upsert 参数定义文档来使其不存在时被创建</span><br><span class="line">POST /website/pageviews/1/_update</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"script"</span> : <span class="string">"ctx._source.views+=1"</span>,</span><br><span class="line">  <span class="attr">"upsert"</span>: &#123;</span><br><span class="line">    <span class="attr">"views"</span>: <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span></span><br><span class="line">在不关心执行顺序时可以通过 retry_on_conflict 参数设置重试次数来自动完成 值默认为0</span><br><span class="line">POST /website/pageviews/1/_update?retry_on_conflict=5</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"script"</span> : <span class="string">"ctx._source.views+=1"</span>,</span><br><span class="line">  <span class="attr">"upsert"</span>: &#123;</span><br><span class="line">    <span class="attr">"views"</span>: <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">对于需要保证顺序的更新操作，则需要指定version信息</span><br></pre></td></tr></table></figure></li></ul><h2 id="检索多个文档-mget"><a class="headerlink" href="#检索多个文档-mget"></a> 检索多个文档 mget</h2><p>为了减少网络开销，ES支持合并请求检索多个文档。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">POST /_mget</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"docs"</span> : [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"_index"</span> : <span class="string">"website"</span>,</span><br><span class="line">      <span class="attr">"_type"</span> : <span class="string">"blog"</span>,</span><br><span class="line">      <span class="attr">"_id"</span> : <span class="number">2</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"_index"</span> : <span class="string">"website"</span>,</span><br><span class="line">      <span class="attr">"_type"</span> : <span class="string">"pageviews"</span>,</span><br><span class="line">      <span class="attr">"_id"</span> : <span class="number">1</span>,</span><br><span class="line">      <span class="attr">"_source"</span>: <span class="string">"views"</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其返回结果的顺序与请求的数组顺序一致。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"docs"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"_index"</span>: <span class="string">"website"</span>,</span><br><span class="line">      <span class="attr">"_id"</span>: <span class="string">"2"</span>,</span><br><span class="line">      <span class="attr">"_type"</span>: <span class="string">"blog"</span>,</span><br><span class="line">      <span class="attr">"found"</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">"_source"</span>: &#123;</span><br><span class="line">        <span class="attr">"text"</span>: <span class="string">"This is a piece of cake..."</span>,</span><br><span class="line">        <span class="attr">"title"</span>: <span class="string">"My first external blog entry"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"_version"</span>: <span class="number">10</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"_index"</span>: <span class="string">"website"</span>,</span><br><span class="line">      <span class="attr">"_id"</span>: <span class="string">"1"</span>,</span><br><span class="line">      <span class="attr">"_type"</span>: <span class="string">"pageviews"</span>,</span><br><span class="line">      <span class="attr">"found"</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">"_version"</span>: <span class="number">2</span>,</span><br><span class="line">      <span class="attr">"_source"</span>: &#123;</span><br><span class="line">        <span class="attr">"views"</span>: <span class="number">2</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个文档的检索和报告都是独立的，如果其中某些文档不存在不会影响到其他可以查询到的文档。</p><p><strong>注：尽管前面提到有一个文档没有被找到，但HTTP请求状态码还是 200 。事实上，就算所有文档都找不到，请求也还是返回 200 ，原因是 mget 请求本身成功了。如果想知道每个文档是否都成功了，你需要检查 found 标志。</strong></p><h2 id="更新时的批量操作-bulk"><a class="headerlink" href="#更新时的批量操作-bulk"></a> 更新时的批量操作 bulk</h2><p>bulk API允许我们使用单一请求来实现多个文档的 create\index\update\delete。</p><p>bulk 请求体如下:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123; action: &#123; metadata &#125;&#125;\n</span><br><span class="line">&#123; request body &#125;\n</span><br><span class="line">&#123; action: &#123; metadata &#125;&#125;\n</span><br><span class="line">&#123; request body &#125;\n</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>用 “\n” 符号连接起来的一行一行的JSON文档流(stream),并且：</p><ul><li>每行必须以 “\n” 符号结尾，包括最后一行。这些都是作为每行有效的分离而做的标记。</li><li>每一行的数据不能包含未被转义的换行符，它们会干扰分析，这意味着JSON不能被美化打印。</li></ul><p><strong>bulk 请求不是原子操作——它们不能实现事务。每个请求操作时分开的，所以每个请求的成功与否不干扰其它操作。</strong></p>]]></content>
      
      
      <categories>
          
          <category> dev </category>
          
          <category> ElasticSearch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ElasticSearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ElasticSearch[1]-集群方面的基础概念</title>
      <link href="/2019/06/30/es-1/"/>
      <url>/2019/06/30/es-1/</url>
      
        <content type="html"><![CDATA[<h2 id="集群cluster-节点node"><a class="headerlink" href="#集群cluster-节点node"></a> 集群(cluster)&amp; 节点(node)</h2><p>每一个节点(node)就是一个 es 实例，而一个集群(cluster)由一个活多个节点组成，他们具有相同的 cluster name。当一个节点新增或删除时，集群会感知并平衡数据。<br>docker中es集群的配置：<br><img src="https://image-1257148187.cos.ap-chengdu.myqcloud.com/picgo_img/20190630234210.png" alt="docker中es集群的配置"><span class="image-caption">docker中es集群的配置</span></p><p>集群中的一个节点会被选举为主节点(master)，主节点管理集群级别的变更(索引增删，节点添加删除等)但不参与文档级别的变更和搜索，这意味着当流量增大时，主节点不会成为集群的瓶颈。</p><h2 id="索引index-分片shard"><a class="headerlink" href="#索引index-分片shard"></a> 索引(index)&amp; 分片(shard)</h2><p>索引(index)是一个存储关联数据的地方，用来指向一个或多个分片(shards)的“逻辑命名空间”(logical namespace)</p><p>分片(shard)是一个最小级别的“工作单元”(worker unit)保存了索引中所有数据的一部分，分片是一个Lucene实例，具有完整的搜索引擎，文档(doc)就存储在分片中。<br>分片可以分为主分片(primary shard)和复制分片(replica shard)：<br>索引中的每个文档属于一个单独的主分片，所以主分片的数量决定了索引最多能存储多少数据。<br>复制分片只是主分片的一个副本，可以防止硬件故障导致的数据丢失，同时可以提供读请求，比如搜索或者从别的shard取回文档。</p><p>索引创建完成，主分片的数量就是固定的，但是复制分片是可以随时调整的。</p><h2 id="集群健康"><a class="headerlink" href="#集群健康"></a> 集群健康</h2><p>集群健康有三种状态：</p><table><thead><tr><th style="text-align:center">颜色</th><th style="text-align:left">意义</th></tr></thead><tbody><tr><td style="text-align:center">green</td><td style="text-align:left">所有主要分片和复制分片都可用</td></tr><tr><td style="text-align:center">yellow</td><td style="text-align:left">所有主要分片可用，但是不是所有复制分片都可用</td></tr><tr><td style="text-align:center">red</td><td style="text-align:left">不是所有主要分片都可用</td></tr></tbody></table><h2 id="故障转移-横向拓展-更多拓展"><a class="headerlink" href="#故障转移-横向拓展-更多拓展"></a> 故障转移 &amp; 横向拓展 &amp; 更多拓展</h2><p>文档的索引会先存储在主分片上，然后并发的复制到对应的复制节点上，以保证主副节点都可用被检索。<br><img src="https://image-1257148187.cos.ap-chengdu.myqcloud.com/picgo_img/20190701003903.png" alt=""><br>横向拓展可以使得主副分片保存在不同的节点上，这样单个节点所承载的分片相对就少，以此提升性能。<br><img src="https://image-1257148187.cos.ap-chengdu.myqcloud.com/picgo_img/20190701003828.png" alt=""><br>每个主分片可以对应到多个复制分片，以此提升搜索性能。<br><img src="https://image-1257148187.cos.ap-chengdu.myqcloud.com/picgo_img/20190701004252.png" alt=""><br><strong>注：增加复制分片的同时一半伴随着增加节点的数量，否则一个节点承载更多的分片意味着单个分片所占有的资源(io吞吐、cpu、内存等)将会减少。</strong></p>]]></content>
      
      
      <categories>
          
          <category> dev </category>
          
          <category> ElasticSearch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ElasticSearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ElasticSearch[0]-基于 Docker 搭建的 ES + Cerebro + Kibana 集群</title>
      <link href="/2019/06/30/es-0/"/>
      <url>/2019/06/30/es-0/</url>
      
        <content type="html"><![CDATA[<h2 id="前置-docker-docker-compose-环境"><a class="headerlink" href="#前置-docker-docker-compose-环境"></a> 前置 docker &amp; docker-compose 环境</h2><p>最好挂载国内 docker 镜像加速</p><p><img src="https://image-1257148187.cos.ap-chengdu.myqcloud.com/picgo_img/20190630101356.png" alt="docker &amp; docker-compose 版本信息"><span class="image-caption">docker &amp; docker-compose 版本信息</span></p><h2 id="docker-composeyaml-配置文件"><a class="headerlink" href="#docker-composeyaml-配置文件"></a> docker-compose.yaml 配置文件</h2><h3 id="前置-docker-network-准备"><a class="headerlink" href="#前置-docker-network-准备"></a> 前置 docker network 准备</h3><p>创建名为 ‘es_app’ 的 docker network 网络配置。方便后续接入其他 docker compose 文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network create es_app</span><br></pre></td></tr></table></figure><h3 id="docker-composeyaml"><a class="headerlink" href="#docker-composeyaml"></a> docker-compose.yaml</h3><ul><li>cerebro es集群管理插件</li><li>kibana es可视化管理工具插件</li><li>elasticsearch &amp; elasticsearch2 es的两个集群节点</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'2.2'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">  cerebro:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">lmenezes/cerebro:0.8.3</span></span><br><span class="line"><span class="attr">    container_name:</span> <span class="string">cerebro</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"9000:9000"</span></span><br><span class="line"><span class="attr">    command:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="bullet">-Dhosts.0.host=http://elasticsearch:9200</span></span><br><span class="line"><span class="attr">    networks:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">es_app</span></span><br><span class="line"><span class="attr">  kibana:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="attr">kibana:7.1.0</span></span><br><span class="line"><span class="attr">    container_name:</span> <span class="string">kibana7</span></span><br><span class="line"><span class="attr">    environment:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">I18N_LOCALE=zh-CN</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">XPACK_GRAPH_ENABLED=true</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">TIMELION_ENABLED=true</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">XPACK_MONITORING_COLLECTION_ENABLED="true"</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"5601:5601"</span></span><br><span class="line"><span class="attr">    networks:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">es_app</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  elasticsearch:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="attr">elasticsearch:7.1.0</span></span><br><span class="line"><span class="attr">    container_name:</span> <span class="string">es7_01</span></span><br><span class="line"><span class="attr">    restart:</span> <span class="string">always</span></span><br><span class="line"><span class="attr">    environment:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">cluster.name=theembers-es</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">node.name=es7_01</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">bootstrap.memory_lock=true</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"ES_JAVA_OPTS=-Xms512m -Xmx512m"</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">discovery.seed_hosts=es7_01</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">cluster.initial_master_nodes=es7_01,es7_02</span></span><br><span class="line"><span class="attr">    ulimits:</span></span><br><span class="line"><span class="attr">      memlock:</span></span><br><span class="line"><span class="attr">        soft:</span> <span class="bullet">-1</span></span><br><span class="line"><span class="attr">        hard:</span> <span class="bullet">-1</span></span><br><span class="line"><span class="attr">    volumes:</span></span><br><span class="line"><span class="attr">      - es7data1:</span><span class="string">/tools/elasticsearch/data</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="number">9200</span><span class="string">:9200</span></span><br><span class="line"><span class="attr">    networks:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">es_app</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  elasticsearch2:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="attr">elasticsearch:7.1.0</span></span><br><span class="line"><span class="attr">    container_name:</span> <span class="string">es7_02</span></span><br><span class="line"><span class="attr">    restart:</span> <span class="string">always</span></span><br><span class="line"><span class="attr">    environment:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">cluster.name=theembers-es</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">node.name=es7_02</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">bootstrap.memory_lock=true</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"ES_JAVA_OPTS=-Xms512m -Xmx512m"</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">discovery.seed_hosts=es7_01</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">cluster.initial_master_nodes=es7_01,es7_02</span></span><br><span class="line"><span class="attr">    ulimits:</span></span><br><span class="line"><span class="attr">      memlock:</span></span><br><span class="line"><span class="attr">        soft:</span> <span class="bullet">-1</span></span><br><span class="line"><span class="attr">        hard:</span> <span class="bullet">-1</span></span><br><span class="line"><span class="attr">    volumes:</span></span><br><span class="line"><span class="attr">      - es7data2:</span><span class="string">/tools/elasticsearch/data</span></span><br><span class="line"><span class="attr">    networks:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">es_app</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line"><span class="attr">  es7data1:</span></span><br><span class="line"><span class="attr">    driver:</span> <span class="string">local</span></span><br><span class="line"><span class="attr">  es7data2:</span></span><br><span class="line"><span class="attr">    driver:</span> <span class="string">local</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line"><span class="attr">  es_app:</span></span><br><span class="line"><span class="attr">    driver:</span> <span class="string">bridge</span></span><br><span class="line"><span class="attr">    external:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h2 id="启动-docker-compose"><a class="headerlink" href="#启动-docker-compose"></a> 启动 docker-compose</h2><ol><li>把以上文件放置在 名为 'docker-compose.yaml’的文件中</li><li>进入目录</li></ol>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> [your file path]</span><br></pre></td></tr></table></figure><ol start="3"><li>执行启动，首次启动会检索docker image，如果不存在相关镜像则会自动下载镜像</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者后台执行</span></span><br><span class="line">docker-compose up -d</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者 其他名称的docker compose文件</span></span><br><span class="line">docker-compose -f [file path] up -d</span><br></pre></td></tr></table></figure><p><img src="https://image-1257148187.cos.ap-chengdu.myqcloud.com/picgo_img/20190630103417.png" alt=""></p><ol start="4"><li>停止es服务</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 停止和删除容器、网络、卷、镜像</span></span><br><span class="line">docker-compose down</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止</span></span><br><span class="line">docker-compose stop</span><br></pre></td></tr></table></figure><p><img src="https://image-1257148187.cos.ap-chengdu.myqcloud.com/picgo_img/20190630103251.png" alt=""></p><h2 id="完成"><a class="headerlink" href="#完成"></a> 完成</h2><p><img src="https://image-1257148187.cos.ap-chengdu.myqcloud.com/picgo_img/20190630104047.png" alt="Kibana 界面"><span class="image-caption">Kibana 界面</span></p><p><img src="https://image-1257148187.cos.ap-chengdu.myqcloud.com/picgo_img/20190630104135.png" alt="Cerebro 界面"><span class="image-caption">Cerebro 界面</span></p>]]></content>
      
      
      <categories>
          
          <category> dev </category>
          
          <category> ElasticSearch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ElasticSearch </tag>
            
            <tag> Cerebro </tag>
            
            <tag> Kibana </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang[0]-突然决定的 Golang 学习计划</title>
      <link href="/2019/06/05/golang-0/"/>
      <url>/2019/06/05/golang-0/</url>
      
        <content type="html"><![CDATA[<h2 id="进度"><a class="headerlink" href="#进度"></a> 进度</h2><p>语法</p><ul><li>基本语法<ul><li>✔️ 基本结构和基本数据类型</li><li>✔️ 控制结构</li><li>✔️ 函数</li><li>✒️ 数组与切片</li><li>⭕️ Map</li><li>⭕️ 包</li><li>⭕️ 结构与方法</li><li>⭕️ 接口与反射</li></ul></li><li>高级语法<ul><li>⭕️ 读写数据</li><li>⭕️ 错误处理与测试</li><li>⭕️ 协程与通道</li><li>⭕️ 网络、模版与网页应用</li></ul></li><li>web开发<ul><li>⭕️ beego</li><li>…</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> dev </category>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小雪第二阶段（6个月 5.7斤）</title>
      <link href="/2019/05/27/cat-in-the-house-1/"/>
      <url>/2019/05/27/cat-in-the-house-1/</url>
      
        <content type="html"><![CDATA[<p><img src="https://image-1257148187.cos.ap-chengdu.myqcloud.com/picgo_img/20190527094053.jpg" alt=""><br><img src="https://image-1257148187.cos.ap-chengdu.myqcloud.com/picgo_img/20190527094054.jpg" alt=""><br><img src="https://image-1257148187.cos.ap-chengdu.myqcloud.com/picgo_img/20190527094358.jpg" alt=""><br><img src="https://image-1257148187.cos.ap-chengdu.myqcloud.com/picgo_img/20190527094359.jpg" alt=""><br><img src="https://image-1257148187.cos.ap-chengdu.myqcloud.com/picgo_img/20190527094400.jpg" alt=""><br><img src="https://image-1257148187.cos.ap-chengdu.myqcloud.com/picgo_img/20190527094401.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
          <category> 碎碎念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cat </tag>
            
            <tag> 雪糕 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL[2]-查询性能优化</title>
      <link href="/2019/04/23/db-4/"/>
      <url>/2019/04/23/db-4/</url>
      
        <content type="html"><![CDATA[<h2 id="慢查询基础"><a class="headerlink" href="#慢查询基础"></a> 慢查询基础</h2><ul><li><p>是否在检索大量不需要的行或列</p></li><li><p>是否在MySQL分析大量的数据行</p></li><li><p>覆盖索引</p></li><li><p>优化表结构</p></li><li><p>重构查询</p></li></ul><h2 id="重构查询的方式"><a class="headerlink" href="#重构查询的方式"></a> 重构查询的方式</h2><h3 id="复杂查询还是简单查询"><a class="headerlink" href="#复杂查询还是简单查询"></a> 复杂查询还是简单查询</h3><p>对于现代MySQL数据库来讲，网络通信、查询解析和优化已经不是影响查询效率的因素，反而MySQL内部扫码数据所消耗的时间远大于数据返回客户端的时间。所以需要考虑是否可以将复杂查询进行拆解。</p><h3 id="切分查询"><a class="headerlink" href="#切分查询"></a> 切分查询</h3><p>比如分表、分区间等等。</p><h3 id="分解关联查询"><a class="headerlink" href="#分解关联查询"></a> 分解关联查询</h3><p>优势：</p><ul><li>提升缓存效率。细化缓存粒度，提升缓存使用率。</li><li>减少锁竞争，提高并发量。</li><li>提升查询本身的效率，比如IN子句转换为索引已知范围查询。</li><li>减少冗余查询，提供查询结果利用率。</li></ul><h2 id="查询执行基础"><a class="headerlink" href="#查询执行基础"></a> 查询执行基础</h2><p><img src="https://image-1257148187.cos.ap-chengdu.myqcloud.com/picgo_img/20190424150321.png" alt="查询执行路径"><span class="image-caption">查询执行路径</span></p><h2 id="mysql查询优化器的局限性"><a class="headerlink" href="#mysql查询优化器的局限性"></a> MySQL查询优化器的局限性</h2><h3 id="关联子查询"><a class="headerlink" href="#关联子查询"></a> 关联子查询</h3><p>IN 子查询。 全表扫描外表（表索引或者是表数据）再通过 内外表关联关系逐个查询内表。</p><h3 id="union-的限制"><a class="headerlink" href="#union-的限制"></a> union 的限制</h3><p>…</p><h2 id="优化特定类型的查询"><a class="headerlink" href="#优化特定类型的查询"></a> 优化特定类型的查询</h2><h3 id="count"><a class="headerlink" href="#count"></a> count</h3><p>count(*) 扫描数据忽略是否为null，而具体的字段则会忽略null值。</p><h3 id=""><a class="headerlink" href="#"></a> …</h3>]]></content>
      
      
      <categories>
          
          <category> dev </category>
          
          <category> database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL[1]-高性能索引</title>
      <link href="/2019/04/23/db-3/"/>
      <url>/2019/04/23/db-3/</url>
      
        <content type="html"><![CDATA[<h2 id="索引基础"><a class="headerlink" href="#索引基础"></a> 索引基础</h2><h3 id="b-tree"><a class="headerlink" href="#b-tree"></a> B-TREE</h3><p><img src="https://image-1257148187.cos.ap-chengdu.myqcloud.com/picgo_img/20190423110121.png" alt="MyISAM B-TREE 结构"><span class="image-caption">MyISAM B-TREE 结构</span></p><blockquote><p>来源见水印</p></blockquote><ul><li><p>基于 B-TREE 的查询类型</p><ul><li>全值匹配</li><li>匹配最左前缀</li><li>匹配列前缀</li><li>匹配范围值</li><li>精准匹配某一列并范围匹配另外一列</li><li>只访问索引的查询</li></ul></li><li><p>关于 B-TREE 的查询限制</p><ul><li>不是按照最左列查询的，则无法使用索引</li><li>不能跳过索引中的列</li><li>如果某一列使用范围查询，则其右边的列无法使用索引优化查询</li></ul></li></ul><h3 id="hash索引"><a class="headerlink" href="#hash索引"></a> hash索引</h3><ul><li>关于 hash 索引的查询限制<ul><li>索引数据不是顺序存储，所以不可排序</li><li>不支持部分索引列匹配</li><li>只支持等值比较查询</li><li>hash 冲突时只能逐行扫描</li><li>hash 冲突高时维护操作代价很大</li></ul></li></ul><h2 id="高性能索引策略"><a class="headerlink" href="#高性能索引策略"></a> 高性能索引策略</h2><h3 id="独立的列"><a class="headerlink" href="#独立的列"></a> 独立的列</h3><p>索引列不应该是表达式的一部分，也不能是函数的参数。</p><h3 id="前缀索引和索引选择性"><a class="headerlink" href="#前缀索引和索引选择性"></a> 前缀索引和索引选择性</h3><ul><li><p>索引选择性<br>不重复的索引值和数据表的记录总数的比值（不重复的索引值/记录总数）比例越高索引效率越高。</p></li><li><p>前缀索引<br>解决大字段建立索引占用空间过大的问题。<br><code>ALERT TABLE table_name ADD KEY (field(length))</code></p></li><li><p>前缀索引无法 GROUP BY 和 ORDER BY</p></li></ul><h3 id="多列索引"><a class="headerlink" href="#多列索引"></a> 多列索引</h3><p>and 条件 需要包含多个相关列的多列索引，而非多个独立的单列索引</p><h3 id="选择合适的索引列顺序"><a class="headerlink" href="#选择合适的索引列顺序"></a> 选择合适的索引列顺序</h3><h3 id="聚簇索引"><a class="headerlink" href="#聚簇索引"></a> 聚簇索引</h3><p>在 B-TREE 索引的叶子页上存储了数据行，因为数据行不能存储在多个地方所以一个表只能有一个聚簇索引。</p><p>为了保证少的存储碎片，聚簇索引应当选择自增类型的数据做索引值</p><h3 id="覆盖索引"><a class="headerlink" href="#覆盖索引"></a> 覆盖索引</h3><p>索引包含索要查询字段的值，则称之为覆盖索引，这种索引不需要会查数据行。</p><p>InnoDB 的二级索引在叶子节点存储的是行的主键值，所以，如果二级主键能够覆盖查询，则可以避免对主键索引的二次查询。</p><h3 id="使用索引扫描排序"><a class="headerlink" href="#使用索引扫描排序"></a> 使用索引扫描排序</h3><h3 id="冗余和重复索引"><a class="headerlink" href="#冗余和重复索引"></a> 冗余和重复索引</h3><p>多列索引和单列索引，如果多列索引可以通过前缀索引，则说明该单列索引是重复的。</p><p>尽量避免创建多余的索引，应当考虑拓展现有索引。</p><h3 id="索引和锁"><a class="headerlink" href="#索引和锁"></a> 索引和锁</h3><p>InnoDB实在读取行的时候加锁的，所以索引可以减少行的读取，从而减少了加锁操作。</p>]]></content>
      
      
      <categories>
          
          <category> dev </category>
          
          <category> database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL[0]-存储引擎前置</title>
      <link href="/2019/04/23/db-2/"/>
      <url>/2019/04/23/db-2/</url>
      
        <content type="html"><![CDATA[<h2 id="逻辑架构"><a class="headerlink" href="#逻辑架构"></a> 逻辑架构</h2><p><img src="https://image-1257148187.cos.ap-chengdu.myqcloud.com/picgo_img/20190423095808.png" alt="MySQL 逻辑架构"><span class="image-caption">MySQL 逻辑架构</span></p><ul><li>顶层客户端负责连接处理、授权验证、安全等等。每一个连接都需要一个线程进行管理。这些线程是通过线程池维护的。</li><li>中间层负责解析查询，包括重写查询、决定表的读取顺序、选择合适的索引。对于SELECT查询语句，服务器会先查询缓存，如果存在则直接返回结果而不去在进行SQL解析等后续步骤。</li><li>底层存储引擎负责数据的读取与存储。存储引擎不会解析SQL只响应上层服务请求。</li></ul><h2 id="并发控制"><a class="headerlink" href="#并发控制"></a> 并发控制</h2><ul><li>读写锁</li><li>锁粒度<ul><li>表锁</li><li>行锁</li></ul></li></ul><h2 id="事务"><a class="headerlink" href="#事务"></a> 事务</h2><ul><li>事务隔离级别</li></ul><h3 id="死锁"><a class="headerlink" href="#死锁"></a> 死锁</h3><p>死锁描述的是在两个或以上线程个占有一个资源，并相互请求对方资源的情况。这是由于不同线程对资源请求顺序不一致导致的，这时必须通过外力作用才能解除。</p><p>在MySQL中可以表现为两个或多个事务在各自持有一行数据锁时，并请求彼此一行数据的情况。为此MySQL实现了各种死锁检测机制以及死锁超时机制。比如Innodb检查到死锁依赖会立即返回错误。并将持有最小行级排他锁事务进行回滚。</p><h3 id="事务日志"><a class="headerlink" href="#事务日志"></a> 事务日志</h3><p>通过修改内存拷贝追加事务日志来提升事务效率，在后台再慢慢写入磁盘。</p><h3 id="事务中的混合存储引擎"><a class="headerlink" href="#事务中的混合存储引擎"></a> 事务中的混合存储引擎</h3><p>事务回滚是不会回滚非事务支持的表的（比如MyISAM引擎的表）</p><h2 id="多版本并发控制mvcc"><a class="headerlink" href="#多版本并发控制mvcc"></a> 多版本并发控制(MVCC)</h2><p>类比 JAVA 的 CAS 操作</p>]]></content>
      
      
      <categories>
          
          <category> dev </category>
          
          <category> database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker[0]-一张图理解 Docker 结构与命令</title>
      <link href="/2019/04/17/docker-0/"/>
      <url>/2019/04/17/docker-0/</url>
      
        <content type="html"><![CDATA[<p><img src="https://image-1257148187.cos.ap-chengdu.myqcloud.com/picgo_img/docker.jpeg" alt="Docker"><span class="image-caption">Docker</span></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>HTTP[0]-直萃链路核心</title>
      <link href="/2019/04/17/http-0/"/>
      <url>/2019/04/17/http-0/</url>
      
        <content type="html"><![CDATA[<h2 id="tcpip-的分层管理"><a class="headerlink" href="#tcpip-的分层管理"></a> TCP/IP 的分层管理</h2><h3 id="应用层"><a class="headerlink" href="#应用层"></a> 应用层</h3><p>应用层决定了向用户提供应用服务时通信的活动。</p><p>其中包括常见的有 HTTP、FTP、DNS等。</p><h3 id="传输层"><a class="headerlink" href="#传输层"></a> 传输层</h3><p>传输层对上层应用层，提供处于网络连接中的两台计算机之间的数据 传输。</p><p>分为两个性质不同的协议：</p><ul><li>TCP（Transmission Control Protocol，传输控制协议）</li><li>UDP（User Data Protocol，用户数据报 协议）</li></ul><h3 id="网络层"><a class="headerlink" href="#网络层"></a> 网络层</h3><p>网络层用来处理在网络上流动的数据包。数据包是网络传输的最小数 据单位。该层规定了通过怎样的路径（所谓的传输路线）到达对方计 算机，并把数据包传送给对方。</p><h3 id="数据链路层"><a class="headerlink" href="#数据链路层"></a> 数据链路层</h3><p>用来处理连接网络的硬件部分。</p><h2 id="tcpip-通信传输流"><a class="headerlink" href="#tcpip-通信传输流"></a> TCP/IP 通信传输流</h2><p><img src="https://i.loli.net/2019/04/17/5cb69418a2892.png" alt="TCP/IP 通信传输流"><span class="image-caption">TCP/IP 通信传输流</span></p><p><img src="https://i.loli.net/2019/04/17/5cb6960f4039d.png" alt="HTTP传输流"><span class="image-caption">HTTP传输流</span></p><h2 id="ip-tcp-dns"><a class="headerlink" href="#ip-tcp-dns"></a> IP TCP DNS</h2><h3 id="ip"><a class="headerlink" href="#ip"></a> IP</h3><p>IP协议保证把数据传输到接收端。其中最重要的两个条件是 IP 地址和 MAC 地址。IP 地址指明了节点被分配到的地址，MAC 地址是指网卡所属的固定地址。IP地址和MAC地址镜像配对。</p><p>其中MAC地址之间的转发路由通过 ARP 解析地址协议，通过 IP 反查 MAC 地址。</p><h3 id="tcp"><a class="headerlink" href="#tcp"></a> TCP</h3><p>TCP 确保数据包送达接收端。</p><h4 id="三次握手"><a class="headerlink" href="#三次握手"></a> 三次握手</h4><p>握手过程中使用了 TCP 的标志（flag） —— SYN（synchronize） 和 ACK（acknowledgement）。</p><ol><li>发送端首先发送一个带 SYN 标志的数据包给对方。</li><li>接收端收到后， 回传一个带有 SYN/ACK 标志的数据包以示传达确认信息。</li><li>最后，发送端再回传一个带 ACK 标志的数据包，代表“握手”结束。</li></ol><p>若在握手过程中某个阶段莫名中断，TCP 协议会再次以相同的顺序发 送相同的数据包。</p><h4 id="四次挥手"><a class="headerlink" href="#四次挥手"></a> 四次挥手</h4><p><img src="https://image-1257148187.cos.ap-chengdu.myqcloud.com/picgo_img/20190418142924.webp" alt="三次握手四次挥手状态变更"><span class="image-caption">三次握手四次挥手状态变更</span></p><h3 id="dns"><a class="headerlink" href="#dns"></a> DNS</h3><p>域名解析服务，ip和域名的映射服务</p><h2 id="各种协议与-http-协议的关系"><a class="headerlink" href="#各种协议与-http-协议的关系"></a> 各种协议与 HTTP 协议的关系</h2><p><img src="https://i.loli.net/2019/04/17/5cb6a0ba87e3a.png" alt="各种协议与 HTTP 协议的关系"><span class="image-caption">各种协议与 HTTP 协议的关系</span></p><blockquote><p>图片来自《图解HTTP》</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> dev </category>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
            <tag> TCP/IP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于 nodejs + kafka + redis 实现的 编程式物联网数据解码单元</title>
      <link href="/2019/01/31/iot-processer/"/>
      <url>/2019/01/31/iot-processer/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>src</strong>: <a href="https://github.com/Theembers/iot-processer" target="_blank" rel="noopener">https://github.com/Theembers/iot-processer</a><br><strong>thanks for your star! 😃</strong></p></blockquote><h1 id="iot-processer"><a class="headerlink" href="#iot-processer"></a> iot-processer</h1><p>基于 nodejs + kafka + redis 实现的 编程式物联网数据解码单元</p><h2 id="特点"><a class="headerlink" href="#特点"></a> 特点</h2><ul><li>编程式解码规则定义<br>基于 JavaScript 脚本语言特性(代码注入)，支持自定义编程式解码规则</li><li>分布式支持</li></ul><h2 id="说明"><a class="headerlink" href="#说明"></a> 说明</h2><h3 id="前置"><a class="headerlink" href="#前置"></a> 前置</h3><p>数据接入端接入设备数据后，通过特征标示分类推送到 kafka 消息队列，等待 iot-processer 模块消费解码数据</p><p>平台总体架构设计</p><p><img src="https://image-1257148187.cos.ap-chengdu.myqcloud.com/picgo_img/20190131162137.png" alt=""></p><h3 id="环境依赖"><a class="headerlink" href="#环境依赖"></a> 环境依赖</h3><ul><li>node</li><li>kafka</li><li>redis</li></ul><h3 id="配置"><a class="headerlink" href="#配置"></a> 配置</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  name: <span class="string">'json'</span>, <span class="comment">// 解码器名称，用于标记解码所需加载的规则标记 （json string Hex ..）</span></span><br><span class="line">  topic: <span class="string">'JSON_OPIC'</span>, <span class="comment">// 监听的topic，获取支持解码的数据</span></span><br><span class="line">  redis: &#123;</span><br><span class="line">    <span class="comment">// redis配置信息</span></span><br><span class="line">    host: <span class="string">'192.168.0.201'</span>,</span><br><span class="line">    port: <span class="number">6379</span>,</span><br><span class="line">    db: <span class="number">14</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  kafka: &#123;</span><br><span class="line">    <span class="comment">// kafka配置信息</span></span><br><span class="line">    kafkaHost: <span class="string">'192.168.10.120:6667,192.168.10.121:6667,192.168.10.122:6667'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="流程"><a class="headerlink" href="#流程"></a> 流程</h3><p><img src="https://image-1257148187.cos.ap-chengdu.myqcloud.com/picgo_img/20190131161528.png" alt=""></p><h3 id="代码"><a class="headerlink" href="#代码"></a> 代码</h3><p>加载依赖 <code>yarn install</code> or <code>npm install --save</code></p><p>启动 <code>node index.js</code></p><p><img src="https://image-1257148187.cos.ap-chengdu.myqcloud.com/picgo_img/20190131165220.png" alt=""></p><h3 id="解码器规则实例"><a class="headerlink" href="#解码器规则实例"></a> 解码器规则实例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">key-data-change-rule-5601808030001129</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;str&quot;: &#123;</span><br><span class="line">    &quot;processorFn&quot;: &quot;const arr = data.split(&apos;:&apos;); return[&#123;attr: arr[0],val:arr[1]&#125;];&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;hex&quot;: &#123;</span><br><span class="line">    &quot;framework&quot;: &#123; // hex 偏移量规则 本例基于 modbus 协议制定</span><br><span class="line">      &quot;address&quot;: 2,</span><br><span class="line">      &quot;command&quot;:   2,</span><br><span class="line">      &quot;length&quot;:   2,</span><br><span class="line">      &quot;data&quot;: &quot;*&quot;,</span><br><span class="line">      &quot;crc&quot;:   4</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;data&quot;: &quot;data&quot;, // 数据属性名</span><br><span class="line">    &quot;dataChangeFn&quot;: [ // 数据转换格式，位置参数</span><br><span class="line">      &quot;data = data + &apos;ms&apos;; return&#123;attr:&apos;SSLL&apos;,val:data&#125;;&quot;,</span><br><span class="line">      &quot;data = data + &apos;ms&apos;; return&#123;attr:&apos;LJLL&apos;,val:data&#125;;&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;checkTag&quot;: &quot;crc&quot;,</span><br><span class="line">    &quot;checkFn&quot;: &#123;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    // 解码规则 （基于 modbus 协议）</span><br><span class="line">    &quot;processorFn&quot;: &quot;const count = data.length / 8;const dataItemList = [];let offset = 0;for (let i = 1; i &lt;= count; i++)&#123;let subData = data.slice(offset, offset + 8);const h = subData.slice(0, 4);const l = subData.slice(4, 8);const data_bit = parseInt(l + h, 16).toString(2);const data_E = parseInt(data_bit.slice(0, 8), 2);const data_M = data_bit.slice(8, 64);let data_M_10 = 0.0;for (var j = 0; j &lt; data_M.length; j++)&#123;data_M_10 = data_M_10 + data_M[j]* Math.pow(2, -1 * (j + 1));&#125;const readData = Math.pow(2, data_E - 127) * (1 + data_M_10);dataItemList.push(readData);offset += 8;&#125;return dataItemList;&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;json&quot;: &#123;</span><br><span class="line">    &quot;processorFn&quot;: &quot;const jsonStr = JSON.parse(data);const datas = jsonStr.data;return [&#123;attr:&apos;YL&apos;,val:datas[0].ch1&#125;];&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">key-attr-topic-rule-5601808030001129</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;Signal&quot;: [</span><br><span class="line">    &quot;realtime-status-topic&quot;,</span><br><span class="line">    &quot;pgsql-topic&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;SSLL&quot;: [</span><br><span class="line">    &quot;pgsql-topic&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;LJLL&quot;: [</span><br><span class="line">    &quot;pgsql-topic&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;YL&quot;: [</span><br><span class="line">    &quot;pgsql-topic&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> dev </category>
          
          <category> node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iot </tag>
            
            <tag> nodejs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2018年：缄默取舍 敬畏人性</title>
      <link href="/2019/01/02/annual-report-2018/"/>
      <url>/2019/01/02/annual-report-2018/</url>
      
        <content type="html"><![CDATA[<blockquote><p>lei～了 lei～了</p></blockquote><a id="more"></a><p>去年的最后一天，在外边冻成狗。我说不行我先回去睡了，迎新年这么隆重的事留给你们年轻人就好。<br>今年的第一天，外边几十分钟的艳阳天。我说不行我先安排下猫儿去医院，这货感冒一个月了爸爸心痛。</p><p>然后。</p><h2 id="一"><a class="headerlink" href="#一"></a> 一。</h2><p>1 月 2 日 这个日子其实也很特殊，除了早上要上新年的第一天班以外，还能把昨天的事总结一下。昨天是什么？元旦节，新年的第一天。我花了一个元旦节想了想这一年要怎么办事，前一年都干了什么好事。</p><p>每一年我都坚持写年终总结，去年的也要如期而至。</p><center><p><img src="https://image-1257148187.cos.ap-chengdu.myqcloud.com/picgo_img/20190101124133.png" alt="2015 ~ 2018 年终总结"><span class="image-caption">2015 ~ 2018 年终总结</span></p></center><p></p><p>原因不是想励什么志，也不是什么文人墨客的情怀。就是想着可以在每年的这个时候，有仪式感的回味下，看看这些年来我有什么变化。但遗憾的是貌似没什么长进，全都是越来越自嘲的段子。</p><p><strong>别人的人生都在开挂，而我却开了叉。</strong> // sad</p><h2 id="二"><a class="headerlink" href="#二"></a> 二。</h2><p>无疾而终这类事其实也很好笑。终于，我也相信了那句：</p><blockquote><p>至死不渝，莫过于时过境迁。 ——我说的</p></blockquote><p>这个世界的本质就是一直在改变、在熵减的过程中演进。过早的进入一个终极形态是会被摒弃的。那为什么不去承认这一点，并加快自己的被同化呢？</p><p><strong>有时候，我们想着提升自己的认知不是为了提升境界到一个高的维度，而是为了在看清事物真相之后更加的心安理得。</strong></p><h2 id="三"><a class="headerlink" href="#三"></a> 三。</h2><p>这个时代流行谈自我，我从来不说自我。</p><p>不知什么时候，脾气差就成为了我性格的一部分。可是我之前是很随和的人啊，为什么会给人留下这样的印象呢。</p><p>主要可能是我懒吧，懒得解释。我相信每个活至此时的人，在 ta 的内心早已构建了一整套的逻辑体系去捍卫自己的意志，妄图通过两三句话去说服什么也是不现实的，因为 ta 们也很自我。需要解释的很多也很累，索性就直接宣布答案吧，没什么好解释，况且结果本来就是已知的，一通解释之后又改变不了什么，何必浪费时间再做毫无意义的探讨呢。</p><p>大概这就是我所谓的自我吧。我不说。</p><center><p><img src="https://image-1257148187.cos.ap-chengdu.myqcloud.com/picgo_img/20190101133500.png" alt="嗯？"><span class="image-caption">嗯？</span></p></center><p></p><h2 id="末"><a class="headerlink" href="#末"></a> 末。</h2><p>往年总结都不会写对新年的祈盼，今年也是这样。我这种自负心切的人，最怕的就是打自己的脸。猛立flag然后再拼命实现确实很累的。索性这些祈盼就藏在心里吧。</p><p><strong>以上，2018 感谢相伴。</strong></p><h2 id="尾"><a class="headerlink" href="#尾"></a> 尾。</h2><p>猫这种百无聊赖的生物，也会在扒拉猫砂的时候特别认真。</p><center><p><img src="https://image-1257148187.cos.ap-chengdu.myqcloud.com/picgo_img/20190101192942.png" alt="我是一只兔几，我么得感情"><span class="image-caption">我是一只兔几，我么得感情</span></p></center>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
          <category> 年终总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 年终总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一个基于 springboot+netty+rabbitmq 实现的 物联网设备 数据接入的项目</title>
      <link href="/2018/12/28/springboot-netty-iot/"/>
      <url>/2018/12/28/springboot-netty-iot/</url>
      
        <content type="html"><![CDATA[<blockquote><p>一个基于 springboot+netty+rabbitmq 实现的 物联网设备 数据接入的项目</p></blockquote><blockquote><p><strong>src</strong>: <a href="https://github.com/Theembers/iot-dc" target="_blank" rel="noopener">https://github.com/Theembers/iot-dc</a><br><strong>thanks for your star! 😃</strong></p></blockquote><ul><li>JDK 8+</li><li><s>springboot 1.4.5</s></li><li>springboot 2.1.3.RELEASE</li><li><s>netty 4.1.29</s></li><li>netty 4.1.34.Final</li><li>redis</li><li>rabbitMq</li><li>kafka</li></ul><h2 id="业务流程示意图"><a class="headerlink" href="#业务流程示意图"></a> 业务流程示意图</h2><p><img src="https://image-1257148187.cos.ap-chengdu.myqcloud.com/picgo_img/20181227172837.png" alt="业务流程示意图"><span class="image-caption">业务流程示意图</span></p><h2 id="功能模块流程图"><a class="headerlink" href="#功能模块流程图"></a> 功能模块流程图</h2><p><img src="https://image-1257148187.cos.ap-chengdu.myqcloud.com/picgo_img/20181228143242.png" alt="功能模块流程图"><span class="image-caption">功能模块流程图</span></p><h2 id="项目结构"><a class="headerlink" href="#项目结构"></a> 项目结构</h2><p><img src="https://image-1257148187.cos.ap-chengdu.myqcloud.com/picgo_img/20181228102814.png" alt="项目结构"><span class="image-caption">项目结构</span></p>]]></content>
      
      
      <categories>
          
          <category> dev </category>
          
          <category> java </category>
          
          <category> netty </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iot </tag>
            
            <tag> netty </tag>
            
            <tag> dc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>介绍一个小朋友：天秤美短小姑娘——雪糕</title>
      <link href="/2018/12/07/cat-in-the-house/"/>
      <url>/2018/12/07/cat-in-the-house/</url>
      
        <content type="html"><![CDATA[<p><img src="https://image-1257148187.cos.ap-chengdu.myqcloud.com/picgo_img/20181212161414.jpg" alt=""></p><a id="more"></a><blockquote><p><strong>名字</strong> 雪糕<br><strong>性别</strong> 妹妹<br><strong>生日</strong> 18.10.03<br><strong>领养时间</strong> 18.12.01</p></blockquote><p><img src="https://image-1257148187.cos.ap-chengdu.myqcloud.com/picgo_img/20181212161138.jpg" alt=""><br><img src="https://image-1257148187.cos.ap-chengdu.myqcloud.com/picgo_img/20181212161203.jpg" alt=""><br><img src="https://image-1257148187.cos.ap-chengdu.myqcloud.com/picgo_img/20181212161223.jpg" alt=""><br><img src="https://image-1257148187.cos.ap-chengdu.myqcloud.com/picgo_img/20181212161240.jpg" alt=""><br><img src="https://image-1257148187.cos.ap-chengdu.myqcloud.com/picgo_img/20181212161318.jpg" alt=""><br><img src="https://image-1257148187.cos.ap-chengdu.myqcloud.com/picgo_img/20181212161334.jpg" alt=""><br><img src="https://image-1257148187.cos.ap-chengdu.myqcloud.com/picgo_img/20181212161448.jpg" alt=""></p><hr><p><img src="https://image-1257148187.cos.ap-chengdu.myqcloud.com/picgo_img/20181220090009.png" alt=""><br><img src="https://image-1257148187.cos.ap-chengdu.myqcloud.com/picgo_img/20181220090038.png" alt=""><br><img src="https://image-1257148187.cos.ap-chengdu.myqcloud.com/picgo_img/20181220090053.png" alt=""><br><img src="https://image-1257148187.cos.ap-chengdu.myqcloud.com/picgo_img/20181220090117.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
          <category> 碎碎念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cat </tag>
            
            <tag> 雪糕 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac 软件 列表</title>
      <link href="/2018/12/07/mac-softs-list/"/>
      <url>/2018/12/07/mac-softs-list/</url>
      
        <content type="html"><![CDATA[<h2 id="软件列表"><a class="headerlink" href="#软件列表"></a> 软件列表</h2><center><p><img src="https://i.loli.net/2018/12/07/5c09e08f299d8.png" alt="Mac软件列表"><span class="image-caption">Mac软件列表</span></p></center><p></p><h2 id="alfred-命令行配置-iterm2"><a class="headerlink" href="#alfred-命令行配置-iterm2"></a> Alfred 命令行配置 Iterm2</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">on alfred_script(q)  </span><br><span class="line">    if application "iTerm2" is running or application "iTerm" is running then  </span><br><span class="line">        run script "  </span><br><span class="line">            on run &#123;q&#125;  </span><br><span class="line">                tell application \":Applications:iTerm.app\"  </span><br><span class="line">                    activate  </span><br><span class="line">                    try  </span><br><span class="line">                        select first window  </span><br><span class="line">                        set onlywindow to false  </span><br><span class="line">                    on error  </span><br><span class="line">                        create window with default profile  </span><br><span class="line">                        select first window  </span><br><span class="line">                        set onlywindow to true  </span><br><span class="line">                    end try  </span><br><span class="line">                    tell current session of the first window  </span><br><span class="line">                        if onlywindow is false then  </span><br><span class="line">                            tell split vertically with default profile  </span><br><span class="line">                                write text q  </span><br><span class="line">                            end tell  </span><br><span class="line">                        end if  </span><br><span class="line">                    end tell  </span><br><span class="line">                end tell  </span><br><span class="line">            end run  </span><br><span class="line">        " with parameters &#123;q&#125;  </span><br><span class="line">    else  </span><br><span class="line">        run script "  </span><br><span class="line">            on run &#123;q&#125;  </span><br><span class="line">                tell application \":Applications:iTerm.app\"  </span><br><span class="line">                    activate  </span><br><span class="line">                    try  </span><br><span class="line">                        select first window  </span><br><span class="line">                    on error  </span><br><span class="line">                        create window with default profile  </span><br><span class="line">                        select first window  </span><br><span class="line">                    end try  </span><br><span class="line">                    tell the first window  </span><br><span class="line">                        tell current session to write text q  </span><br><span class="line">                    end tell  </span><br><span class="line">                end tell  </span><br><span class="line">            end run  </span><br><span class="line">        " with parameters &#123;q&#125;  </span><br><span class="line">    end if  </span><br><span class="line">end alfred_script</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Mac </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mac </tag>
            
            <tag> soft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Netty In Action - ByteBuf</title>
      <link href="/2018/10/23/netty-in-action-1/"/>
      <url>/2018/10/23/netty-in-action-1/</url>
      
        <content type="html"><![CDATA[<h2 id="bytebuf-api"><a class="headerlink" href="#bytebuf-api"></a> ByteBuf API</h2><h3 id="特点"><a class="headerlink" href="#特点"></a> 特点</h3><ul><li>它可以被用户自定义的缓冲区类型扩展;</li><li>通过内置的复合缓冲区类型实现了透明的零拷贝;</li><li>容量可以按需增长(类似于 JDK 的 StringBuilder);</li><li>在读和写这两种模式之间切换不需要调用 ByteBuffer 的 flip()方法;</li><li>读和写使用了不同的索引;</li><li>支持方法的链式调用;</li><li>支持引用</li><li>支持池化</li></ul><h3 id="工作方式"><a class="headerlink" href="#工作方式"></a> 工作方式</h3><p>ByteBuf 维护了两个不同的索引:一个用于读取，一个用于写入。当从 ByteBuf 读取时， 它的 readerIndex 将会被递增已经被读取的字节数。同理，当写入 ByteBuf 时，它的 writerIndex 也会被递增。</p><p><strong>名称以 read 或者 write 开头的 ByteBuf 方法，将会推进其对应的索引，而名称以 set 或者 get 开头的操作则不会。</strong></p><h3 id="使用模式"><a class="headerlink" href="#使用模式"></a> 使用模式</h3><ul><li><p>堆缓冲区</p><p>这个模式下，数据会存储在 JVM 堆空间中，这种模式也称作“支持数组”（backing array）它能在米有使用池化的情况下提供快速的分配和释放。</p><p>适合于有遗留的数据需要处理的情况。</p></li><li><p>直接缓冲区</p><p>如同 JDK 的 ByteBuffer 一样，数据存储在常规的会被垃圾回收的堆之外。但这有一个缺点，就是如果需要对数据进行操作，则需要拷贝一份到 JVM 内存中。</p></li><li><p>复合缓冲区</p><p>这是为多个 ByteBuf 提供的聚合试图，可以根据需要添加或者删除 ByteBuf 实例。</p><p>Netty 通过一个 ByteBuf 子类——CompositeByteBuf——实现了这个模式，它提供了一个将多个缓冲区表示为单个合并缓冲区的虚拟表示。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CompositeByteBuf messageBuf = Unpooled.compositeBuffer();</span><br><span class="line">ByteBuf headerBuf = ...;</span><br><span class="line">ByteBuf bodyBuf = ...;</span><br><span class="line">messageBuf.addComponents(headerBuf, bodyBuf);</span><br><span class="line">messageBuf.removeComponent(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (ByteBuf buf : messageBuf) &#123;</span><br><span class="line">    System.out.println(buf.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="字节级操作"><a class="headerlink" href="#字节级操作"></a> 字节级操作</h3><ul><li><p>顺序访问索引</p><p>由于 JDK 的 ByteBuffer 只有一个索引，所以即使 ByteBuf 同时具有读索引和写索引，仍然需要调用 <code>flip()</code> 方法 再读写模式之间切换</p></li><li><p>可丢弃字节</p><p>ByteBuf 的可读字节分段存储了实际数据。新分配的、包装的或者复制的缓冲区的默认的 readerIndex 值为 0。任何名称以 read 或者 skip 开头的操作都将检索或者跳过位于当前 readerIndex 的数据，并且将它增加已读字节数。</p></li><li><p>可写字节</p><p>可写字节分段是指一个拥有未定义内容的、写入就绪的内存区域。新分配的缓冲区的 writerIndex 的默认值为 0。任何名称以 write 开头的操作都将从当前的 writerIndex 处 开始写数据，并将它增加已经写入的字节数。如果写操作的目标也是 ByteBuf，并且没有指定 源索引的值，则源缓冲区的 readerIndex 也同样会被增加相同的大小。</p></li><li><p>索引管理</p><p>通过调用 <code>markReaderIndex()</code>、<code>markWriterIndex()</code>、<code>resetWriterIndex()</code> 和 <code>resetReaderIndex()</code>来标记和重置 ByteBuf 的 readerIndex 和 writerIndex。</p><p>也可以通过调用 <code>readerIndex(int)</code>或者 <code>writerIndex(int)</code>来将索引移动到指定位置。</p><p>可以通过调用 <code>clear()</code>方法来将 readerIndex 和 writerIndex 都设置为 0。<strong>但并不会清除内存中的内容。</strong></p></li><li><p>查找操作</p><p>indexOf()<br>ByteProcessor</p></li><li><p>派生缓冲区</p></li><li><p>读/写操作</p><ul><li>get()和 set()操作，从给定的索引开始，并且保持索引不变;</li><li>read()和 write()操作，从给定的索引开始，并且会根据已经访问过的字节数对索引进行调整。</li></ul></li></ul><hr><ul><li>get()操作</li></ul><table><thead><tr><th style="text-align:left">名称</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">getBoolean(int)</td><td style="text-align:left">返回给定索引处的 Boolean 值</td></tr><tr><td style="text-align:left">getByte(int)</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">getUnsignedByte(int)</td><td style="text-align:left">将给定索引处的无符号字节值作为 short 返回</td></tr><tr><td style="text-align:left">getMedium(int)</td><td style="text-align:left">返回给定索引处的 24 位的中等 int 值</td></tr><tr><td style="text-align:left">getUnsignedMedium(int)</td><td style="text-align:left">返回给定索引处的无符号的 24 位的中等 int 值</td></tr><tr><td style="text-align:left">getInt(int)</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">getUnsignedInt(int)</td><td style="text-align:left">将给定索引处的无符号 int 值作为 long 返回</td></tr><tr><td style="text-align:left">getLong(int)</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">getShort(int)</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">getUnsignedShort(int)</td><td style="text-align:left">将给定索引处的无符号 short 值作为 int 返回</td></tr><tr><td style="text-align:left">getBytes(int, …)</td><td style="text-align:left">将该缓冲区中从给定索引开始的数据传送到指定的目的地</td></tr></tbody></table><ul><li>set()操作</li></ul><table><thead><tr><th style="text-align:left">名称</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">setBoolean(int, boolean)</td><td style="text-align:left">设定给定索引处的 Boolean 值</td></tr><tr><td style="text-align:left">setByte(int index, int value)</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">setMedium(int index, int value)</td><td style="text-align:left">设定给定索引处的 24 位的中等 int 值</td></tr><tr><td style="text-align:left">setInt(int index, int value)</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">setLong(int index, long value)</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">setShort(int index, int value)</td><td style="text-align:left"></td></tr></tbody></table><ul><li>read()操作</li></ul><table><thead><tr><th style="text-align:left">名称</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">readBoolean()</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">readByte()</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">readUnsignedByte()</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">readMedium()</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">readUnsignedMedium()</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">readInt()</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">readUnsignedInt()</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">readLong()</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">readShort()</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">readUnsignedShort()</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">readBytes(ByteBuf| byte[] destination,int dstIndex [,intlength])</td><td style="text-align:left"></td></tr></tbody></table><ul><li>write()操作</li></ul><table><thead><tr><th style="text-align:left">名称</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">writeBoolean(boolean)</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">writeByte(int)</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">writeMedium(int)</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">writeInt(int)</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">writeLong(long)</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">writeShort(int)</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">writeBytes(source ByteBuf |byte[] [,int srcIndex ,int length])</td><td style="text-align:left"></td></tr></tbody></table><ul><li>其他有用的操作</li></ul><table><thead><tr><th style="text-align:left">名称</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">isReadable()</td><td style="text-align:left">如果至少有一个字节可供读取，则返回 true</td></tr><tr><td style="text-align:left">isWritable()</td><td style="text-align:left">如果至少有一个字节可被写入，则返回 true</td></tr><tr><td style="text-align:left">readableBytes()</td><td style="text-align:left">返回可被读取的字节数</td></tr><tr><td style="text-align:left">writableBytes()</td><td style="text-align:left">返回可被写入的字节数</td></tr><tr><td style="text-align:left">capacity()</td><td style="text-align:left">返回 ByteBuf 可容纳的字节数。在此之后，它会尝试再次扩展直 到达到 maxCapacity()</td></tr><tr><td style="text-align:left">maxCapacity()</td><td style="text-align:left">返回 ByteBuf 可以容纳的最大字节数</td></tr><tr><td style="text-align:left">hasArray()</td><td style="text-align:left">如果 ByteBuf 由一个字节数组支撑，则返回 true</td></tr><tr><td style="text-align:left">array()</td><td style="text-align:left">如果 ByteBuf 由一个字节数组支撑则返回该数组;否则，它将抛出一个 UnsupportedOperationException 异常</td></tr></tbody></table><h3 id="bytebuf-分配-池化非池化"><a class="headerlink" href="#bytebuf-分配-池化非池化"></a> ByteBuf 分配 (池化&amp;非池化)</h3><ul><li><p>ByteBufAllocator<br>为了降低分配和释放内存的开销，Netty 通过 interface ByteBufAllocator 实现了 (ByteBuf 的)池化，它可以用来分配我们所描述过的任意类型的 ByteBuf 实例。</p><center><p><img src="https://i.loli.net/2018/10/25/5bd118ae4f410.png" alt=""></p></center><p>可以通过 Channel(每个都可以有一个不同的 ByteBufAllocator 实例)或者绑定到 ChannelHandler 的 ChannelHandlerContext 获取一个到 ByteBufAllocator 的引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Channel channel = ...;</span><br><span class="line">ByteBufAllocator allocator = channel.alloc();</span><br><span class="line"></span><br><span class="line">ChannelHandlerContext ctx = ...; </span><br><span class="line">ByteBufAllocator allocator2 = ctx.alloc();</span><br></pre></td></tr></table></figure><p>ByteBufAllocator 有两种实现：PooledByteBufAllocator 和 UnpooledByteBufAllocator。前者池化了ByteBuf的实例以提高性能并最大限度地减少内存碎片，而后者则没有堆实例进行池化。</p></li><li><p>Unpooled</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> dev </category>
          
          <category> java </category>
          
          <category> netty </category>
          
      </categories>
      
      
        <tags>
            
            <tag> netty </tag>
            
            <tag> nio </tag>
            
            <tag> ByteBuf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring AOP-基本概念以及织入顺序</title>
      <link href="/2018/10/08/spring-aop/"/>
      <url>/2018/10/08/spring-aop/</url>
      
        <content type="html"><![CDATA[<h2 id="基本概念"><a class="headerlink" href="#基本概念"></a> 基本概念</h2><p>在 spring 中 Aspect 通过<code>@Aspect</code>、<code>@Pointcut</code>和一系列 advice（<code>@Before</code>、<code>@after</code>、<code>@afterReturning</code>、<code>@Around</code>）组成。</p><ul><li><code>@Aspect</code> 切面，声明当前 class 为一个切面</li><li><code>@Pointcut</code> 切入点，通过 execution 表达式描述切入规则，</li><li>advice 通知，定义了切面是什么以及何时使用。<br>advice 中还包含了 连接点（joinpoint）</li><li>weave 织入，将切面应用到目标对象并导致代理对象创建的过程</li><li>introduction 引入，在不修改代码的前提下，引入可以在运行期为类动态地添加一些方法或字段</li></ul><h2 id="advice-类型"><a class="headerlink" href="#advice-类型"></a> advice 类型</h2><h3 id="before"><a class="headerlink" href="#before"></a> @Before</h3><p>前置通知（Before advice）：在某连接点（JoinPoint）——被切入代码（类或者方法）之前执行的通知，<strong>但这个通知不能阻止连接点前的执行</strong>。因为<code>@Before</code> 注解的方法入参不能传 ProceedingJoinPoint，而只能传入 JoinPoint。而从 aop 走到核心代码就是通过调用 ProceedingJionPoint 的 proceed()方法。而 JoinPoint 没有这个方法。<br>这里牵扯区别这两个类：Proceedingjoinpoint 继承了 JoinPoint 。是在 JoinPoint 的基础上暴露出 proceed 这个方法。proceed 很重要，这个是 aop 代理链执行的方法。暴露出这个方法，就能支持 aop:around 这种切面（而其他的几种切面只需要用到 JoinPoint，这跟切面类型有关）， 能决定是否走代理链还是走自己拦截的其他逻辑。</p><h3 id="after"><a class="headerlink" href="#after"></a> @After</h3><p>后通知（After advice）：当某连接点退出的时候执行的通知（不论是正常返回还是异常退出）。</p><h3 id="afterreturning"><a class="headerlink" href="#afterreturning"></a> @AfterReturning</h3><p>返回后通知（After return advice）：在某连接点正常完成后执行的通知，不包括抛出异常的情况。</p><h3 id="around"><a class="headerlink" href="#around"></a> @Around</h3><p>环绕通知（Around advice）：包围一个连接点的通知，类似 Web 中 Servlet 规范中的 Filter 的 doFilter 方法。可以在方法的调用前后完成自定义的行为，也可以选择不执行。这时 aop 的最重要的，最常用的注解。用这个注解的方法入参传的是 ProceedingJionPoint pjp，可以决定当前线程能否进入核心方法中——通过调用 <code>pjp.proceed();</code></p><h3 id="afterthrowing"><a class="headerlink" href="#afterthrowing"></a> @AfterThrowing</h3><p>抛出异常后通知（After throwing advice）：在方法抛出异常退出时执行的通知。</p><h2 id="advice-注解的执行先后顺序"><a class="headerlink" href="#advice-注解的执行先后顺序"></a> advice 注解的执行先后顺序</h2><h3 id="基础顺序"><a class="headerlink" href="#基础顺序"></a> 基础顺序</h3><center><p><img src="https://i.loli.net/2018/10/08/5bbb69a28dcbe.png" alt=""></p></center><p></p><p>执行到核心业务方法或者类时，会先执行 AOP。在 aop 的逻辑内，先走<code>@Around</code> 注解的方法。然后是<code>@Before</code> 注解的方法，然后这两个都通过了，走核心代码，核心代码走完，无论核心有没有返回值，都会走<code>@After</code> 方法。然后如果程序无异常，正常返回就走<code>@AfterReturn</code>,有异常就走<code>@AfterThrowing</code>。</p><h3 id="多个切面顺序"><a class="headerlink" href="#多个切面顺序"></a> 多个切面顺序</h3><center><p><img src="https://i.loli.net/2018/10/08/5bbb6c39c10b3.png" alt=""></p></center><p></p><h3 id="注意点"><a class="headerlink" href="#注意点"></a> 注意点</h3><ul><li>如果在同一个 aspect 类中，针对同一个 pointcut，定义了两个相同的 advice(比如，定义了两个 <code>@Before</code>)，那么这两个 advice 的执行顺序是无法确定的，即使在这两个 advice 添加了 <code>@Order</code> 这个注解，也不行。</li><li>对于@Around 这个 advice，不管它有没有返回值，但是必须要方法内部，调用一下 <code>pjp.proceed();</code>否则方法将不会会被执行，从而也导致了 <code>@Before</code> 这个 advice 不会被触发。</li></ul>]]></content>
      
      
      <categories>
          
          <category> dev </category>
          
          <category> java </category>
          
          <category> spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
            <tag> aop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MQ[0]-RabbitMQ 起步</title>
      <link href="/2018/09/28/MQ-rabbitmq-0/"/>
      <url>/2018/09/28/MQ-rabbitmq-0/</url>
      
        <content type="html"><![CDATA[<h2 id="基本概念"><a class="headerlink" href="#基本概念"></a> 基本概念</h2><p><img src="https://i.loli.net/2018/09/29/5baf33e81071e.png" alt="rabbitmq结构图"><span class="image-caption">rabbitmq结构图</span></p><h3 id="queue"><a class="headerlink" href="#queue"></a> Queue</h3><p>Queue（队列）RabbitMQ 的作用是存储消息，队列的特性是先进先出。上图可以清晰地看到 Client A 和 Client B 是生产者，生产者生产消息最终被送到 RabbitMQ 的内部对象 Queue 中去，而消费者则是从 Queue 队列中取出数据。可以简化成表示为:</p><center><p><img src="https://i.loli.net/2018/09/29/5baf34d3d53a8.png" alt="Queue"><span class="image-caption">Queue</span></p></center><p></p><p>生产者 Send Message “A”被传送到 Queue 中，消费者发现消息队列 Queue 中有订阅的消息，就会将这条消息 A 读取出来进行一些列的业务操作。这里只是一个消费正对应一个队列 Queue，也可以多个消费者订阅同一个队列 Queue，当然这里就会将 Queue 里面的消息平分给其他的消费者，但是会存在一个一个问题就是如果每个消息的处理时间不同，就会导致某些消费者一直在忙碌中，而有的消费者处理完了消息后一直处于空闲状态，因为前面已经提及到了 Queue 会平分这些消息给相应的消费者。这里我们就可以使用 prefetchCount 来限制每次发送给消费者消息的个数。详情见下图所示：</p><center><p><img src="https://i.loli.net/2018/09/29/5baf3573ac506.png" alt=""></p></center><p></p><p>这里的 prefetchCount=1 是指每次从 Queue 中发送一条消息来。等消费者处理完这条消息后 Queue 会再发送一条消息给消费者。</p><h3 id="exchange"><a class="headerlink" href="#exchange"></a> Exchange</h3><p>首先明确一点就是生产者产生的消息并不是直接发送给消息队列 Queue 的，而是要经过 Exchange（交换器），由 Exchange 再将消息路由到一个或多个 Queue，当然这里还会对不符合路由规则的消息进行丢弃掉，这里指的是后续要谈到的 Exchange Type。那么 Exchange 是怎样将消息准确的推送到对应的 Queue 的呢？那么这里的功劳最大的当属 Binding，RabbitMQ 是通过 Binding 将 Exchange 和 Queue 链接在一起，这样 Exchange 就知道如何将消息准确的推送到 Queue 中去。简单示意图如下所示：</p><center><p><img src="https://i.loli.net/2018/09/29/5baf35f7d5394.png" alt=""></p></center><p></p><p>在绑定（Binding）Exchange 和 Queue 的同时，一般会指定一个 Binding Key，生产者将消息发送给 Exchange 的时候，一般会产生一个 Routing Key，当 Routing Key 和 Binding Key 对应上的时候，消息就会发送到对应的 Queue 中去。那么 Exchange 有四种类型，不同的类型有着不同的策略。也就是表明不同的类型将决定绑定的 Queue 不同，换言之就是说生产者发送了一个消息，Routing Key 的规则是 A，那么生产者会将 Routing Key=A 的消息推送到 Exchange 中，这时候 Exchange 中会有自己的规则，对应的规则去筛选生产者发来的消息，如果能够对应上 Exchange 的内部规则就将消息推送到对应的 Queue 中去。那么接下来就来详细讲解下 Exchange 里面类型。</p><h3 id="exchange-type"><a class="headerlink" href="#exchange-type"></a> Exchange Type</h3><h4 id="fanout"><a class="headerlink" href="#fanout"></a> fanout</h4><p>把所有发送到该 Exchange 的消息路由到所有与它绑定的 Queue 中。</p><center><p><img src="https://i.loli.net/2018/09/29/5baf368aadc5d.png" alt=""></p></center><p></p><p>上图所示，生产者（P）生产消息 1 将消息 1 推送到 Exchange，由于 Exchange Type=fanout 这时候会遵循 fanout 的规则将消息推送到所有与它绑定 Queue，也就是图上的两个 Queue 最后两个消费者消费。</p><h4 id="direct"><a class="headerlink" href="#direct"></a> direct</h4><p>把消息路由到那些 binding key 与 routing key <strong>完全匹配</strong>的 Queue 中</p><center><p><img src="https://i.loli.net/2018/09/29/5baf3920ec000.png" alt=""></p></center><p></p><p>当生产者（P）发送消息时 Rotuing key=booking 时，这时候将消息传送给 Exchange，Exchange 获取到生产者发送过来消息后，会根据自身的规则进行与匹配相应的 Queue，这时发现 Queue1 和 Queue2 都符合，就会将消息传送给这两个队列，如果我们以 Rotuing key=create 和 Rotuing key=confirm 发送消息时，这时消息只会被推送到 Queue2 队列中，其他 Routing Key 的消息将会被丢弃。</p><h4 id="topic"><a class="headerlink" href="#topic"></a> topic</h4><p>topic 这个规则就是模糊匹配，可以通过通配符满足一部分规则就可以传送。它的约定是:</p><ul><li>routing key 为一个句点号<code>.</code>分隔的字符串（我们将被句点号<code>.</code>分隔开的每一段独立的字符串称为一个单词），如“stock.usd.nyse”、“nyse.vmw”、“quick.orange.rabbit”</li><li>binding key 与 routing key 一样也是句点号<code>.</code>分隔的字符串</li><li>binding key 中可以存在两种特殊字符 <code>*</code>与<code>#</code>，用于做模糊匹配，其中<code>_</code>用于匹配一个单词，<code>#</code>用于匹配多个单词（可以是零个）</li></ul><center><p><img src="https://i.loli.net/2018/09/29/5baf3a49c02b3.png" alt=""></p></center><p></p><p>当生产者发送消息 Routing Key=F.C.E 的时候，这时候只满足 Queue1，所以会被路由到 Queue 中，如果 Routing Key=A.C.E 这时候会被同是路由到 Queue1 和 Queue2 中，如果 Routing Key=A.F.B 时，这里只会发送一条消息到 Queue2 中。</p><h4 id="headers"><a class="headerlink" href="#headers"></a> headers</h4><p>headers 类型的 Exchange 不依赖于 routing key 与 binding key 的匹配规则来路由消息，而是根据发送的消息内容中的 headers 属性进行匹配。<br>在绑定 Queue 与 Exchange 时指定一组键值对；当消息发送到 Exchange 时，RabbitMQ 会取到该消息的 headers（也是一个键值对的形式），对比其中的键值对是否完全匹配 Queue 与 Exchange 绑定时指定的键值对；如果完全匹配则消息会路由到该 Queue，否则不会路由到该 Queue。</p><p>(ing…)</p>]]></content>
      
      
      <categories>
          
          <category> dev </category>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 消息队列 </tag>
            
            <tag> RabbitMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DB[1]-如何正确的跑路，不，删表</title>
      <link href="/2018/09/19/db-1/"/>
      <url>/2018/09/19/db-1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>原文 <a href="https://www.cnblogs.com/rjzheng/p/9497109.html" target="_blank" rel="noopener">https://www.cnblogs.com/rjzheng/p/9497109.html</a></p></blockquote><h2 id="drop-table-产生的影响"><a class="headerlink" href="#drop-table-产生的影响"></a> drop table 产生的影响</h2><p>假设，你有一个表 erp,如果你直接进行下面的命令</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> erp</span><br></pre></td></tr></table></figure><p>这个时候所有的 mysql 的相关进程都会停止，直到 drop 结束，mysql 才会恢复执行。出现这个情况的原因就是因为，在 <code>drop table</code> 的时候，innodb 维护了一个全局锁，drop 完毕锁就释放了。<br>这意味着，如果在白天，访问量非常大的时候，如果你在不做任何处理措施的情况下，执行了删大表的命令，整个 mysql 就挂在那了，在删表期间，QPS 会严重下滑。</p><h2 id="前置"><a class="headerlink" href="#前置"></a> 前置</h2><h3 id="配置共享表空间"><a class="headerlink" href="#配置共享表空间"></a> 配置共享表空间</h3><p>在这里有一个前提，mysql 开启了独立表空间，MySQL5.6.7 之后默认开启。<br>也就是在 my.cnf 中:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">innodb_file_per_table = 1</span><br></pre></td></tr></table></figure><p>查看表空间状态，用下面的命令:<code>show variables like '%per_table';</code></p><p><img src="https://i.loli.net/2018/09/19/5ba19fb795418.png" alt="mysql"><span class="image-caption">mysql</span></p><p>如果 innodb_file_per_table 的 value 值为 OFF，代表采用的是共享表空间。<br>如果 innodb_file_per_table 的 value 值为 ON ，代表采用的是独立表空间。</p><h3 id="独立表空间和共享表空间"><a class="headerlink" href="#独立表空间和共享表空间"></a> 独立表空间和共享表空间</h3><ul><li><p>共享表空间：<br>某一个数据库的所有的表数据，索引文件全部放在一个文件中，默认这个共享表空间的文件路径在 data 目录下。 默认的文件名为:ibdata1(此文件，可以扩展成多个)。注意，在这种方式下，运维超级不方便。你看，所有数据都在一个文件里，要对单表维护，十分不方便。另外，你在做 delete 操作的时候，文件内会留下很多间隙，ibdata1 文件不会自动收缩。换句话说，使用共享表空间来存储数据，会遭遇 drop table 之后，空间无法释放的问题。</p></li><li><p>独立表空间：<br>每一个表都以独立方式来部署，每个表都有一个.frm 表描述文件，还有一个.ibd 文件。<br>.frm 文件：保存了每个表的元数据，包括表结构的定义等，该文件与数据库引擎无关。<br>.ibd 文件：保存了每个表的数据和索引的文件</p><p>注意，在这种方式下，每个表都有自已独立的表空间，这样运维起来方便，可以实现单表在不同数据库之间的移动。另外，在执行 <code>drop table</code> 操作的时候，是可以自动回收表空间。在执行 delete 操作后，可以通过 <code>alter table TableName engine=innodb</code> 可以整理碎片，回收部分表空间。</p></li></ul><h2 id="正确姿势"><a class="headerlink" href="#正确姿势"></a> 正确姿势</h2><p>假设，我们有<code>datadir = /data/mysql/</code>,另外，我们有有一个 database,名为 mytest。在数据库 mytest 中，有一个表，名为 erp，执行下列命令<code>system ls -l /data/mysql/mytest/</code></p><p>得到下面的输出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-rw-r----- 1 mysql mysql          9023  8 18 05:21 erp.frm</span><br><span class="line">-rw-r----- 1 mysql mysql 2356792000512  8 18 05:21 erp.ibd</span><br></pre></td></tr></table></figure><h3 id="建立硬连接"><a class="headerlink" href="#建立硬连接"></a> 建立硬连接</h3><p>这里需要利用了 linux 中硬链接的知识，来进行快速删除。下面容我上《鸟哥的私房菜》中的一些内容，<br>软链接其实大家可以类比理解为 windows 中的快捷方式，就不多介绍了，主要介绍一下硬链接。<br>至于这个硬链接，我简单说一下，不想贴一大堆话过来，看起来太累。<br>就是对于真正存储的文件来说，有一个</p><p><img src="https://i.loli.net/2018/09/19/5ba1a14752657.png" alt="o_pg1.png"><span class="image-caption">o_pg1.png</span><br>然后呢有一个文件名指向上面的 node Index<br><img src="https://i.loli.net/2018/09/19/5ba1a14898dcf.png" alt="o_pg2.png"><span class="image-caption">o_pg2.png</span><br>那么，所谓的硬链接，就是不止一个文件名指向 node Index，有好几个文件名指向 node Index。<br>假设，这会又有一个文件名指向上面的 node Index，即<br><img src="https://i.loli.net/2018/09/19/5ba1a149d30b0.png" alt="o_pg3.png"><span class="image-caption">o_pg3.png</span><br>这个时候，你做了删除文件名(1)的操作，linux 系统检测到，还有一个文件名(2)指向 node Index，因此并不会真正的把文件删了，而是把步骤(2)的引用给删了，这步操作非常快，毕竟只是删除引用。于是图就变成了这样<br><img src="https://i.loli.net/2018/09/19/5ba1a14b2726f.png" alt="o_pg4.png"><span class="image-caption">o_pg4.png</span><br>接下来，你再做删除文件名(2)的操作，linux 系统检测到，没有其他文件名指向该 node Index，就会删除真正的存储文件，这步操作，是删真正的文件，所以比较慢。</p><p>OK，我们用的就是上面的原理。<br>先给 erp.ibd 建立一个硬链接，利用 ln 命令<br><code>mysql&gt; system ln /data/mysql/mytest/erp.ibd /data/mysql/mytest/erp.ibd.hdlk</code><br>此时，文件目录如下所示</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-rw-r----- 1 mysql mysql          9023  8 18 05:21 erp.frm</span><br><span class="line">-rw-r----- 2 mysql mysql 2356792000512  8 18 05:21 erp.ibd</span><br><span class="line">-rw-r----- 2 mysql mysql 2356792000512  8 18 05:21 erp.ibd.hdlk</span><br></pre></td></tr></table></figure><p>你会发现，多了一个 erp.ibd.hdlk 文件，且 erp.ibd 和 erp.ibd.hdlk 的 inode 均为 2。<br>此时，你执行 drop table 操作</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> erp;</span><br><span class="line"># Query OK, 0 rows affected (0.99 sec)</span><br></pre></td></tr></table></figure><p>你会发现，不到 1 秒就删除了。因为，此时有两个文件名称(erp.ibd 和 erp.ibd.hdlk),同时指向一个 inode.这个时候，执行删除操作，只是把引用给删了，所以非常快。<br>那么，这时的删除，已经把 table 从 mysql 中删除。但是磁盘空间，还没释放，因为还剩一个文件 erp.ibd.hdlk。<br>如果用 rm 命令来删。这里需要说明的是，在生产环境，直接用 rm 命令来删大文件，会造成磁盘 IO 开销飙升,CPU 负载过高，是会影响其他程序运行的。<br>那么，这种时候，就是应该用 truncate 命令来删，truncate 命令在 coreutils 工具集中。<br>详情，大家可以去百度一下，有人对 rm 和 truncate 命令，专程测试过，truncate 命令对磁盘 IO，CPU 负载几乎无影响。<br>删除脚本如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TRUNCATE=/usr/<span class="built_in">local</span>/bin/truncate</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> `seq 2194 -10 10 `;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  sleep 2</span><br><span class="line">  <span class="variable">$TRUNCATE</span> -s <span class="variable">$&#123;i&#125;</span>G /data/mysql/mytest/erp.ibd.hdlk</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line">rm -rf /data/mysql/mytest/erp.ibd.hdlk ;</span><br></pre></td></tr></table></figure><p>从 2194G 开始，每次缩减 10G，停 2 秒，继续，直到文件只剩 10G，最后使用 rm 命令删除剩余的部分。</p><blockquote><p>作者：孤独烟</p></blockquote><h2 id="步骤总结"><a class="headerlink" href="#步骤总结"></a> 步骤总结</h2><ul><li><p>确认 mysql 配置 是否开启独立表空间<br>mysql 版本 5.6.7 默认开启<br>配置文件 my.cnf &gt; <code>innodb_file_per_table = 1</code><br>查看配置：<code>show variables like '%per_table';</code> value=NO 表示开启</p></li><li><p>创建硬链接<br><code>system ln [表空间地址]] [新的硬链接地址]</code><br><code>system ln /data/mysql/mytest/erp.ibd /data/mysql/mytest/erp.ibd.hdlk</code></p></li><li><p>执行 <code>drop table</code> 操作</p></li><li><p>使用脚本删除表数据文件（.hdlk 文件）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TRUNCATE=/usr/<span class="built_in">local</span>/bin/truncate</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> `seq 2194 -10 10 `;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">sleep 2</span><br><span class="line"><span class="variable">$TRUNCATE</span> -s <span class="variable">$&#123;i&#125;</span>G /data/mysql/mytest/erp.ibd.hdlk</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line">rm -rf /data/mysql/mytest/erp.ibd.hdlk ;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> dev </category>
          
          <category> database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DB[0]：mysql-SQL &amp; 索引 性能优化</title>
      <link href="/2018/09/18/db-0/"/>
      <url>/2018/09/18/db-0/</url>
      
        <content type="html"><![CDATA[<h2 id="关于优化"><a class="headerlink" href="#关于优化"></a> 关于优化</h2><ul><li>第一阶段 sql 优化&amp;索引优化</li><li>第二阶段 搭建缓存</li><li>第三阶段 读写分离</li><li>第四阶段 利用分区表（不推荐）</li><li>第五阶段 垂直拆分</li><li>第六阶段 水平拆分</li></ul><h2 id="sql-优化索引优化"><a class="headerlink" href="#sql-优化索引优化"></a> sql 优化&amp;索引优化</h2><h3 id="执行计划分析"><a class="headerlink" href="#执行计划分析"></a> 执行计划分析</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 表结构</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`beas_class_type`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`cname`</span> <span class="built_in">varchar</span>(<span class="number">500</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`ename`</span> <span class="built_in">varchar</span>(<span class="number">500</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`code`</span> <span class="built_in">varchar</span>(<span class="number">200</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`gid`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> <span class="string">`code_gid`</span> (<span class="string">`code`</span>,<span class="string">`gid`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure><p>EXPLAIN 执行计划中 type 字段分为以下几种：</p><p><strong>性能从差到优</strong><br><strong>ALL &lt; INDEX &lt; RANGE &lt; REF &lt; EQ_REF &lt; CONST,SYSTEM &lt; NULL</strong></p><h4 id="all"><a class="headerlink" href="#all"></a> ALL</h4><p>type = ALL，全表扫描，MYSQL 扫描全表来找到匹配的行。</p><h4 id="index"><a class="headerlink" href="#index"></a> INDEX</h4><p>type = index，索引全扫描，MYSQL 遍历整个索引来查找匹配的行。（虽然 where 条件中没有用到索引，但是要取出的列 是索引包含的列，所以只要全表扫描索引即可，直接使用索引树查找数据）。<br><img src="https://i.loli.net/2018/09/18/5ba064fd08532.png" alt="sql"><span class="image-caption">sql</span></p><h4 id="range"><a class="headerlink" href="#range"></a> RANGE</h4><p>type = range ，索引范围扫描，常见于&lt;、&lt;=、&gt;、&gt;=、between、in 等操作符<br><img src="https://i.loli.net/2018/09/18/5ba065a27abde.png" alt="sql"><span class="image-caption">sql</span><br><img src="https://i.loli.net/2018/09/18/5ba06608aa9ff.png" alt="sql"><span class="image-caption">sql</span></p><h4 id="ref"><a class="headerlink" href="#ref"></a> REF</h4><p>type = ref ，使用非唯一性索引或者唯一索引的前缀扫描，返回匹配某个单独值的记录行。</p><blockquote><p>注意下边两张图的索引使用情况</p></blockquote><p><img src="https://i.loli.net/2018/09/18/5ba066684882b.png" alt="sql"><span class="image-caption">sql</span><br><img src="https://i.loli.net/2018/09/18/5ba066d91edf3.png" alt="sql"><span class="image-caption">sql</span></p><h4 id="eq_ref"><a class="headerlink" href="#eq_ref"></a> EQ_REF</h4><p>type = eq_ref，相对于 ref 来说就是使用的是唯一索引，对于每个索引键值，只有唯一的一条匹配记录（在联表查询中使用 primary key 或者 unique key 作为关联条件）</p><h4 id="constsystem"><a class="headerlink" href="#constsystem"></a> CONST,SYSTEM</h4><p>type = const/system，单表中最多只有一条匹配行，查询起来非常迅速，所以这个匹配行中的其他列中的值可以被优化器在当前查询中当做常量来处理。例如根据主键或者唯一索引进行的查询。<br><img src="https://i.loli.net/2018/09/18/5ba0680e45dc6.png" alt="sql.png"><span class="image-caption">sql.png</span><br><img src="https://i.loli.net/2018/09/18/5ba0682c7ac77.png" alt="sql.png"><span class="image-caption">sql.png</span></p><h4 id="null"><a class="headerlink" href="#null"></a> NULL</h4><p>type = NULL，MYSQL 不用访问表或者索引就直接能到结果。</p><h3 id="索引优化"><a class="headerlink" href="#索引优化"></a> 索引优化</h3><p>常用的索引有：B-Tree 索引，哈希索引，空间索引，全文索引。除此之外，按照数据存储方式可以分为聚集索引和非聚集索引。</p><h4 id="b-tree-索引"><a class="headerlink" href="#b-tree-索引"></a> B-Tree 索引</h4><p><img src="https://i.loli.net/2018/09/18/5ba069ef7d565.png" alt="B-Tree 索引"><span class="image-caption">B-Tree 索引</span><br>结构中，每一层节点均从左往右从小到大排列，key1 &lt; key2 &lt; … &lt; keyN，对于小于 key1 或在[key1，key2)或其他的值的节点，在进入叶子节点查找，是一个范围分布，同时，同一层节点之间可直接访问，因为他们之间有指针指向联系（MyISAM 的 BTREE 索引没有）。每次搜索是一个区间搜索，有的话就找到了，没有的话就是空。索引能加快访问速度，因为有了它无需全表扫描数据（不总是这样），根据查找的值，跟节点中的值比较，通常使用二分查找，对于排好序的数值来说，平均速度几乎是最快的。</p><p>val 指向了哪里，对于 InnoDB，它指向的就是表数据，因为 InnoDB 的表数据本身就是索引文件，这是与 MyISAM 索引的显著区别，MyISAM 的索引指向的是表数据的地址（val 指向的是类似于 0x7DFF…之类）。</p><p>前面在 BTREE 的抽象结构中，索引值的节点是放在页中的，这里有两个需注意的问题：</p><ol><li><p>计算机的存储空间是一块一块的，通常一块用完了再用另一块，如果上一块只剩余 5kb，但这里刚好要申请 8kb 的空间，就需要在一个新的块上申请这个空间，然后以后的申请又接在这个 8kb 后面，只要这个块的空间足够，那么上一块的 5kb 通常就成了所谓的“碎片”。在 mysql 中，这里的页可理解为块存储空间，即索引的树节点是存放在页中的，每一页（称为逻辑页）有固定大小，InnoDB 目前是 16kb，一页用完了，当继续插入表生成新的索引节点时，就去新的页中存储这个节点，再有新的节点就继续放在这个新的页的节点后面。</p></li><li><p>页分裂问题，一页总要被存满，然后新开一页继续，这种行为被称作页分裂。何时开辟新的页，mysql 规定了一个分裂因子，达到页存储空间的 15/16 则存到下一页。页分裂的存在可能极大影响性能维护索引的性能。通常提倡的是，设定一个无意义的整数自增索引，有利于索引存储。</p><p>如果非自增或不是整数索引，如非自增整数、类似 MD5 的字符串，以他们作为索引值时，因为待插入的下一条数据的值不一定比上一条大，甚至比当前页所有值都小，需要跑到前几页去比较而找到合适位置，InnoDB 无法简单的把新行插入到上一行后面，而找到并插入索引后，可能导致该页达到分裂因子阀值，需要页分裂，进一步导致后面所有的索引页的分裂和排序，数据量小也许没什么问题，数据量大的话可能会浪费大量时间，产生许多碎片。</p><p>主键总是唯一且非空，InnoDB 自动对它建立了索引（primary key），对于非主键字段上建立的索引，又称辅助索引，索引排列也是顺序排列，只是它还附带一个本条记录的主键值的数据域，不是指向本数据行的指针，在使用辅助索引查找时，先找到对应这一列的索引值，再根据索引节点上的另一个数据域—主键值，来查找该行记录，即每次查找实际经过查找了两次。额外的数据域存储主键值的好处是，当页分裂发生时，无需修改数据域的值，因为即使页分裂，该行的主键值是不变的，而地址就变了。</p></li></ol><p>包含一列的索引称为单列索引，多列的称为复合索引，因为 BTREE 索引是顺序排列的，所以比较适合范围查询，但是在复合索引中，还应注意列数目、列的顺序以及前面范围查询的列对后边列的影响。</p><h5 id="btree-索引使用"><a class="headerlink" href="#btree-索引使用"></a> BTREE 索引使用</h5><p>在 BTREE 索引的使用上，以下几种情况可以用到该索引或索引的一部分（使用 explain 简单查看使用情况）：</p><ol><li>全值匹配</li><li>匹配最左列，对于复合索引来说，不总是匹配所有字段列，但是可以匹配索引中靠左的列</li><li>匹配列前缀，即一个索引中列的前一部分，主要用在模糊匹配（like ‘xxx%’）</li><li>匹配范围</li><li>精确匹配一列并范围匹配右侧相邻列，即前一列是固定值，后一列是范围值</li><li>只访问索引的查询(select 字段都存在索引)</li><li>前缀索引<br>某些列，一般是字符串类型，很长，全部作为索引大大增加存储空间，索引也需要维护，对于长字符串，又想作为索引列，一个可取的办法就是取前一部分（前缀），代表一整列作为索引串，问题是：如何确保这个前缀能代表或大致代表这一列？所以 mysql 中有个概念是索引的选择性，是指索引中不重复的值的数目（也称基数）与整个表该列记录总数（#T）的比值，比如一个列表（1,2,2,3），总数是 4，不重复值数目为 3，选择性为 3/4，因此选择性范围是[1/#T, 1]，这个值越大，表示列中不重复值越多，越适合作为前缀索引，唯一索引（UNIQUE KEY）的选择性是 1。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> tab <span class="keyword">add</span> <span class="keyword">index</span> idx_pn(<span class="keyword">name</span>(<span class="number">9</span>)); <span class="comment">--单独前缀索引</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> tab <span class="keyword">add</span> <span class="keyword">index</span> idx_cpn(<span class="keyword">count</span>, <span class="keyword">name</span>(<span class="number">9</span>)); <span class="comment">--复合前缀索引</span></span><br></pre></td></tr></table></figure></li></ol><p>以上为常见的使用索引的方式，有这么些情况不能用或不能全用，有的就是上面情况的反例，以 key(a, b, c)为例</p><ol><li>跳过列，where a = 1 and c = 3，最多用到索引列 a；where b = 2 and c = 3，一个也用不到，必须从最左列开始</li><li>前面是范围查询，where a = 1 and b &gt; 2 and c = 3，最多用到 a, b 两个索引列；</li><li>索引列上使用了表达式，如 where substr(a, 1, 3) = ‘hhh’，where a = a + 1，表达式是一大忌讳，再简单 mysql 也不认。有时数据量不是大到严重影响速度时，一般可以先查出来，比如先查所有有订单记录的数据，再在程序中去筛选以’cp1001’开头的订单，而不是写 sql 过滤它；</li><li>模糊匹配时，尽量写 where a like ‘J%’，字符串放在左边，这样才可能用得到 a 列索引，甚至可能还用不到，当然这得看数据类型，最好测试一下。</li></ol><h5 id="排序对索引的影响"><a class="headerlink" href="#排序对索引的影响"></a> 排序对索引的影响</h5><p>排序也遵循最左前缀列的原则</p><h4 id="哈希索引"><a class="headerlink" href="#哈希索引"></a> 哈希索引</h4><p>类似于数据结构中简单实现的 HASH 表（散列表）一样，当我们在 mysql 中用哈希索引时，也是对索引列计算一个散列值（类似 md5、sha1、crc32），然后对这个散列值以顺序（默认升序）排列，同时记录该散列值对应数据表中某行的指针。</p><p>建立 hash 索引，生成 hash 值按顺序排列，但是顺序排列的 hash 值并不对应表中记录，从地址指针可反应出来，而且，hash 索引可能建立在两列或者更多列上，取得是多列数据后的 hash 值，它不存储表中数据。它先计算列数据的 hash 值，与索引中的 hash 值比较，找到了然后比对列数据是否相等，可能涉及其他列条件，然后返回数据。hash 当然会有冲突，即碰撞，除非有很多冲突，一般 hash 索引效率很高，否则 hash 维护成本较高，因此哈希索引通常用在选择性较高的列上面。哈希索引的结构决定了它的特点：</p><ol><li>hash 索引只是 hash 值顺序排列，跟表数据没有关系，无法应用于 order by；</li><li>hash 索引是对它的所有列计算哈希值，因此在查询时，必须带上所有列，比如有(a, b)哈希索引，查询时必须 where a = 1 and b = 2，少任何一个不行；</li><li>hash 索引只能用于比较查询 = 或 IN，其他范围查询无效，本质还是因不存储表数据；</li><li>一旦出现碰撞，hash 索引必须遍历所有的 hash 值，将地址所指向数据一一比较，直到找到所有符合条件的行。</li></ol>]]></content>
      
      
      <categories>
          
          <category> dev </category>
          
          <category> database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> 优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM[5]-一张图看懂JVM</title>
      <link href="/2018/09/17/JVM-5/"/>
      <url>/2018/09/17/JVM-5/</url>
      
        <content type="html"><![CDATA[<blockquote><p>大佬的 JVM 结构图，来源见水印</p></blockquote><p><img src="/2018/09/17/JVM-5/JVM-5.jpg" alt="JVM结构示意图"><span class="image-caption">JVM结构示意图</span></p>]]></content>
      
      
      <categories>
          
          <category> dev </category>
          
          <category> java </category>
          
          <category> jvm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vscode-插件列表</title>
      <link href="/2018/09/15/vscode-plugins/"/>
      <url>/2018/09/15/vscode-plugins/</url>
      
        <content type="html"><![CDATA[<center><p><img src="https://i.loli.net/2018/09/22/5ba530429c498.png" alt="插件列表"><span class="image-caption">插件列表</span></p></center><p></p>]]></content>
      
      
      <categories>
          
          <category> dev </category>
          
          <category> tool </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vscode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git-多密钥配置</title>
      <link href="/2018/09/13/git-0/"/>
      <url>/2018/09/13/git-0/</url>
      
        <content type="html"><![CDATA[<h2 id="安装-git"><a class="headerlink" href="#安装-git"></a> 安装 git</h2><p>下载地址：<a href="https://git-scm.com/" target="_blank" rel="noopener">https://git-scm.com/</a></p><h2 id="创建-sshkey"><a class="headerlink" href="#创建-sshkey"></a> 创建 sshKey</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 切换目录到.ssh下</span></span><br><span class="line"><span class="built_in">cd</span> ~/.ssh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成私钥 (可以根据自己的需求生成多把，比如私人和企业使用不同的邮箱地址)</span></span><br><span class="line">ssh-keygen -t rsa -C <span class="string">"youremail@example.com"</span> -f [id-rsa-name]</span><br><span class="line"><span class="comment"># eg: ssh-keygen -t rsa -C "123@example.com" -f id-rsa-personal</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加私钥 (因为默认私钥名称为id_rsa，为了可以识别自定义的密钥需要执行一下指令)</span></span><br><span class="line">ssh-add ~/.ssh/[id-rsa-name]</span><br><span class="line"><span class="comment"># eg: ssh-add ~/.ssh/id-rsa-personal</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意！如果以上执行出现Could not open a connection to your authentication agent. 先输入一下指令 再重试上一步骤</span></span><br><span class="line">ssh-agent bash</span><br></pre></td></tr></table></figure><p>生成密钥如下：</p><center><p><img src="/2018/09/13/git-0/1.png" alt=".ssh"><span class="image-caption">.ssh</span></p></center><p></p><h2 id="在-git-远程仓库中添加-ssh-key"><a class="headerlink" href="#在-git-远程仓库中添加-ssh-key"></a> 在 git 远程仓库中添加 ssh-key</h2><ul><li>github 为例:<ol><li>用户头像 -&gt; settings -&gt; SSH and GPG keys -&gt; New SSH Key</li><li>title 随意，建议使用生成 key 时的邮箱地址</li><li>key 填写 生成的 [id-rsa-name].pub 文件 里的一串字符</li><li>Add SSH Key</li></ol></li></ul><p><img src="https://i.loli.net/2018/09/13/5b9a6331577ef.png" alt="github 设置ssh-key"><span class="image-caption">github 设置ssh-key</span></p><h2 id="配置-config-文件"><a class="headerlink" href="#配置-config-文件"></a> 配置 config 文件</h2><p>Host 为别名 可以随意，建议与 HostName 一致<br>HostName 为 git 远程仓库 ip 地址或域名<br>IdentityFile 为该仓库添加的公钥对应的本机私钥地址，也就是~/.ssh/路径下的私钥<br>PreferredAuthentications 为验证方式，这里通过共私钥方式 所以如下设置即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Host github.com</span><br><span class="line">    HostName github.com</span><br><span class="line">    PreferredAuthentications publickey</span><br><span class="line">    User youremail@example.com</span><br><span class="line">    IdentityFile ~/.ssh/id_rsa_personal</span><br><span class="line"></span><br><span class="line">Host gitee.com</span><br><span class="line">    HostName gitee.com</span><br><span class="line">    PreferredAuthentications publickey</span><br><span class="line">    User youremail@example.com</span><br><span class="line">    IdentityFile ~/.ssh/id_rsa_personal</span><br></pre></td></tr></table></figure><h2 id="链接测试必须"><a class="headerlink" href="#链接测试必须"></a> 链接测试（必须）</h2><p>这个步骤是必须的，否则在或许的操作这可能会出现无法 push 或者 clone 项目的问题。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br><span class="line">ssh -T git@gitee.com</span><br></pre></td></tr></table></figure><p>如果返回 Hi [用户名] … 表示成功。</p><center><p><img src="/2018/09/13/git-0/2.png" alt=".ssh"><span class="image-caption">.ssh</span></p></center><p></p><h2 id="项目使用"><a class="headerlink" href="#项目使用"></a> 项目使用</h2><p>我们这里不设置全局的用户名和邮箱，防止不同的项目中使用了错误的用户名或邮箱，在没有全局用户名邮箱时，在新项目中使用 git 会提示没有设置用户名邮箱，这样可以提醒我们为这个项目设置本地的用户名邮箱。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入项目文件下</span></span><br><span class="line"><span class="built_in">cd</span> your-project-path</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置本地用户名邮箱</span></span><br><span class="line">git config --<span class="built_in">local</span> user.name <span class="string">"xxx"</span></span><br><span class="line">git config --<span class="built_in">local</span> user.email <span class="string">"xxx@xxx.com"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果你依然需要设置全局的：</span></span><br><span class="line">git config --global user.name <span class="string">"xxx"</span></span><br><span class="line">git config --global user.email <span class="string">"xxx@xxx.com"</span></span><br></pre></td></tr></table></figure><p>完成！</p>]]></content>
      
      
      <categories>
          
          <category> dev </category>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发[4]-各种BlockingQueue</title>
      <link href="/2018/09/11/thread-4/"/>
      <url>/2018/09/11/thread-4/</url>
      
        <content type="html"><![CDATA[<h2 id="生产者-消费者场景"><a class="headerlink" href="#生产者-消费者场景"></a> &quot;生产者-消费者&quot;场景</h2><p>在 “生产者-消费者” 场景中，队列通常被视作线程间操作的数据容器，这样，可以对各个模块的业务功能进行解耦，生产者将“生产”出来的数据放置在数据容器中，而消费者仅仅只需要在“数据容器”中进行获取数据即可，这样生产者线程和消费者线程就能够进行解耦，只专注于自己的业务功能即可。</p><p>而阻塞队列（BlockingQueue）就被广泛使用在“生产者-消费者”场景中。原因是 BlockingQueue 提供了可阻塞的插入和移除的方法。当队列容器已满，生产者线程会被阻塞，直到队列未满；当队列容器为空时，消费者线程会被阻塞，直至队列非空时为止。</p><h2 id="blockingqueue-基本操作"><a class="headerlink" href="#blockingqueue-基本操作"></a> BlockingQueue 基本操作</h2><p>BlockingQueue基本操作总结如下：</p><table><thead><tr><th></th><th>Throws exception</th><th>Special value(true / false)</th><th>Blocks</th><th>Time out</th></tr></thead><tbody><tr><td><strong>Insert</strong></td><td>add(e)</td><td>offer(e)</td><td>put(e)</td><td>offer(e,time,unit)</td></tr><tr><td><strong>Remove</strong></td><td>remove()</td><td>poll()</td><td>take()</td><td>poll(time,unit)</td></tr><tr><td><strong>Examine</strong></td><td>element()</td><td>peek()</td><td>[not applicable]</td><td>[not applicable]</td></tr></tbody></table><p>BlockingQueue继承于Queue接口</p><h3 id="插入队列元素"><a class="headerlink" href="#插入队列元素"></a> 插入队列元素</h3><ul><li>add(E e):boolean 往队列插入数据，当队列满时，插入元素时 <strong>会抛出IllegalStateException异常</strong></li><li>offer(E e):boolean 当往队列插入数据时，插入成功返回true，否则则返回false。当队列满时 <strong>不会抛出异常</strong></li><li>put(E e):void 当阻塞队列容量已经满时，往阻塞队列插入数据的线程 <strong>会被阻塞</strong>，直至阻塞队列已经有空余的容量可供使用</li><li>offer(E e, long timeout, TimeUnit unit):boolean 若阻塞队列已经满时，同样会阻塞插入数据的线程，直至阻塞队列已经有空余的地方，与put方法不同的是，该方法会有一个超时时间，若超过当前给定的超时时间，插入数据的线程会退出</li></ul><h3 id="删除元素"><a class="headerlink" href="#删除元素"></a> 删除元素</h3><ul><li>remove(Object o):boolean 从队列中删除数据，成功则返回true，否则为false</li><li>remove():Object 从队列中删除数据，成功则返回元素对象，否则 <strong>会抛出NoSuchElementException异常</strong></li><li>poll:Object 删除并返回数据，当队列为空时，返回null</li><li>poll(long timeout, TimeUnit unit):Object 删除并返回数据，当队列为空时，返回null</li><li>take():Object 删除并返回数据,当阻塞队列为空时，获取队头数据的线程 <strong>会被阻塞</strong></li></ul><h3 id="查看元素"><a class="headerlink" href="#查看元素"></a> 查看元素</h3><ul><li>element:Object 获取队头元素，如果队列为空时则 <strong>抛出NoSuchElementException异常</strong></li><li>peek:Object 获取队头元素，如果队列为空 <strong>则返回null</strong></li></ul><h3 id="特点"><a class="headerlink" href="#特点"></a> 特点</h3><ul><li><p><strong>不接受 null 元素</strong>。<br>试图 add、put 或 offer 一个 null 元素时，某些实现会抛出 NullPointerException。null 被用作指示 poll 操作失败的警戒值。</p></li><li><p><strong>可以是限定容量的</strong>。<br>它在任意给定时间都可以有一个 remainingCapacity，超出此容量，便无法无阻塞地 put 附加元素。没有任何内部容量约束的 BlockingQueue 总是报告Integer.MAX_VALUE 的剩余容量。</p></li><li><p>实现主要用于生产者-使用者队列，但它另外还支持 Collection 接口。<br>因此，举例来说，使用 remove(x) 从队列中移除任意一个元素是有可能的。然而，这种操作通常不会有效执行，只能有计划地偶尔使用，比如在取消排队信息时。</p></li><li><p><strong>实现是线程安全的</strong>。<br>所有排队方法都可以使用内部锁或其他形式的并发控制来自动达到它们的目的。然而，大量的 Collection 操作（addAll、containsAll、retainAll 和removeAll）没有 必要自动执行，除非在实现中特别说明。因此，举例来说，在只添加了 c 中的一些元素后，<code>addAll(c)</code> 有可能失败（抛出一个异常）。</p></li></ul><h2 id="常用的blockingqueue实现类"><a class="headerlink" href="#常用的blockingqueue实现类"></a> 常用的BlockingQueue实现类</h2><p>实现BlockingQueue接口的有 ArrayBlockingQueue, DelayQueue, LinkedBlockingDeque, LinkedBlockingQueue, LinkedTransferQueue, PriorityBlockingQueue, SynchronousQueue</p><h3 id="arrayblockingqueue"><a class="headerlink" href="#arrayblockingqueue"></a> ArrayBlockingQueue</h3><p>一个由数组支持的有界阻塞队列。<br>此队列按 FIFO（先进先出）原则对元素进行排序。<br>队列的头部 是在队列中存在时间最长的元素。队列的尾部 是在队列中存在时间最短的元素。<br>新元素插入到队列的尾部，队列获取操作则是从队列头部开始获得元素。</p><p>这是一个典型的“有界缓存区”，固定大小的数组在其中保持生产者插入的元素和使用者提取的元素。一旦创建了这样的缓存区，就不能再增加其容量。试图向已满队列中放入元素会导致操作受阻塞；试图从空队列中提取元素将导致类似阻塞。</p><p>此类支持对等待的生产者线程和使用者线程进行排序的可选公平策略。默认情况下，不保证是这种排序。然而，通过将公平性 (fairness) 设置为 true 而构造的队列允许按照 FIFO 顺序访问线程。公平性通常会降低吞吐量，但也减少了可变性和避免了“不平衡性”</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> BlockingQueue&lt;String&gt; blockingQueue = <span class="keyword">new</span> ArrayBlockingQueue(<span class="number">10</span>,<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><h3 id="delayqueue-延迟队列"><a class="headerlink" href="#delayqueue-延迟队列"></a> DelayQueue 延迟队列</h3><p>Delayed 元素的一个无界阻塞队列，只有在延迟期满时才能从中提取元素。<br>该队列的头部是延迟期满后保存时间最长的 Delayed 元素。<strong>如果延迟都还没有期满，则队列没有头部，并且 poll 将返回 null</strong>。<br>当一个元素的 getDelay(TimeUnit.NANOSECONDS) 方法返回一个小于等于 0 的值时，将发生到期。即使无法使用 take 或 poll 移除未到期的元素，也不会将这些元素作为正常元素对待。例如，size 方法同时返回到期和未到期元素的计数。此队列不允许使用 null 元素</p><p>延迟队列示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> TheEmbers</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * createTime 2018-09-11 12:23</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayQueueDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayedTask</span> <span class="keyword">implements</span> <span class="title">Delayed</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> Long delayTime; <span class="comment">// -&gt; 阻塞时间</span></span><br><span class="line">        <span class="keyword">public</span> TimeUnit delayTimeUnit; <span class="comment">// -&gt; 阻塞时间单位</span></span><br><span class="line">        <span class="keyword">public</span> Long executeTime;<span class="comment">//ms // -&gt; 执行时间</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">DelayedTask</span><span class="params">(<span class="keyword">long</span> delayTime, TimeUnit delayTimeUnit)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.delayTime = delayTime;</span><br><span class="line">            <span class="keyword">this</span>.delayTimeUnit = delayTimeUnit;</span><br><span class="line">            <span class="keyword">this</span>.executeTime = System.currentTimeMillis() + delayTimeUnit.toMillis(delayTime); <span class="comment">// -&gt; 系统当前时间 + 阻塞时间</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 计算当前时间到执行时间之间还有多长时间</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> unit</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getDelay</span><span class="params">(TimeUnit unit)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> unit.convert(executeTime - System.currentTimeMillis(), TimeUnit.MILLISECONDS);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 判断队列中元素的顺序谁前谁后。当前元素比队列元素后执行时，返回一个正数，比它先执行时返回一个负数，否则返回0</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> o</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Delayed o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.getDelay(TimeUnit.MILLISECONDS) &gt; o.getDelay(TimeUnit.MILLISECONDS)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.getDelay(TimeUnit.MILLISECONDS) &lt; o.getDelay(TimeUnit.MILLISECONDS)) &#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"DelayedTask&#123;"</span> +</span><br><span class="line">                    <span class="string">"delayTime="</span> + delayTime +</span><br><span class="line">                    <span class="string">", delayTimeUnit="</span> + delayTimeUnit +</span><br><span class="line">                    <span class="string">", executeTime="</span> + executeTime +</span><br><span class="line">                    <span class="string">'&#125;'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DelayQueue&lt;DelayedTask&gt; queue = <span class="keyword">new</span> DelayQueue&lt;&gt;();</span><br><span class="line">        queue.add(<span class="keyword">new</span> DelayedTask(<span class="number">4L</span>, TimeUnit.SECONDS));</span><br><span class="line">        queue.add(<span class="keyword">new</span> DelayedTask(<span class="number">2L</span>, TimeUnit.SECONDS));</span><br><span class="line">        queue.add(<span class="keyword">new</span> DelayedTask(<span class="number">3L</span>, TimeUnit.SECONDS));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"queue put done"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                DelayedTask task = queue.take();</span><br><span class="line">                System.out.println(task.toString());</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 输出： 注意输出顺序与插入顺序的区别</span></span><br><span class="line">    <span class="comment">//    queue put done</span></span><br><span class="line">    <span class="comment">//    DelayedTask&#123;delayTime=2, delayTimeUnit=SECONDS, executeTime=1536640039477&#125;</span></span><br><span class="line">    <span class="comment">//    DelayedTask&#123;delayTime=3, delayTimeUnit=SECONDS, executeTime=1536640040477&#125;</span></span><br><span class="line">    <span class="comment">//    DelayedTask&#123;delayTime=4, delayTimeUnit=SECONDS, executeTime=1536640041477&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="linkedblockingqueue-链阻塞队列"><a class="headerlink" href="#linkedblockingqueue-链阻塞队列"></a> LinkedBlockingQueue 链阻塞队列</h3><p>LinkedBlockingQueue 内部以一个链式结构(链接节点)对其元素进行存储。如果需要的话，这一链式结构可以选择一个上限。如果没有定义上限，将使用 Integer.MAX_VALUE 作为上限。<br>LinkedBlockingQueue 内部以 FIFO(先进先出)的顺序对元素进行存储。队列中的头元素在所有元素之中是放入时间最久的那个，而尾元素则是最短的那个。</p><h3 id="priorityblockingqueue-优先级阻塞队列"><a class="headerlink" href="#priorityblockingqueue-优先级阻塞队列"></a> PriorityBlockingQueue 优先级阻塞队列</h3><p>一个无界阻塞队列，它使用与类 PriorityQueue 相同的顺序规则，并且提供了阻塞获取操作。虽然此队列逻辑上是无界的，但是资源被耗尽时试图执行 add 操作也将失败（导致OutOfMemoryError）。此类不允许使用 null 元素。依赖自然顺序的优先级队列也不允许插入不可比较的对象（这样做会导致抛出 ClassCastException）。</p><p>此类及其迭代器可以实现 Collection 和 Iterator 接口的所有可选 方法。iterator() 方法中提供的迭代器并不 保证以特定的顺序遍历 PriorityBlockingQueue 的元素。如果需要有序地进行遍历，则应考虑使用 <code>Arrays.sort(pq.toArray())</code>。此外，可以使用方法 drainTo 按优先级顺序移除 全部或部分元素，并将它们放在另一个 collection 中。</p><p>在此类上进行的操作不保证具有同等优先级的元素的顺序。如果需要实施某一排序，那么可以定义自定义类或者比较器，比较器可使用修改键断开主优先级值之间的联系。例如，以下是应用先进先出 (first-in-first-out) 规则断开可比较元素之间联系的一个类。要使用该类，则需要插入一个新的 FIFOEntry(anEntry) 来替换普通的条目对象。</p><h3 id="synchronousqueue-同步队列"><a class="headerlink" href="#synchronousqueue-同步队列"></a> SynchronousQueue 同步队列</h3><p>SynchronousQueue 是一个特殊的队列，它的内部同时只能够容纳单个元素。如果该队列已有一元素的话，试图向队列中插入一个新元素的线程将会阻塞，直到另一个线程将该元素从队列中抽走。同样，如果该队列为空，试图向队列中抽取一个元素的线程将会阻塞，直到另一个线程向队列中插入了一条新的元素。</p><h3 id="blockingdeque-阻塞双端队列"><a class="headerlink" href="#blockingdeque-阻塞双端队列"></a> BlockingDeque 阻塞双端队列</h3><p>一个基于已链接节点的、任选范围的阻塞双端队列。<br>可选的容量范围构造方法参数是一种防止过度膨胀的方式。如果未指定容量，那么容量将等于 Integer.MAX_VALUE。只要插入元素不会使双端队列超出容量，每次插入后都将动态地创建链接节点。<br>大多数操作都以固定时间运行（不计阻塞消耗的时间）。异常包括 remove、removeFirstOccurrence、removeLastOccurrence、contains、iterator.remove() 以及批量操作，它们均以线性时间运行。</p>]]></content>
      
      
      <categories>
          
          <category> dev </category>
          
          <category> java </category>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 并发 </tag>
            
            <tag> 多线程 </tag>
            
            <tag> BlockingQueue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux-常用操作命令</title>
      <link href="/2018/09/08/linux-0/"/>
      <url>/2018/09/08/linux-0/</url>
      
        <content type="html"><![CDATA[<p><s>朋友， <code>rm -rf /*</code> 怕不怕 😈</s></p><a id="more"></a><h2 id="常用指令"><a class="headerlink" href="#常用指令"></a> 常用指令</h2><h3 id="ls-显示文件或目录"><a class="headerlink" href="#ls-显示文件或目录"></a> ls 显示文件或目录</h3><ul><li><code>-l</code> 列出文件详细信息 l(list)</li><li><code>-a</code> 列出当前目录下所有文件及目录，包括隐藏的 a(all)</li><li><code>ls -a -l</code> 相当于 <code>ll</code></li></ul><p><img src="https://i.loli.net/2018/09/08/5b934827926ce.png" alt="ON.png"><span class="image-caption">ON.png</span></p><h3 id="mkdir-创建目录"><a class="headerlink" href="#mkdir-创建目录"></a> mkdir 创建目录</h3><ul><li><code>-p</code> 创建目录，若无父目录，则创建 p(parent)</li></ul><p><img src="https://i.loli.net/2018/09/08/5b9348de952b9.png" alt="ON.png"><span class="image-caption">ON.png</span></p><h3 id="rmdir-删除空目录"><a class="headerlink" href="#rmdir-删除空目录"></a> rmdir 删除空目录</h3><h3 id="cd-切换目录"><a class="headerlink" href="#cd-切换目录"></a> cd 切换目录</h3><h3 id="touch-创建空文件"><a class="headerlink" href="#touch-创建空文件"></a> touch 创建空文件</h3><h3 id="cat-查看文件内容"><a class="headerlink" href="#cat-查看文件内容"></a> cat 查看文件内容</h3><p><code>cat [文件地址]</code></p><h3 id="cp-拷贝"><a class="headerlink" href="#cp-拷贝"></a> cp 拷贝</h3><p><code>cp [源文件地址] [目标地址]</code></p><p><img src="https://i.loli.net/2018/09/08/5b934b0bdc528.png" alt="cp.png"><span class="image-caption">cp.png</span></p><h3 id="mv-移动或重命名"><a class="headerlink" href="#mv-移动或重命名"></a> mv 移动或重命名</h3><ul><li><code>mv /usr/men/* .</code> 移动</li><li><code>mv ex3 new1</code> 重命名<br><img src="https://i.loli.net/2018/09/08/5b934c2ac4fb3.png" alt="mv.png"><span class="image-caption">mv.png</span></li></ul><h3 id="rm-删除文件"><a class="headerlink" href="#rm-删除文件"></a> rm 删除文件</h3><ul><li><code>-r</code> 递归删除，可删除子目录及文件</li><li><code>-f</code> 强制删除</li></ul><h3 id="find-在文件系统中搜索某文件"><a class="headerlink" href="#find-在文件系统中搜索某文件"></a> find 在文件系统中搜索某文件</h3><h3 id="grep-在文本文件中查找某个字符串"><a class="headerlink" href="#grep-在文本文件中查找某个字符串"></a> grep 在文本文件中查找某个字符串</h3><h3 id="tree-树形结构显示目录需要安装-tree-包"><a class="headerlink" href="#tree-树形结构显示目录需要安装-tree-包"></a> tree 树形结构显示目录（需要安装 tree 包）</h3><p><img src="https://i.loli.net/2018/09/08/5b934d6471b2c.png" alt="tree.png"><span class="image-caption">tree.png</span></p><h3 id="pwd-显示当前目录"><a class="headerlink" href="#pwd-显示当前目录"></a> pwd 显示当前目录</h3><h3 id="ln-创建链接文件快捷方式"><a class="headerlink" href="#ln-创建链接文件快捷方式"></a> ln 创建链接文件（快捷方式）</h3><p><code>ln /mub1/m2.c /usr/liu/a2.c</code></p><h2 id="系统管理命令"><a class="headerlink" href="#系统管理命令"></a> 系统管理命令</h2><h3 id="stat-显示指定文件的详细信息比-ls-更详细"><a class="headerlink" href="#stat-显示指定文件的详细信息比-ls-更详细"></a> stat 显示指定文件的详细信息，比 ls 更详细</h3><p><img src="https://i.loli.net/2018/09/08/5b935030c3f42.png" alt="stat.png"><span class="image-caption">stat.png</span></p><h3 id="who-显示在线登陆用户"><a class="headerlink" href="#who-显示在线登陆用户"></a> who 显示在线登陆用户</h3><h3 id="whoami-显示当前操作用户"><a class="headerlink" href="#whoami-显示当前操作用户"></a> whoami 显示当前操作用户</h3><h3 id="hostname-显示主机名"><a class="headerlink" href="#hostname-显示主机名"></a> hostname 显示主机名</h3><h3 id="uname-显示系统信息"><a class="headerlink" href="#uname-显示系统信息"></a> uname 显示系统信息</h3><h3 id="top-动态显示当前耗费资源最多进程信息"><a class="headerlink" href="#top-动态显示当前耗费资源最多进程信息"></a> top 动态显示当前耗费资源最多进程信息</h3><h3 id="ps-显示瞬间进程状态"><a class="headerlink" href="#ps-显示瞬间进程状态"></a> ps 显示瞬间进程状态</h3><p><img src="https://i.loli.net/2018/09/08/5b93514120b4d.png" alt="ps.png"><span class="image-caption">ps.png</span></p><h3 id="du-查看目录大小"><a class="headerlink" href="#du-查看目录大小"></a> du 查看目录大小</h3><ul><li>du -h /home 带有单位显示目录信息</li></ul><h3 id="df-查看磁盘大小"><a class="headerlink" href="#df-查看磁盘大小"></a> df 查看磁盘大小</h3><ul><li>df -h 带有单位显示磁盘信息</li></ul><h3 id="ifconfig-查看网络情况"><a class="headerlink" href="#ifconfig-查看网络情况"></a> ifconfig 查看网络情况</h3><h3 id="ping-测试网络连通"><a class="headerlink" href="#ping-测试网络连通"></a> ping 测试网络连通</h3><h3 id="netstat-显示网络状态信息"><a class="headerlink" href="#netstat-显示网络状态信息"></a> netstat 显示网络状态信息</h3><h3 id="man-命令不会用了找男人"><a class="headerlink" href="#man-命令不会用了找男人"></a> man 命令不会用了，找男人</h3><p>如：man ls</p><h3 id="clear-清屏"><a class="headerlink" href="#clear-清屏"></a> clear 清屏</h3><h3 id="aliasb-对命令重命名"><a class="headerlink" href="#aliasb-对命令重命名"></a> aliasb 对命令重命名</h3><p>如：alias showmeit=“ps -aux” ，另外解除使用 unaliax showmeit</p><h3 id="kill-杀死进程"><a class="headerlink" href="#kill-杀死进程"></a> kill 杀死进程</h3><p>可以先用 ps 或 top 命令查看进程的 id，然后再用 kill 命令杀死进程。</p><h2 id="关机重启机器"><a class="headerlink" href="#关机重启机器"></a> 关机/重启机器</h2><h3 id="shutdown"><a class="headerlink" href="#shutdown"></a> shutdown</h3><ul><li><code>-r</code> 关机重启</li><li><code>-h</code> 关机不重启</li><li><code>now</code> 立刻关机</li></ul><h3 id="halt-关机"><a class="headerlink" href="#halt-关机"></a> halt 关机</h3><h3 id="reboot-重启"><a class="headerlink" href="#reboot-重启"></a> reboot 重启</h3><h2 id="linux-管道"><a class="headerlink" href="#linux-管道"></a> Linux 管道</h2><p>将一个命令的标准输出作为另一个命令的标准输入。也就是把几个命令组合起来使用，后一个命令除以前一个命令的结果。<br>例：<code>grep -r &quot;close&quot; /home/\* | more</code> 在 home 目录下所有文件中查找，包括 close 的文件，并分页输出。</p><h2 id="文件权限管理"><a class="headerlink" href="#文件权限管理"></a> 文件权限管理</h2><h3 id="三种基本权限"><a class="headerlink" href="#三种基本权限"></a> 三种基本权限</h3><table><thead><tr><th style="text-align:left">标记</th><th style="text-align:left">含义</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">R</td><td style="text-align:left">读</td><td style="text-align:left">数值表示为 4</td></tr><tr><td style="text-align:left">W</td><td style="text-align:left">写</td><td style="text-align:left">数值表示为 2</td></tr><tr><td style="text-align:left">X</td><td style="text-align:left">可执行</td><td style="text-align:left">数值表示为 1</td></tr></tbody></table><p><img src="https://i.loli.net/2018/09/08/5b9352c332e7e.png" alt="三种基本权限.png"><span class="image-caption">三种基本权限.png</span></p><p>第一个字符<code>-</code>表示普通文件；这个位置还可能会出现<code>l</code>链接；<code>d</code>表示目录</p><p>第二三四个字符<code>rw-</code>表示 <strong>当前所属用户的权限</strong>。 所以用数值表示为4+2=6<br>第五六七个字符<code>rw-</code>表示 <strong>当前所属组的权限</strong>。 所以用数值表示为4+2=6<br>第八九十个字符<code>rw-</code>表示 <strong>其他用户权限</strong>。 所以用数值表示为4+2=6<br>所以操作此文件的权限用数值表示为666</p><h3 id="更改权限"><a class="headerlink" href="#更改权限"></a> 更改权限</h3><p>sudo chmod [u所属用户  g所属组  o其他用户  a所有用户]  [+增加权限  -减少权限]  [r  w  x]   目录名</p><p>例如：有一个文件filename，权限为“-rw-r----x” ,将权限值改为&quot;-rwxrw-r-x&quot;，用数值表示为765<br><code>sudo chmod u+x g+w o+r filename</code></p><p>上面的例子可以用数值表示<br><code>sudo chmod 765 filename</code></p>]]></content>
      
      
      <categories>
          
          <category> dev </category>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发[3]-线程池怎么玩</title>
      <link href="/2018/09/06/thread-pool/"/>
      <url>/2018/09/06/thread-pool/</url>
      
        <content type="html"><![CDATA[<h2 id="线程池的基本使用"><a class="headerlink" href="#线程池的基本使用"></a> 线程池的基本使用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.theembers.threadpool;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> TheEmbers</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * createTime 2018-09-06 9:45</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolDemo</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建一个线程池(完整入参):</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 核心线程数为5 (corePoolSize),</span></span><br><span class="line"><span class="comment">     * 最大线程数为10 (maximumPoolSize),</span></span><br><span class="line"><span class="comment">     * 存活时间为60分钟(keepAliveTime),</span></span><br><span class="line"><span class="comment">     * 工作队列为LinkedBlockingQueue (workQueue),</span></span><br><span class="line"><span class="comment">     * 线程工厂为默认的DefaultThreadFactory (threadFactory),</span></span><br><span class="line"><span class="comment">     * 饱和策略(拒绝策略)为AbortPolicy: 抛出异常(handler).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService THREAD_POOL = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>, <span class="number">10</span>, <span class="number">60</span>, TimeUnit.MINUTES,</span><br><span class="line">            <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(), Executors.defaultThreadFactory(),</span><br><span class="line">            <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 只有一个线程的线程池 没有超时时间, 工作队列使用无界的LinkedBlockingQueue</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor();</span><br><span class="line">    <span class="comment">// private static ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor(Executors.defaultThreadFactory());</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 有固定线程的线程池(即corePoolSize = maximumPoolSize) 没有超时时间,</span></span><br><span class="line"><span class="comment">     * 工作队列使用无界的LinkedBlockingQueue</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService fixedThreadPool = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">    <span class="comment">// private static ExecutorService fixedThreadPool = Executors.newFixedThreadPool(5, Executors.defaultThreadFactory());</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 大小不限的线程池 核心线程数为0, 最大线程数为Integer.MAX_VALUE, 存活时间为60秒 该线程池可以无限扩展,</span></span><br><span class="line"><span class="comment">     * 并且当需求降低时会自动收缩, 工作队列使用同步移交SynchronousQueue.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService cachedThreadPool = Executors.newCachedThreadPool();</span><br><span class="line">    <span class="comment">// private static ExecutorService cachedThreadPool = Executors.newCachedThreadPool(Executors.defaultThreadFactory());</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 给定的延迟之后运行任务, 或者定期执行任务的线程池</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(<span class="number">5</span>);</span><br><span class="line">    <span class="comment">// private static ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(5, Executors.defaultThreadFactory());</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 例子1: 没有返回结果的异步任务</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        THREAD_POOL.submit(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// do something</span></span><br><span class="line">            System.out.println(<span class="string">"没有返回结果的异步任务"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 例子2: 有返回结果的异步任务</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Future&lt;List&lt;String&gt;&gt; future = THREAD_POOL.submit(() -&gt; &#123;</span><br><span class="line">            List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            result.add(<span class="string">"TheEmbers"</span>);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;);</span><br><span class="line">        List&lt;String&gt; result = future.get(); <span class="comment">// 获取返回结果</span></span><br><span class="line">        System.out.println(<span class="string">"有返回结果的异步任务: "</span> + result);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 例子3:</span></span><br><span class="line"><span class="comment">         * 有延迟的, 周期性执行异步任务</span></span><br><span class="line"><span class="comment">         * 本例子为: 延迟1秒, 每2秒执行1次</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        scheduledThreadPool.scheduleAtFixedRate(() -&gt; System.out.println(<span class="string">"this is "</span> + Thread.currentThread().getName()), <span class="number">1</span>, <span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 例子4: FutureTask的使用</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Callable&lt;String&gt; task = () -&gt; <span class="string">"TheEmbers"</span>;</span><br><span class="line">        FutureTask&lt;String&gt; futureTo = <span class="keyword">new</span> FutureTask&lt;&gt;(task);</span><br><span class="line">        THREAD_POOL.submit(futureTo);</span><br><span class="line">        System.out.println(futureTo.get()); <span class="comment">// 获取返回结果</span></span><br><span class="line"><span class="comment">//        System.out.println(futureTo.get(3, TimeUnit.SECONDS));  // 超时时间为3秒</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程池的定义和优点"><a class="headerlink" href="#线程池的定义和优点"></a> 线程池的定义和优点</h2><p>线程池是与工作队列密切相关的，其中在工作队列中保存了所有等待执行的任务。工作线程的任务很简单：从工作队列中获取一个任务，执行任务，然后返回线程池并等待下一个任务。</p><p><strong>在线程池中执行任务</strong> 比 <strong>为每个线程分配一个任务</strong> 优势更多。通过重用现有的线程而不是创建线程，可以在处理多个请求时分摊在线程创建和销毁过程中产生的巨大开销。另一个额外的好处是，当请求到达时，工作线程通常已经存在，因此不会由于等待创建线程而延迟任务的执行，从而提高了响应性。通过适当的调整线程池的大小，可以创建足够的线程以便使处理器保持忙碌状态，同时还可以防止过多线程相互竞争资源而使应用程序耗尽内存或失败。</p><blockquote><p>核心思想：线程的创建和销毁需要很大的开销，线程池用来维护并管理线程以减少开销。</p></blockquote><h2 id="线程池的工作流程"><a class="headerlink" href="#线程池的工作流程"></a> 线程池的工作流程</h2><ol><li>默认情况下，创建完线程池后并不会立即创建线程, 而是等到有任务提交时才会创建线程来进行处理。（除非调用 prestartCoreThread 或 prestartAllCoreThreads 方法）</li><li>当线程数小于核心线程数时，每提交一个任务就创建一个线程来执行，即使当前有线程处于空闲状态，直到当前线程数达到核心线程数。</li><li>当前线程数达到核心线程数时，如果这个时候还提交任务，这些任务会被放到队列里，等到线程处理完了手头的任务后，会来队列中取任务处理。</li><li>当前线程数达到核心线程数并且队列也满了，如果这个时候还提交任务，则会继续创建线程来处理，直到线程数达到最大线程数。</li><li>当前线程数达到最大线程数并且队列也满了，如果这个时候还提交任务，则会触发饱和策略。</li><li>如果某个线程的控线时间超过了 keepAliveTime，那么将被标记为可回收的，并且当前线程池的当前大小超过了核心线程数时，这个线程将被终止。</li></ol><p><img src="https://i.loli.net/2018/09/06/5b90b431ce0bf.png" alt="线程池工作流程.png"><span class="image-caption">线程池工作流程.png</span></p><h2 id="工作队列阻塞队列"><a class="headerlink" href="#工作队列阻塞队列"></a> 工作队列（阻塞队列）</h2><p>如果新请求的到达速率超过了线程池的处理速率，那么新到来的请求将累积起来。在线程池中，这些请求会在一个由 Executor 管理的 Runnable 队列中等待，而不会像线程那样去竞争 CPU 资源。常见的工作队列有以下几种，前三种用的最多。</p><ul><li>ArrayBlockingQueue：列表形式的工作队列，必须要有初始队列大小，有界队列，先进先出。</li><li>LinkedBlockingQueue：链表形式的工作队列，可以选择设置初始队列大小，有界/无界队列，先进先出。</li><li>SynchronousQueue：SynchronousQueue 不是一个真正的队列，而是一种在线程之间移交的机制。要将一个元素放入 SynchronousQueue 中, 必须有另一个线程正在等待接受这个元素. 如果没有线程等待，并且线程池的当前大小小于最大值，那么 ThreadPoolExecutor 将创建 一个线程, 否则根据饱和策略，这个任务将被拒绝。使用直接移交将更高效，因为任务会直接移交 给执行它的线程，而不是被首先放在队列中, 然后由工作线程从队列中提取任务. 只有当线程池是无解的或者可以拒绝任务时，SynchronousQueue 才有实际价值。<blockquote><p>说白了就是个 0 容量的队列，核心线程饱和后直接将任务移交给拓展线程。</p></blockquote></li><li>PriorityBlockingQueue：优先级队列，有界队列，根据优先级来安排任务，任务的优先级是通过自然顺序或 Comparator（如果任务实现了 Comparator）来定义的。</li><li>DelayedWorkQueue：延迟的工作队列，无界队列。</li></ul><h2 id="饱和策略拒绝策略"><a class="headerlink" href="#饱和策略拒绝策略"></a> 饱和策略（拒绝策略）</h2><p>当有界队列被填满后，饱和策略开始发挥作用。ThreadPoolExecutor 的饱和策略可以通过调用 setRejectedExecutionHandler 来修改。（如果某个任务被提交到一个已被关闭的 Executor 时，也会用到饱和策略）。饱和策略有以下四种，一般使用默认的 AbortPolicy。</p><ul><li>AbortPolicy：中止策略。默认的饱和策略，抛出未检查的 RejectedExecutionException。调用者可以捕获这个异常，然后根据需求编写自己的处理代码。</li><li>DiscardPolicy：抛弃策略。当新提交的任务无法保存到队列中等待执行时，该策略会悄悄抛弃该任务。</li><li>DiscardOldestPolicy：抛弃最旧的策略。当新提交的任务无法保存到队列中等待执行时，则会抛弃下一个将被执行的任务，然后尝试重新提交新的任务。（<strong>如果工作队列是一个优先队列，那么“抛弃最旧的”策略将导致抛弃优先级最高的任务，因此最好不要将“抛弃最旧的”策略和优先级队列放在一起使用</strong>）。</li><li>CallerRunsPolicy：调用者运行策略。该策略实现了一种调节机制，该策略既不会抛弃任务，也不会抛出异常，而是将某些任务回退到调用者（调用线程池执行任务的主线程），从而降低新任务的流程。它不会在线程池的某个线程中执行新提交的任务，而是在一个调用了 execute 的线程中执行该任务。当线程池的所有线程都被占用，并且工作队列被填满后，下一个任务会在调用 execute 时在主线程中执行（调用线程池执行任务的主线程）。由于执行任务需要一定时间，因此主线程至少在一段时间内不能提交任务，从而使得工作者线程有时间来处理完正在执行的任务。在这期间，主线程不会调用 accept，因此到达的请求将被保存在 TCP 层的队列中。如果持续过载，那么 TCP 层将最终发现它的请求队列被填满，因此同样会开始抛弃请求。当服务器过载后，这种过载情况会逐渐向外蔓延开来——从线程池到工作队列到应用程序再到 TCP 层，最终达到客户端，导致服务器在高负载下实现一种平缓的性能降低。</li></ul><h2 id="线程工厂"><a class="headerlink" href="#线程工厂"></a> 线程工厂</h2><p>每当线程池需要创建一个线程时，都是通过线程工厂方法来完成的。在 ThreadFactory 中只定义了一个方法 newThread，每当线程池需要创建一个新线程时都会调用这个方法。Executors 提供的线程工厂有两种，一般使用默认的，当然如果有特殊需求，也可以自己定制。</p><ul><li>DefaultThreadFactory：默认线程工厂，创建一个新的、非守护的线程，并且不包含特殊的配置信息。</li><li>PrivilegedThreadFactory：通过这种方式创建出来的线程，将与创建 privilegedThreadFactory 的线程拥有相同的访问权限、 AccessControlContext、ContextClassLoader。如果不使用 privilegedThreadFactory， 线程池创建的线程将从在需要新线程时调用 execute 或 submit 的客户程序中继承访问权限。</li><li>自定义线程工厂：可以自己实现 ThreadFactory 接口来定制自己的线程工厂方法。</li></ul>]]></content>
      
      
      <categories>
          
          <category> dev </category>
          
          <category> java </category>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 并发 </tag>
            
            <tag> 多线程 </tag>
            
            <tag> 线程池 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发[2]-ThreadLocal</title>
      <link href="/2018/09/05/thread-2/"/>
      <url>/2018/09/05/thread-2/</url>
      
        <content type="html"><![CDATA[<h2 id="说明"><a class="headerlink" href="#说明"></a> 说明</h2><p>ThreadLocal 的作用是提供线程内的局部变量，这种变量在多线程环境下访问时能够保证各个线程里变量的独立性。</p><h2 id="基本使用"><a class="headerlink" href="#基本使用"></a> 基本使用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ThreadLocal&lt;Integer&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ThreadLocal&lt;User&gt; threadLocalUser = <span class="keyword">new</span> ThreadLocal&lt;User&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">threadLocal.set(<span class="number">100</span>);<span class="comment">// 保存值</span></span><br><span class="line">System.out.println(threadLocal.get());<span class="comment">// 获取值</span></span><br><span class="line"></span><br><span class="line">User user = <span class="keyword">new</span> User();</span><br><span class="line">user.setName(<span class="string">"Tom"</span>);</span><br><span class="line">user.setAge(<span class="number">25</span>);</span><br><span class="line">threadLocalUser.set(user);<span class="comment">// 保存值</span></span><br><span class="line">System.out.println(threadLocalUser.get());<span class="comment">// 获取值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">String name;</span><br><span class="line">Integer age;</span><br><span class="line"></span><br><span class="line"><span class="comment">// geter&amp;seter..</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"User [name="</span> + name + <span class="string">", age="</span> + age + <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="comment">// 100</span></span><br><span class="line"><span class="comment">// User [name=Tom, age=25]</span></span><br></pre></td></tr></table></figure><h2 id="源码解析"><a class="headerlink" href="#源码解析"></a> 源码解析</h2><h3 id="threadlocal-的定义"><a class="headerlink" href="#threadlocal-的定义"></a> ThreadLocal 的定义</h3><p>ThreadLocal 提供了线程局部变量。能使线程中的某个值与保存值的对象关联起来。ThreadLocal 提供了 get 与 set 等访问接口或方法，这些方法为每个使用该变量的线程都存有一份独立的副本（即每个线程的 threadLocals 属性），因此 get 总是返回由当前执行线程在调用 set 时设置的最新值。</p><p>只要线程处于活动状态并且 Threadocal 实例可以访问，每个线程就拥有对其线程局部变量副本的隐式引用；在一个线程消失之后，线程本地实例的所有副本都会被垃圾收集（除非存在对这些副本的其他引用）。</p><p>ThreadLocal 的 hashcode（threadLocalHashCode）是从 0 开始，每新建一个 ThreadLocal，对应的 hashcode 就加 0x61c88647。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> threadLocalHashCode = nextHashCode();</span><br><span class="line"></span><br><span class="line"><span class="comment">// AtomicInteger类型，从0开始</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger nextHashCode =</span><br><span class="line">    <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line"><span class="comment">// hash code每次增加1640531527</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_INCREMENT = <span class="number">0x61c88647</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下一个hash code</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextHashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);</span><br></pre></td></tr></table></figure><h3 id="threadlocalmap-的定义"><a class="headerlink" href="#threadlocalmap-的定义"></a> ThreadLocalMap 的定义</h3><p>ThreadLocalMap 是一个自定义哈希映射，仅用于维护线程本地变量值。ThreadLocalMap 是 ThreadLocal 的内部类，主要有一个 Entry 数组，Entry 的 key 为 ThreadLocal，value 为 ThreadLocal 对应的值。每个线程都有一个 ThreadLocalMap 类型的 threadLocals 变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">    Object value;</span><br><span class="line"></span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">        <span class="keyword">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="set方法"><a class="headerlink" href="#set方法"></a> set()方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t); <span class="comment">// 获取当前线程的ThreadLocalMap</span></span><br><span class="line">    <span class="comment">// 当前线程的ThreadLocalMap不为空则调用set方法, this为调用该方法的ThreadLocal对象</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value); <span class="comment">// --&gt; 代码块 1</span></span><br><span class="line">    <span class="comment">// map为空则调用createMap方法创建一个新的ThreadLocalMap, 并新建一个Entry放入该</span></span><br><span class="line">    <span class="comment">// ThreadLocalMap, 调用set方法的ThreadLocal和传入的value作为该Entry的key和value</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;<span class="comment">// 返回线程t的threadLocals属性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>先拿到当前线程，再使用 getMap 方法拿到当前线程的 threadLocals 变量</li><li>如果 threadLocals 不为空，则将当前 ThreadLocal 作为 key，传入的值作为 value，调用 set 方法（见下文代码块 1 详解）插入 threadLocals。</li><li>如果 threadLocals 为空则调用创建一个 ThreadLocalMap，并新建一个 Entry 放入该 ThreadLocalMap, 调用 set 方法的 ThreadLocal 和传入的 value 作为该 Entry 的 key 和 value</li></ol><blockquote><p>注意此处的 threadLocals 变量是一个 ThreadLocalMap，是 Thread 的一个局部变量，因此它只与当前线程绑定。</p></blockquote><h4 id="代码块-1set-方法"><a class="headerlink" href="#代码块-1set-方法"></a> 代码块 1：set 方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);  <span class="comment">// 计算出索引的位置</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从索引位置开始遍历,由于不是链表结构,因此通过nextIndex方法来寻找下一个索引位置</span></span><br><span class="line">    <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">        e != <span class="keyword">null</span>;<span class="comment">// 当遍历到的Entry为空时结束遍历</span></span><br><span class="line">        e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get(); <span class="comment">// 拿到Entry的key，也就是ThreadLocal</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 该Entry的key和传入的key相等, 则用传入的value替换掉原来的value</span></span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 该Entry的key为空, 则代表该Entry需要被清空,</span></span><br><span class="line">        <span class="comment">// 调用replaceStaleEntry方法</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 该方法会继续寻找传入key的安放位置, 并清理掉key为空的Entry</span></span><br><span class="line">            replaceStaleEntry(key, value, i); <span class="comment">// --&gt; 代码块 2</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 寻找到一个空位置,　则放置在该位置上</span></span><br><span class="line">    tab[i] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">    <span class="keyword">int</span> sz = ++size;</span><br><span class="line">    <span class="comment">// cleanSomeSlots是用来清理掉key为空的Entry,如果此方法返回true,则代表至少清理</span></span><br><span class="line">    <span class="comment">// 了1个元素, 则此次set必然不需要扩容, 如果此方法返回false则判断sz是否大于阈值</span></span><br><span class="line">    <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">        rehash();   <span class="comment">// 扩容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>通过传入的 key 的 hashCode 计算出索引的位置</li><li>从索引位置开始遍历，由于不是链表结构，因此通过 nextIndex 方法来寻找下一个索引位置</li><li>如果找到某个 Entry 的 key 和传入的 key 相同，则用传入的 value 替换掉该 Entry 的 value。</li><li>如果遍历到某个 Entry 的 key 为空，则调用 replaceStaleEntry 方法（见下文代码块 2 详解）</li><li>如果通过 nextIndex 寻找到一个空位置（代表没有找到 key 相同的），则将元素放在该位置上</li><li>调用 cleanSomeSlots 方法清理 key 为 null 的 Entry，并判断是否需要扩容，如果需要则调用 rehash 方法进行扩容（见下文 rehash 方法详解）。</li></ol><h4 id="代码块-2replacestaleentry-方法"><a class="headerlink" href="#代码块-2replacestaleentry-方法"></a> 代码块 2：replaceStaleEntry 方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">replaceStaleEntry</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value,<span class="keyword">int</span> staleSlot)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    Entry e;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> slotToExpunge = staleSlot;<span class="comment">// 清除元素的开始位置（记录索引位置最前面的）</span></span><br><span class="line">    <span class="comment">// 向前遍历，直到遇到Entry为空</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = prevIndex(staleSlot, len);</span><br><span class="line">        (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">        i = prevIndex(i, len))</span><br><span class="line">        <span class="keyword">if</span> (e.get() == <span class="keyword">null</span>)</span><br><span class="line">            slotToExpunge = i;<span class="comment">// 记录最后一个key为null的索引位置</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find either the key or trailing null slot of run, whichever</span></span><br><span class="line">    <span class="comment">// occurs first</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nextIndex(staleSlot, len); <span class="comment">// 向后遍历，直到遇到Entry为空</span></span><br><span class="line">        (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">        i = nextIndex(i, len)) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 该Entry的key和传入的key相等, 则将传入的value替换掉该Entry的value</span></span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将i位置和staleSlot位置的元素对换（staleSlot位置较前，是要清除的元素）</span></span><br><span class="line">            tab[i] = tab[staleSlot];</span><br><span class="line">            tab[staleSlot] = e;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果相等, 则代表上面的向前寻找key为null的遍历没有找到，</span></span><br><span class="line">            <span class="comment">// 即staleSlot位置前面的元素没有需要清除的，此时将slotToExpunge设置为i,</span></span><br><span class="line">            <span class="comment">// 因为原staleSlot的元素已经被放到i位置了，这时位置i前面的元素都不需要清除</span></span><br><span class="line">            <span class="keyword">if</span> (slotToExpunge == staleSlot)</span><br><span class="line">                slotToExpunge = i;</span><br><span class="line">            <span class="comment">// 从slotToExpunge位置开始清除key为空的Entry</span></span><br><span class="line">            cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果第一次遍历到key为null的元素，并且上面的向前寻找key为null的遍历没有找到，</span></span><br><span class="line">        <span class="comment">// 则将slotToExpunge设置为当前的位置</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span> &amp;&amp; slotToExpunge == staleSlot)</span><br><span class="line">            slotToExpunge = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果key没有找到，则新建一个Entry，放在staleSlot位置</span></span><br><span class="line">    tab[staleSlot].value = <span class="keyword">null</span>;</span><br><span class="line">    tab[staleSlot] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果slotToExpunge!=staleSlot，代表除了staleSlot位置还有其他位置的元素需要清除</span></span><br><span class="line">    <span class="comment">// 需要清除的定义：key为null的Entry，调用cleanSomeSlots方法清除key为null的Entry</span></span><br><span class="line">    <span class="keyword">if</span> (slotToExpunge != staleSlot)</span><br><span class="line">        cleanSomeSlots(expungeStaleEntry(slotToExpunge), len); <span class="comment">// --&gt; 代码块 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>slotToExpunge 始终记录着需要清除的元素的最前面的位置（即 slotToExpunge 前面的元素是不需要清除的）</li><li>从位置 staleSlot 向前遍历，直到遇到 Entry 为空，用 staleSlot 记录最后一个 key 为 null 的索引位置（也就是遍历过位置最前的 key 为 null 的位置）</li><li>从位置 staleSlot 向后遍历，直到遇到 Entry 为空，如果遍历到 key 和入参 key 相同的，则将入参的 value 替换掉该 Entry 的 value，并将 i 位置和 staleSlot 位置的元素对换（staleSlot 位置较前，是要清除的元素），遍历的时候判断 slotToExpunge 的值是否需要调整，最后调用 expungeStaleEntry 方法（见下文 expungeStaleEntry 方法详解）和 cleanSomeSlots 方法（见下文代码块 3 详解）清除 key 为 null 的元素。</li><li>如果 key 没有找到，则使用入参的 key 和 value 新建一个 Entry，放在 staleSlot 位置</li><li>判断是否还有其他位置的元素 key 为 null，如果有则调用 expungeStaleEntry 方法和 cleanSomeSlots 方法清除 key 为 null 的元素</li></ol><h4 id="代码块-3cleansomeslots-方法"><a class="headerlink" href="#代码块-3cleansomeslots-方法"></a> 代码块 3：cleanSomeSlots 方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">cleanSomeSlots</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> removed = <span class="keyword">false</span>;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        i = nextIndex(i, len);<span class="comment">// 下一个索引位置</span></span><br><span class="line">        Entry e = tab[i];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == <span class="keyword">null</span>) &#123;<span class="comment">// 遍历到key为null的元素</span></span><br><span class="line">            n = len;<span class="comment">// 重置n的值</span></span><br><span class="line">            removed = <span class="keyword">true</span>;<span class="comment">// 标志有移除元素</span></span><br><span class="line">            i = expungeStaleEntry(i);<span class="comment">// 移除i位置及之后的key为null的元素</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> ( (n &gt;&gt;&gt;= <span class="number">1</span>) != <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> removed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从 i 开始，清除 key 为空的 Entry，遍历次数由当前的 table 长度决定，当遍历到一个 key 为 null 的元素时，调用 expungeStaleEntry 清除，并将遍历次数重置。至于为什么使用 table 长度来决定遍历次数，官方给出的解释是这个方法简单、快速，并且效果不错。</p><h3 id="get方法"><a class="headerlink" href="#get方法"></a> get()方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">//调用getEntry方法, 通过调用get()方法的ThreadLocal获取对应的Entry</span></span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>); <span class="comment">// --&gt; 代码块 5</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;    <span class="comment">//Entry不为空则代表找到目标Entry, 返回该Entry的value值</span></span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();   <span class="comment">//该线程的ThreadLocalMap为空则初始化一个 --&gt; 代码块 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>跟 set 方法差不多，先拿到当前的线程，再使用 getMap 方法拿到当前线程的 threadLocals 变量</li><li>如果 threadLocals 不为空，则将调用 get 方法的 ThreadLocal 作为 key，调用 getEntry 方法（见下文代码块 5 详解）找到对应的 Entry。</li><li>如果 threadLocals 为空或者找不到目标 Entry，则调用 setInitialValue 方法（见下文代码块 4 详解）进行初始化。</li></ol><h4 id="代码块-4setinitialvalue-方法"><a class="headerlink" href="#代码块-4setinitialvalue-方法"></a> 代码块 4：setInitialValue 方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    T value = initialValue();<span class="comment">// 默认null，需要用户自己重写该方法，</span></span><br><span class="line">    Thread t = Thread.currentThread();<span class="comment">// 当前线程</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);<span class="comment">// 拿到当前线程的threadLocals</span></span><br><span class="line">    <span class="comment">// threadLocals不为空则将当前的ThreadLocal作为key，null作为value，插入到ThreadLocalMap</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="comment">// threadLocals为空则调用创建一个ThreadLocalMap，并新建一个Entry放入该ThreadLocalMap,</span></span><br><span class="line">    <span class="comment">// 调用set方法的ThreadLocal和value作为该Entry的key和value</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>如果是 threadLocals 为空，创建一个新的 ThreadLocalMap，并将当前的 ThreadLocal 作为 key，null 作为 value，插入到新创建的 ThreadLocalMap，并返回 null。</li><li>如果 threadLocals 不为空，则将当前的 ThreadLocal 作为 key，null 作为 value，插入到 threadLocals。</li><li>注意上面的 initialValue()方法为 protected，如果希望线程局部变量具有非 null 的初始值，则必须对 ThreadLocal 进行子类化，并重写此方法。</li></ol><h4 id="代码块-5getentry-方法"><a class="headerlink" href="#代码块-5getentry-方法"></a> 代码块 5：getEntry 方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line"><span class="comment">//根据hash code计算出索引位置</span></span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">    Entry e = table[i];</span><br><span class="line">    <span class="comment">// 如果该Entry的key和传入的key相等, 则为目标Entry, 直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == key)</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    <span class="comment">// 否则，e不是目标Entry, 则从e之后继续寻找目标Entry</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> getEntryAfterMiss(key, i, e); <span class="comment">// --&gt; 代码块 6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>根据 hash code 计算出索引位置</li><li>如果该索引位置 Entry 的 key 和传入的 key 相等，则为目标 Entry，直接返回</li><li>否则，e 不是目标 Entry，调用 getEntryAfterMiss 方法（见下文代码块 6 详解）继续遍历。</li></ol><h4 id="代码块-6getentryaftermiss-方法"><a class="headerlink" href="#代码块-6getentryaftermiss-方法"></a> 代码块 6：getEntryAfterMiss 方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntryAfterMiss</span><span class="params">(ThreadLocal&lt;?&gt; key, <span class="keyword">int</span> i, Entry e)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="comment">// 找到目标Entry，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (k == key)</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        <span class="comment">// 调用expungeStaleEntry清除key为null的元素</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>)</span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            i = nextIndex(i, len);  <span class="comment">// 下一个索引位置</span></span><br><span class="line">        e = tab[i]; <span class="comment">// 下一个遍历的Entry</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;    <span class="comment">// 找不到, 返回空</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从元素 e 开始向后遍历，如果找到目标 Entry 元素直接返回；如果遇到 key 为 null 的元素，调用 expungeStaleEntry 方法（见下文 expungeStaleEntry 方法详解）进行清除；否则，遍历到 Entry 为 nu</p><h3 id="remove方法"><a class="headerlink" href="#remove方法"></a> remove()方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 获取当前线程的ThreadLocalMap</span></span><br><span class="line">ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class="line"><span class="keyword">if</span> (m != <span class="keyword">null</span>)</span><br><span class="line">m.remove(<span class="keyword">this</span>);    <span class="comment">// 调用此方法的ThreadLocal作为入参，调用remove方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="comment">// 根据hashCode计算出当前ThreadLocal的索引位置</span></span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 从位置i开始遍历，直到Entry为null</span></span><br><span class="line">    <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">        e != <span class="keyword">null</span>;</span><br><span class="line">        e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.get() == key) &#123;   <span class="comment">// 如果找到key相同的</span></span><br><span class="line">            e.clear(); <span class="comment">// 则调用clear方法, 该方法会把key的引用清空</span></span><br><span class="line">            expungeStaleEntry(i);<span class="comment">//调用expungeStaleEntry方法清除key为null的Entry</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法很简单，拿到当前线程的 threadLocals 属性，如果不为空，则将 key 为当前 ThreadLocal 的键值对移除，并且会调用 expungeStaleEntry 方法清除 key 为空的 Entry。</p><h3 id="expungestaleentry-方法"><a class="headerlink" href="#expungestaleentry-方法"></a> expungeStaleEntry 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从staleSlot开始, 清除key为空的Entry, 并将不为空的元素放到合适的位置，最后返回Entry为空的位置</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">expungeStaleEntry</span><span class="params">(<span class="keyword">int</span> staleSlot)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// expunge entry at staleSlot</span></span><br><span class="line">    tab[staleSlot].value = <span class="keyword">null</span>;    <span class="comment">// 将tab上staleSlot位置的对象清空</span></span><br><span class="line">    tab[staleSlot] = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Rehash until we encounter null</span></span><br><span class="line">    Entry e;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = nextIndex(staleSlot, len); <span class="comment">// 遍历下一个元素, 即(i+1)%len位置的元素</span></span><br><span class="line">        (e = tab[i]) != <span class="keyword">null</span>;<span class="comment">// 遍历到Entry为空时, 跳出循环并返回索引位置</span></span><br><span class="line">        i = nextIndex(i, len)) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;    <span class="comment">// 当前遍历Entry的key为空, 则将该位置的对象清空</span></span><br><span class="line">            e.value = <span class="keyword">null</span>;</span><br><span class="line">            tab[i] = <span class="keyword">null</span>;</span><br><span class="line">            size--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;    <span class="comment">// 当前遍历Entry的key不为空</span></span><br><span class="line">            <span class="keyword">int</span> h = k.threadLocalHashCode &amp; (len - <span class="number">1</span>);  <span class="comment">// 重新计算该Entry的索引位置</span></span><br><span class="line">            <span class="keyword">if</span> (h != i) &#123;   <span class="comment">// 如果索引位置不为当前索引位置i</span></span><br><span class="line">                tab[i] = <span class="keyword">null</span>;  <span class="comment">// 则将i位置对象清空, 替当前Entry寻找正确的位置</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果h位置不为null，则向后寻找当前Entry的位置</span></span><br><span class="line">                <span class="keyword">while</span> (tab[h] != <span class="keyword">null</span>)</span><br><span class="line">                    h = nextIndex(h, len);</span><br><span class="line">                tab[h] = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从 staleSlot 开始，清除 key 为 null 的 Entry，并将不为空的元素放到合适的位置，最后遍历到 Entry 为空的元素时，跳出循环返回当前索引位置。</p><p>set、get、remove 方法，在遍历的时候如果遇到 key 为 null 的情况，都会调用 expungeStaleEntry 方法来清除 key 为 null 的 Entry。</p><h3 id="rehash-方法"><a class="headerlink" href="#rehash-方法"></a> rehash 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    expungeStaleEntries();  <span class="comment">// 调用expungeStaleEntries方法清理key为空的Entry</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果清理后size超过阈值的3/4, 则进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> (size &gt;= threshold - threshold / <span class="number">4</span>)</span><br><span class="line">        resize();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Double the capacity of the table.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Entry[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldLen = oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> newLen = oldLen * <span class="number">2</span>;<span class="comment">// 新表长度为老表2倍</span></span><br><span class="line">    Entry[] newTab = <span class="keyword">new</span> Entry[newLen];<span class="comment">// 创建新表</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldLen; ++j) &#123;<span class="comment">// 遍历所有元素</span></span><br><span class="line">        Entry e = oldTab[j];<span class="comment">// 拿到对应位置的Entry</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">            <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;<span class="comment">// 如果key为null，将value清空</span></span><br><span class="line">                e.value = <span class="keyword">null</span>; <span class="comment">// Help the GC</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 通过hash code计算新表的索引位置</span></span><br><span class="line">                <span class="keyword">int</span> h = k.threadLocalHashCode &amp; (newLen - <span class="number">1</span>);</span><br><span class="line">                <span class="comment">// 如果新表的该位置已经有元素，则调用nextIndex方法直到寻找到空位置</span></span><br><span class="line">                <span class="keyword">while</span> (newTab[h] != <span class="keyword">null</span>)</span><br><span class="line">                    h = nextIndex(h, newLen);</span><br><span class="line">                newTab[h] = e;<span class="comment">// 将元素放在对应位置</span></span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setThreshold(newLen);<span class="comment">// 设置新表扩容的阈值</span></span><br><span class="line">    size = count;<span class="comment">// 更新size</span></span><br><span class="line">    table = newTab;<span class="comment">// table指向新表</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>调用 expungeStaleEntries 方法（该方法和 expungeStaleEntry 类似，只是把搜索范围扩大到整个表）清理 key 为空的 Entry</li><li>如果清理后 size 超过阈值的 3/4，则进行扩容。</li><li>新表长度为老表 2 倍，创建新表。</li><li>遍历老表所有元素，如果 key 为 null，将 value 清空；否则通过 hash code 计算新表的索引位置 h，如果 h 已经有元素，则调用 nextIndex 方法直到寻找到空位置，将元素放在新表的对应位置。</li><li>设置新表扩容的阈值、更新 size、table 指向新表。</li></ol><h2 id="内存泄漏问题"><a class="headerlink" href="#内存泄漏问题"></a> 内存泄漏问题</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">    Object value;</span><br><span class="line"></span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">        <span class="keyword">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面源码可以看出，ThreadLocalMap 使用 ThreadLocal 的弱引用作为 Entry 的 key，如果一个 ThreadLocal 没有外部强引用来引用它，下一次系统 GC 时，这个 ThreadLocal 必然会被回收，这样一来，ThreadLocalMap 中就会出现 key 为 null 的 Entry，就没有办法访问这些 key 为 null 的 Entry 的 value。</p><p>我们上面介绍的 get、set、remove 等方法中，都会对 key 为 null 的 Entry 进行清除（expungeStaleEntry 方法，将 Entry 的 value 清空，等下一次垃圾回收时，这些 Entry 将会被彻底回收）。</p><p>但是如果当前线程一直在运行，并且一直不执行 get、set、remove 方法，这些 key 为 null 的 Entry 的 value 就会一直存在一条强引用链：Thread Ref -&gt; Thread -&gt; ThreadLocalMap -&gt; Entry -&gt; value，导致这些 key 为 null 的 Entry 的 value 永远无法回收，造成内存泄漏。</p><h3 id="如何避免内存泄漏"><a class="headerlink" href="#如何避免内存泄漏"></a> 如何避免内存泄漏</h3><p>为了避免这种情况，我们可以在使用完 ThreadLocal 后，手动调用 remove 方法，以避免出现内存泄漏。</p>]]></content>
      
      
      <categories>
          
          <category> dev </category>
          
          <category> java </category>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 并发 </tag>
            
            <tag> 多线程 </tag>
            
            <tag> ThreadLocal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>markdown-syntax[markdown句法说明]</title>
      <link href="/2018/09/05/markdown-syntax/"/>
      <url>/2018/09/05/markdown-syntax/</url>
      
        <content type="html"><![CDATA[<h1 id="markdown-文件"><a class="headerlink" href="#markdown-文件"></a> Markdown 文件</h1><p><img src="https://i.loli.net/2018/09/07/5b91d5181af40.png" alt="Markdown"><span class="image-caption">Markdown</span></p><p><strong>NOTE:</strong> 本文是简体中文意译,英文原文见 <a href="http://daringfireball.net/projects/markdown/syntax" target="_blank" rel="noopener">Markdown: Syntax</a>.</p><p><strong>注意：</strong> 这份文件是用 Markdown 写的，你可以<a href="https://github.com/osokay/markdown-syntax-zh/edit/master/syntax_zh.md" target="_blank" rel="noopener">看看它的原始档</a> 。</p><hr><h2 id="概述"><a class="headerlink" href="#概述"></a> 概述</h2><h3 id="宗旨"><a class="headerlink" href="#宗旨"></a> 宗旨</h3><p>Markdown 的目标是实现「易读易写」。</p><p>可读性，无论如何，都是最重要的。一份使用 Markdown 格式撰写的文件应该可以直接以纯文本发布，并且看起来不会像是由许多标签或是格式指令所构成。Markdown 语法受到一些既有 text-to-HTML 格式的影响，包括 <a href="http://docutils.sourceforge.net/mirror/setext.html" target="_blank" rel="noopener">Setext</a>、<a href="http://www.aaronsw.com/2002/atx/" target="_blank" rel="noopener">atx</a>、<a href="http://textism.com/tools/textile/" target="_blank" rel="noopener">Textile</a>、<a href="http://docutils.sourceforge.net/rst.html" target="_blank" rel="noopener">reStructuredText</a>、<a href="http://www.triptico.com/software/grutatxt.html" target="_blank" rel="noopener">Grutatext</a> 和 <a href="http://ettext.taint.org/doc/" target="_blank" rel="noopener">EtText</a>，而最大灵感来源其实是纯文本电子邮件的格式。</p><p>总之， Markdown 的语法全由一些符号所组成，这些符号经过精挑细选，其作用一目了然。比如：在文字两旁加上星号，看起来就像<em>强调</em>。Markdown 的列表看起来，嗯，就是列表。Markdown 的区块引用看起来就真的像是引用一段文字，就像你曾在电子邮件中见过的那样。</p><h3 id="兼容-html"><a class="headerlink" href="#兼容-html"></a> 兼容 HTML</h3><p>Markdown 的格式语法只涵盖纯文本可以涵盖的范围，不在 Markdown 涵盖范围之内的标签，都可以直接在文件里面用 HTML 撰写。不需要额外标注这是 HTML 或是 Markdown；只要直接加标签就可以了。</p><p>只有区块元素 ── 比如 <code>&lt;div&gt;</code>、<code>&lt;table&gt;</code>、<code>&lt;pre&gt;</code>、<code>&lt;p&gt;</code> 等标签，必须在前后加上空行与其它内容区隔开，而且这些（元素）的开始与结尾标签，不可以用制表符或空格来缩进。Markdown 的生成器足够智能，不会在 HTML 区块标签外加上不必要的 <code>&lt;p&gt;</code> 标签。</p><p>举例来说，在 Markdown 文件里加上一段 HTML 表格：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">This is a regular paragraph.</span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span></span><br><span class="line"><span class="code">    &lt;tr&gt;</span></span><br><span class="line"><span class="code">        &lt;td&gt;Foo&lt;/td&gt;</span></span><br><span class="line"><span class="code">    &lt;/tr&gt;</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">This is another regular paragraph.</span><br></pre></td></tr></table></figure><p>Markdown 语法在 HTML 区块标签中将不会被进行处理。比如，你在 HTML 区块内使用 Markdown 样式的<code>*强调*</code>会没有效果。</p><p>HTML 的区段（行内）标签如 <code>&lt;span&gt;</code>、<code>&lt;cite&gt;</code>、<code>&lt;del&gt;</code> 则不受限制，可以在 Markdown 的段落、列表或是标题里任意使用。依照个人习惯，甚至可以不用 Markdown 格式，而直接采用 HTML 标签来格式化。举例说明：如果比较喜欢 HTML 的 <code>&lt;a&gt;</code> 或 <code>&lt;img&gt;</code> 标签，可以直接使用这些标签，而不用 Markdown 提供的链接或是图像标签语法。</p><p>请注意，Markdown 语法在 HTML 区段标签间是有效的。</p><h3 id="特殊字符自动转换"><a class="headerlink" href="#特殊字符自动转换"></a> 特殊字符自动转换</h3><p>在 HTML 文件中，有两个字符需要特殊处理： <code>&lt;</code> 和 <code>&amp;</code> 。 <code>&lt;</code> 符号用于起始标签，<code>&amp;</code> 符号则用于标记 HTML 实体，如果你只是想要显示这些字符的原型，你必须要使用实体的形式，像是 <code>&amp;lt;</code> 和 <code>&amp;amp;</code>。</p><p><code>&amp;</code> 符号其实很容易让写作网络文件的人感到困扰，如果你要打「AT&amp;T」 ，你必须要写成「<code>AT&amp;amp;T</code>」 ，而且网址中的 <code>&amp;</code> 字符也要转换。如果你要链接到：</p><p><a href="http://images.google.com/images?num=30&amp;q=larry+bird" target="_blank" rel="noopener">http://images.google.com/images?num=30&amp;q=larry+bird</a></p><p>你必须要把网址写成：</p><p><a href="http://images.google.com/images?num=30&amp;q=larry+bird" target="_blank" rel="noopener">http://images.google.com/images?num=30&amp;q=larry+bird</a></p><p>才能放到链接标签的 <code>href</code> 属性里。不用说也知道这很容易忽略，这也可能是 HTML 标准检查所检查到的错误中，数量最多的。</p><p>Markdown 可以自动处理这些符号，如果你使用的 <code>&amp;</code> 字符是 HTML 字符实体的一部分，它会保留原状，否则它会被转换成 <code>&amp;amp</code>;。<br>所以你如果要在文件中插入一个著作权的符号，你可以这样写：</p><p><code>&amp;copy;</code></p><p>Markdown 将不会对这段文字做修改，但是如果你这样写：</p><p><code>AT&amp;T</code></p><p>Markdown 就会将它转为：</p><p><code>AT&amp;amp;T</code></p><p>类似的状况也会发生在 <code>&lt;</code> 符号上，因为 Markdown 支持 <a href="#html">兼容 HTML</a> ，如果你是使用 <code>&lt;</code> 符号作为 HTML 标签使用，那 Markdown 也不会对它做任何转换，但是如果你是写：</p><p><code>4 &lt; 5</code></p><p>Markdown 将会把它转换为：</p><p><code>4 &amp;lt; 5</code></p><p>不过需要注意的是，code 范围内，不论是行内还是区块， <code>&lt;</code> 和 <code>&amp;</code> 两个符号都<strong>一定</strong>会被转换成 HTML 实体，这项特性让你可以很容易地用 Markdown 写 HTML code （和 HTML 相对而言， HTML 语法中，你要把所有的 <code>&lt;</code> 和 <code>&amp;</code> 都转换为 HTML 实体，才能在 HTML 文件里面写出 HTML code。）</p><hr><h2 id="区块元素"><a class="headerlink" href="#区块元素"></a> 区块元素</h2><h3 id="段落和换行"><a class="headerlink" href="#段落和换行"></a> 段落和换行</h3><p>一个 Markdown 段落是由一个或多个连续的文本行组成，它的前后要有一个以上的空行（空行的定义是显示上看起来像是空的，便会被视为空行。比方说，若某一行只包含空格和制表符，则该行也会被视为空行）。普通段落不该用空格或制表符来缩进。</p><p>「由一个或多个连续的文本行组成」这句话其实暗示了 Markdown 允许段落内的强迫换行（插入换行符），这个特性和其他大部分的 text-to-HTML 格式不一样（包括 Movable Type 的「Convert Line Breaks」选项），其它的格式会把每个换行符都转成 <code>&lt;br /&gt;</code> 标签。</p><p>如果你<strong>真的</strong>想要插入 <code>&lt;br /&gt;</code> 标签的话，在行尾加上两个以上的格然后回车。</p><p>是的，这确实需要花比较多功夫来插入 <code>&lt;br /&gt;</code> ，但是「每个换行都转换为 <code>&lt;br /&gt;</code>」的方法在 Markdown 中并不适合， Markdown 中 email 式的 <a href="#blockquote">区块引用</a> 和多段落的 <a href="#list">列表</a> 在使用换行来排版的时候，不但更好用，还更好阅读。</p><h3 id="标题"><a class="headerlink" href="#标题"></a> 标题</h3><p>Markdown 支持两种标题的语法，类 <a href="http://docutils.sourceforge.net/mirror/setext.html" target="_blank" rel="noopener">Setext</a> 和类 <a href="http://www.aaronsw.com/2002/atx/" target="_blank" rel="noopener">atx</a> 形式。</p><p>类 Setext 形式是用底线的形式，利用 <code>=</code> （最高阶标题）和 <code>-</code> （第二阶标题），例如：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">This is an H1</span><br><span class="line">=============</span><br><span class="line"></span><br><span class="line">This is an H2</span><br><span class="line">-------------</span><br></pre></td></tr></table></figure><p>任何数量的 <code>=</code> 和 <code>-</code> 都可以有效果。</p><p>类 Atx 形式则是在行首插入 1 到 6 个 <code>#</code> ，对应到标题 1 到 6 阶，例如：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># This is an H1</span></span><br><span class="line"></span><br><span class="line"><span class="section">## This is an H2</span></span><br><span class="line"></span><br><span class="line"><span class="section">###### This is an H6</span></span><br></pre></td></tr></table></figure><p>你可以选择性地「闭合」类 atx 样式的标题，这纯粹只是美观用的，若是觉得这样看起来比较舒适，你就可以在行尾加上 <code>#</code>，而行尾的 <code>#</code> 数量也不用和开头一样（行首的井字数量决定标题的阶数）：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># This is an H1 #</span></span><br><span class="line"></span><br><span class="line"><span class="section">## This is an H2 ##</span></span><br><span class="line"></span><br><span class="line"><span class="section">### This is an H3 ######</span></span><br></pre></td></tr></table></figure><h3 id="blockquotes"><a class="headerlink" href="#blockquotes"></a> Blockquotes</h3><p>Markdown 标记区块引用是使用类似 email 中用 <code>&gt;</code> 的引用方式。如果你还熟悉在 email 信件中的引言部分，你就知道怎么在 Markdown 文件中建立一个区块引用，那会看起来像是你自己先断好行，然后在每行的最前面加上 <code>&gt;</code> ：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="quote">&gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,</span></span><br><span class="line"><span class="quote">&gt; consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.</span></span><br><span class="line"><span class="quote">&gt; Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.</span></span><br><span class="line">&gt;</span><br><span class="line"><span class="quote">&gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse</span></span><br><span class="line"><span class="quote">&gt; id sem consectetuer libero luctus adipiscing.</span></span><br></pre></td></tr></table></figure><p>Markdown 也允许你只在整个段落的第一行最前面加上 <code>&gt;</code> ：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="quote">&gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,</span></span><br><span class="line">consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.</span><br><span class="line">Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.</span><br><span class="line"></span><br><span class="line"><span class="quote">&gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse</span></span><br><span class="line">id sem consectetuer libero luctus adipiscing.</span><br></pre></td></tr></table></figure><p>区块引用可以有嵌套（例如：引用内的引用），只要根据层数加上不同数量的 <code>&gt;</code> ：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="quote">&gt; This is the first level of quoting.</span></span><br><span class="line">&gt;</span><br><span class="line"><span class="quote">&gt; &gt; This is nested blockquote.</span></span><br><span class="line">&gt;</span><br><span class="line"><span class="quote">&gt; Back to the first level.</span></span><br></pre></td></tr></table></figure><p>引用的区块内也可以使用其他的 Markdown 语法，包括标题、列表、代码区块等：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="quote">&gt; ## This is a header.</span></span><br><span class="line">&gt;</span><br><span class="line"><span class="quote">&gt; 1.   This is the first list item.</span></span><br><span class="line"><span class="quote">&gt; 2.   This is the second list item.</span></span><br><span class="line">&gt;</span><br><span class="line"><span class="quote">&gt; Here's some example code:</span></span><br><span class="line">&gt;</span><br><span class="line"><span class="quote">&gt;     return shell_exec("echo $input | $markdown_script");</span></span><br></pre></td></tr></table></figure><p>任何标准的文本编辑器都能简单地建立 email 样式的引用，例如 BBEdit ，你可以选取文字后然后从选单中选择<em>增加引用阶层</em>。</p><h3 id="列表"><a class="headerlink" href="#列表"></a> 列表</h3><p>Markdown 支持有序列表和无序列表。</p><p>无序清单使用星号、加号或是减号作为列表标记：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*   Red</span><br><span class="line">*   Green</span><br><span class="line">*   Blue</span><br></pre></td></tr></table></figure><p>等同于：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+   Red</span><br><span class="line">+   Green</span><br><span class="line">+   Blue</span><br></pre></td></tr></table></figure><p>也等同于：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-   Red</span><br><span class="line">-   Green</span><br><span class="line">-   Blue</span><br></pre></td></tr></table></figure><p>有序列表则使用数字接着一个英文句点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.  Bird</span><br><span class="line">2.  McHale</span><br><span class="line">3.  Parish</span><br></pre></td></tr></table></figure><p>很重要的一点是，你在列表标记上使用的数字并不会影响输出的 HTML 结果，上面的列表所产生的 HTML 标记为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;ol&gt;</span><br><span class="line">&lt;li&gt;Bird&lt;/li&gt;</span><br><span class="line">&lt;li&gt;McHale&lt;/li&gt;</span><br><span class="line">&lt;li&gt;Parish&lt;/li&gt;</span><br><span class="line">&lt;/ol&gt;</span><br></pre></td></tr></table></figure><p>如果你的列表标记写成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.  Bird</span><br><span class="line">1.  McHale</span><br><span class="line">1.  Parish</span><br></pre></td></tr></table></figure><p>或甚至是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3. Bird</span><br><span class="line">1. McHale</span><br><span class="line">8. Parish</span><br></pre></td></tr></table></figure><p>你都会得到完全相同的 HTML 输出。重点在于，你可以让 Markdown 文件的列表数字和输出的结果相同，或是你懒一点，你可以完全不用在意数字的正确性。</p><p>如果你使用懒惰的写法，建议第一个项目最好还是从 1. 开始，因为 Markdown 未来可能会支持有序列表的 start 属性。</p><p>列表项目标记通常是放在最左边，但是其实也可以缩进，最多 3 个空格，项目标记后面则一定要接着至少一个空格或制表符。</p><p>要让列表看起来更漂亮，你可以把内容用固定的缩进整理好：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*   Lorem ipsum dolor sit amet, consectetuer adipiscing elit.</span><br><span class="line">    Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi,</span><br><span class="line">    viverra nec, fringilla in, laoreet vitae, risus.</span><br><span class="line">*   Donec sit amet nisl. Aliquam semper ipsum sit amet velit.</span><br><span class="line">    Suspendisse id sem consectetuer libero luctus adipiscing.</span><br></pre></td></tr></table></figure><p>但是如果你很懒，那也行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*   Lorem ipsum dolor sit amet, consectetuer adipiscing elit.</span><br><span class="line">Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi,</span><br><span class="line">viverra nec, fringilla in, laoreet vitae, risus.</span><br><span class="line">*   Donec sit amet nisl. Aliquam semper ipsum sit amet velit.</span><br><span class="line">Suspendisse id sem consectetuer libero luctus adipiscing.</span><br></pre></td></tr></table></figure><p>如果列表项目间用空行分开， 在输出 HTML 时 Markdown 会把项目的内容在输出时用 <code>&lt;p&gt;</code><br>标签包起来，举例来说：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*   Bird</span><br><span class="line">*   Magic</span><br></pre></td></tr></table></figure><p>会被转换为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">&lt;li&gt;Bird&lt;/li&gt;</span><br><span class="line">&lt;li&gt;Magic&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure><p>但是这个：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*   Bird</span><br><span class="line"></span><br><span class="line">*   Magic</span><br></pre></td></tr></table></figure><p>会被转换为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">&lt;li&gt;&lt;p&gt;Bird&lt;/p&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;p&gt;Magic&lt;/p&gt;&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure><p>列表项目可以包含多个段落，每个项目下的段落都必须缩进 4 个空格或是 1 个制表符：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.  This is a list item with two paragraphs. Lorem ipsum dolor</span><br><span class="line">    sit amet, consectetuer adipiscing elit. Aliquam hendrerit</span><br><span class="line">    mi posuere lectus.</span><br><span class="line"></span><br><span class="line">    Vestibulum enim wisi, viverra nec, fringilla in, laoreet</span><br><span class="line">    vitae, risus. Donec sit amet nisl. Aliquam semper ipsum</span><br><span class="line">    sit amet velit.</span><br><span class="line"></span><br><span class="line">2.  Suspendisse id sem consectetuer libero luctus adipiscing.</span><br></pre></td></tr></table></figure><p>如果你每行都有缩进，看起来会看好很多，当然，Markdown 也允许：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">*   This is a list item with two paragraphs.</span><br><span class="line"></span><br><span class="line">    This is the second paragraph in the list item. You&apos;re</span><br><span class="line">only required to indent the first line. Lorem ipsum dolor</span><br><span class="line">sit amet, consectetuer adipiscing elit.</span><br><span class="line"></span><br><span class="line">*   Another item in the same list.</span><br></pre></td></tr></table></figure><p>如果要在列表项目内放进引用，那 <code>&gt;</code> 就需要缩进：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*   A list item with a blockquote:</span><br><span class="line"></span><br><span class="line">    &gt; This is a blockquote</span><br><span class="line">    &gt; inside a list item.</span><br></pre></td></tr></table></figure><p>如果要放代码区块的话，该区块就需要缩排<strong>两次</strong>，也就是 8 个空格或是 2 个制表符：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*   A list item with a code block:</span><br><span class="line"></span><br><span class="line">        &lt;code goes here&gt;</span><br></pre></td></tr></table></figure><p>当然，项目列表很可能会不小心产生，像是下面这样的写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1986. What a great season.</span><br></pre></td></tr></table></figure><p>换句话说，也就是在行首出现<strong>数字-句点-空白</strong>，要避免这样的状况，你可以在句点前面加上反斜杠。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1986\. What a great season.</span><br></pre></td></tr></table></figure><h3 id="程序代码区块"><a class="headerlink" href="#程序代码区块"></a> 程序代码区块</h3><p>和程序相关的写作或是标签语言原始码通常会有已经排版好的代码区块，通常这些区块我们并不希望它以一般段落文件的方式去排版，而是照原来的样子显示，Markdown 会用 <code>&lt;pre&gt;</code> 和 <code>&lt;code&gt;</code> 标签来把代码区块包起来。</p><p>要在 Markdown 中建立代码区块很简单，只要简单地缩进 4 个空格或是 1 个制表符就可以，例如，下面的输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">This is a normal paragraph:</span><br><span class="line"></span><br><span class="line">    This is a code block.</span><br></pre></td></tr></table></figure><p>Markdown 会转换成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;This is a normal paragraph:&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;pre&gt;&lt;code&gt;This is a code block.</span><br><span class="line">&lt;/code&gt;&lt;/pre&gt;</span><br></pre></td></tr></table></figure><p>这个每行一阶的缩进（4 个空格或是 1 个制表符），都会被移除，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Here is an example of AppleScript:</span><br><span class="line"></span><br><span class="line">    tell application &quot;Foo&quot;</span><br><span class="line">        beep</span><br><span class="line">    end tell</span><br></pre></td></tr></table></figure><p>会被转换为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;Here is an example of AppleScript:&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;pre&gt;&lt;code&gt;tell application &quot;Foo&quot;</span><br><span class="line">    beep</span><br><span class="line">end tell</span><br><span class="line">&lt;/code&gt;&lt;/pre&gt;</span><br></pre></td></tr></table></figure><p>一个代码区块会一直持续到没有缩进的那一行（或是文件结尾）。</p><p>在代码区块里面， <code>&amp;</code> 、 <code>&lt;</code> 和 <code>&gt;</code> 会自动转成 HTML 实体，这样的方式让你非常容易使用 Markdown 插入范例用的 HTML 原始码，只需要复制贴上，再加上缩进就可以了，剩下的 Markdown 都会帮你处理，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;footer&quot;&gt;</span><br><span class="line">    &amp;copy; 2004 Foo Corporation</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>会被转换为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;pre&gt;&lt;code&gt;&amp;lt;div class=&quot;footer&quot;&amp;gt;</span><br><span class="line">    &amp;amp;copy; 2004 Foo Corporation</span><br><span class="line">&amp;lt;/div&amp;gt;</span><br><span class="line">&lt;/code&gt;&lt;/pre&gt;</span><br></pre></td></tr></table></figure><p>代码区块中，一般的 Markdown 语法不会被转换，像是星号便只是星号，这表示你可以很容易地以 Markdown 语法撰写 Markdown 语法相关的文件。</p><h3 id="分隔线"><a class="headerlink" href="#分隔线"></a> 分隔线</h3><p>你可以在一行中用三个或以上的星号、减号来建立一个分隔线，行内不能有其他东西。你也可以在星号中间插入空格。下面每种写法都可以建立分隔线：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">* * *</span><br><span class="line"></span><br><span class="line">***</span><br><span class="line"></span><br><span class="line">*****</span><br><span class="line"></span><br><span class="line">- - -</span><br><span class="line"></span><br><span class="line">---------------------------------------</span><br></pre></td></tr></table></figure><hr><h2 id="区段元素"><a class="headerlink" href="#区段元素"></a> 区段元素</h2><h3 id="链接"><a class="headerlink" href="#链接"></a> 链接</h3><p>Markdown 支持两种形式的链接语法： <strong>行内式</strong>和<strong>参考式</strong>两种形式。</p><p>不管是哪一种，链接的文字都是用 [方括号] 来标记。</p><p>要建立一个<strong>行内式</strong>的链接，只要在方括号后面马上接着圆括号并插入网址链接即可，如果你还想要加上链接的 title 文字，只要在网址后面，用双引号把 title 文字包起来即可，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">This is [an example](http://example.com/ &quot;Title&quot;) inline link.</span><br><span class="line"></span><br><span class="line">[This link](http://example.net/) has no title attribute.</span><br></pre></td></tr></table></figure><p>会产生：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;This is &lt;a href=&quot;http://example.com/&quot; title=&quot;Title&quot;&gt;</span><br><span class="line">an example&lt;/a&gt; inline link.&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;&lt;a href=&quot;http://example.net/&quot;&gt;This link&lt;/a&gt; has no</span><br><span class="line">title attribute.&lt;/p&gt;</span><br></pre></td></tr></table></figure><p>如果你是要链接到同样主机的资源，你可以使用相对路径：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">See my [About](/about/) page for details.</span><br></pre></td></tr></table></figure><p><strong>参考式</strong>的链接是在链接文字的括号后面再接上另一个方括号，而在第二个方括号里面要填入用以辨识链接的标记：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">This is [an example][id] reference-style link.</span><br></pre></td></tr></table></figure><p>你也可以选择性地在两个方括号中间加上空格：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">This is [an example] [id] reference-style link.</span><br></pre></td></tr></table></figure><p>接着，在文件的任意处，你可以把这个标签的链接内容定义出来：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[id]: http://example.com/  &quot;Optional Title Here&quot;</span><br></pre></td></tr></table></figure><p>链接内容定义的形式为：</p><ul><li>方括号（前面可以选择性地加上至多三个空格来缩进），里面输入链接文字</li><li>接着一个冒号</li><li>接着一个以上的空格或制表符</li><li>接着链接的网址</li><li>选择性地接着 title 内容，可以用单引号、双引号或是圆括号包着</li></ul><p>下面这三种连结的定义都是相同：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[foo]: http://example.com/  &quot;Optional Title Here&quot;</span><br><span class="line">[foo]: http://example.com/  &apos;Optional Title Here&apos;</span><br><span class="line">[foo]: http://example.com/  (Optional Title Here)</span><br></pre></td></tr></table></figure><p>**请注意：**有一个已知的问题是 <a href="http://Markdown.pl" target="_blank" rel="noopener">Markdown.pl</a> 1.0.1 会忽略单引号包起来的链接 title。</p><p>链接网址也可以用方括号包起来：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[id]: &lt;http://example.com/&gt;  &quot;Optional Title Here&quot;</span><br></pre></td></tr></table></figure><p>你也可以把 title 属性放到下一行，也可以加一些缩进，网址太长的话，这样会比较好看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[id]: http://example.com/longish/path/to/resource/here</span><br><span class="line">    &quot;Optional Title Here&quot;</span><br></pre></td></tr></table></figure><p>网址定义只有在产生链接的时候用到，并不会直接出现在文件之中。</p><p>链接辨识标记可以有字母、数字、空白和标点符号，但是并<strong>不区分</strong>大小写，因此下面两个链接是一样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[link text][a]</span><br><span class="line">[link text][A]</span><br></pre></td></tr></table></figure><p><strong>隐式链接标记</strong>功能让你可以省略指定链接标记，这种情形下，链接标记和链接文字会视为相同，要用隐式链接标记只要在链接文字后面加上一个空的方括号，如果你要让 “Google” 链接到 <a href="http://google.com" target="_blank" rel="noopener">google.com</a>，你可以简化成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Google][]</span><br></pre></td></tr></table></figure><p>然后定义链接内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Google]: http://google.com/</span><br></pre></td></tr></table></figure><p>由于链接文字可能包含空白，所以这种简化的标记内也可以包含多个单词：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Visit [Daring Fireball][] for more information.</span><br></pre></td></tr></table></figure><p>然后接着定义链接：</p><p>链接的定义可以放在文件中的任何一个地方，我比较偏好直接放在链接出现段落的后面，你也可以把它放在文件最后面，就像是注解一样。</p><p>下面是一个参考式链接的范例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">I get 10 times more traffic from [Google] [1] than from</span><br><span class="line">[Yahoo] [2] or [MSN] [3].</span><br><span class="line"></span><br><span class="line">  [1]: http://google.com/        &quot;Google&quot;</span><br><span class="line">  [2]: http://search.yahoo.com/  &quot;Yahoo Search&quot;</span><br><span class="line">  [3]: http://search.msn.com/    &quot;MSN Search&quot;</span><br></pre></td></tr></table></figure><p>如果改成用链接名称的方式写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">I get 10 times more traffic from [Google][] than from</span><br><span class="line">[Yahoo][] or [MSN][].</span><br><span class="line"></span><br><span class="line">  [google]: http://google.com/        &quot;Google&quot;</span><br><span class="line">  [yahoo]:  http://search.yahoo.com/  &quot;Yahoo Search&quot;</span><br><span class="line">  [msn]:    http://search.msn.com/    &quot;MSN Search&quot;</span><br></pre></td></tr></table></figure><p>上面两种写法都会产生下面的 HTML。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;I get 10 times more traffic from &lt;a href=&quot;http://google.com/&quot;</span><br><span class="line">title=&quot;Google&quot;&gt;Google&lt;/a&gt; than from</span><br><span class="line">&lt;a href=&quot;http://search.yahoo.com/&quot; title=&quot;Yahoo Search&quot;&gt;Yahoo&lt;/a&gt;</span><br><span class="line">or &lt;a href=&quot;http://search.msn.com/&quot; title=&quot;MSN Search&quot;&gt;MSN&lt;/a&gt;.&lt;/p&gt;</span><br></pre></td></tr></table></figure><p>下面是用行内形式写的同样一段内容的 Markdown 文件，提供作为比较之用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">I get 10 times more traffic from [Google](http://google.com/ &quot;Google&quot;)</span><br><span class="line">than from [Yahoo](http://search.yahoo.com/ &quot;Yahoo Search&quot;) or</span><br><span class="line">[MSN](http://search.msn.com/ &quot;MSN Search&quot;).</span><br></pre></td></tr></table></figure><p>参考式的链接其实重点不在于它比较好写，而是它比较好读，比较一下上面的范例，使用参考式的文章本身只有 81 个字符，但是用行内形式的连结却会增加到 176 个字符，如果是用纯 HTML 格式来写，会有 234 个字符，在 HTML 格式中，标签比文字还要多。</p><p>使用 Markdown 的参考式链接，可以让文件更像是浏览器最后产生的结果，让你可以把一些标记相关的信息移到段落文字之外，你就可以增加连结而不让文章的阅读感觉被打断。</p><h3 id="强调"><a class="headerlink" href="#强调"></a> 强调</h3><p>Markdown 使用星号（<code>*</code>）和底线（<code>_</code>）作为标记强调字词的符号，被 <code>*</code> 或 <code>_</code> 包围的字词会被转成用 <code>&lt;em&gt;</code> 标签包围，用两个 <code>*</code> 或 <code>_</code> 包起来的话，则会被转成 <code>&lt;strong&gt;</code>，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">*single asterisks*</span><br><span class="line"></span><br><span class="line">_single underscores_</span><br><span class="line"></span><br><span class="line">**double asterisks**</span><br><span class="line"></span><br><span class="line">__double underscores__</span><br></pre></td></tr></table></figure><p>会转成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;em&gt;single asterisks&lt;/em&gt;</span><br><span class="line"></span><br><span class="line">&lt;em&gt;single underscores&lt;/em&gt;</span><br><span class="line"></span><br><span class="line">&lt;strong&gt;double asterisks&lt;/strong&gt;</span><br><span class="line"></span><br><span class="line">&lt;strong&gt;double underscores&lt;/strong&gt;</span><br></pre></td></tr></table></figure><p>你可以随便用你喜欢的样式，唯一的限制是，你用什么符号开启标签，就要用什么符号结束。</p><p>强调也可以直接插在文字中间：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">un*frigging*believable</span><br></pre></td></tr></table></figure><p>但是<strong>如果你的 <code>*</code> 和 <code>_</code> 两边都有空白的话，它们就只会被当成普通的符号</strong>。</p><p>如果要在文字前后直接插入普通的星号或底线，你可以用反斜杠：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\*this text is surrounded by literal asterisks\*</span><br></pre></td></tr></table></figure><h3 id="代码"><a class="headerlink" href="#代码"></a> 代码</h3><p>如果要标记一小段行内代码，你可以用反引号把它包起来（<code>`</code>），例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Use the `printf()` function.</span><br></pre></td></tr></table></figure><p>会产生：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;Use the &lt;code&gt;printf()&lt;/code&gt; function.&lt;/p&gt;</span><br></pre></td></tr></table></figure><p>如果要在代码区段内插入反引号，你可以用多个反引号来开启和结束代码区段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">``There is a literal backtick (`) here.``</span><br></pre></td></tr></table></figure><p>这段语法会产生：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;&lt;code&gt;There is a literal backtick (`) here.&lt;/code&gt;&lt;/p&gt;</span><br></pre></td></tr></table></figure><p>代码区段的起始和结束端都可以放入一个空白，起始端后面一个，结束端前面一个，这样你就可以在区段的一开始就插入反引号：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A single backtick in a code span: `` ` ``</span><br><span class="line"></span><br><span class="line">A backtick-delimited string in a code span: `` `foo` ``</span><br></pre></td></tr></table></figure><p>会产生：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;A single backtick in a code span: &lt;code&gt;`&lt;/code&gt;&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;A backtick-delimited string in a code span: &lt;code&gt;`foo`&lt;/code&gt;&lt;/p&gt;</span><br></pre></td></tr></table></figure><p>在代码区段内，<code>&amp;</code> 和方括号都会被转成 HTML 实体，这样会比较容易插入 HTML 原始码，Markdown 会把下面这段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Please don&apos;t use any `&lt;blink&gt;` tags.</span><br></pre></td></tr></table></figure><p>转为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;Please don&apos;t use any &lt;code&gt;&amp;lt;blink&amp;gt;&lt;/code&gt; tags.&lt;/p&gt;</span><br></pre></td></tr></table></figure><p>你也可以这样写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`&amp;#8212;` is the decimal-encoded equivalent of `&amp;mdash;`.</span><br></pre></td></tr></table></figure><p>以产生：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;&lt;code&gt;&amp;amp;#8212;&lt;/code&gt; is the decimal-encoded</span><br><span class="line">equivalent of &lt;code&gt;&amp;amp;mdash;&lt;/code&gt;.&lt;/p&gt;</span><br></pre></td></tr></table></figure><h3 id="图片"><a class="headerlink" href="#图片"></a> 图片</h3><p>很明显地，要在纯文本应用中设计一个 「自然」的语法来插入图片是有一定难度的。</p><p>Markdown 使用一种和链接很相似的语法来标记图片，同样也允许两种样式： <strong>行内式</strong>和<strong>参考式</strong>。</p><p>行内式图片的语法看起来像是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">![Alt text](/path/to/img.jpg)</span><br><span class="line"></span><br><span class="line">![Alt text](/path/to/img.jpg &quot;Optional title&quot;)</span><br></pre></td></tr></table></figure><p>详细叙述如下：</p><ul><li>一个惊叹号 <code>!</code></li><li>接着一对方括号，里面放上图片的替代文字</li><li>接着一对普通括号，里面放上图片的网址，最后还可以用引号包住并加上选择性的 ‘title’ 文字。</li></ul><p>参考式的图片语法则长得像这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![Alt text][id]</span><br></pre></td></tr></table></figure><p>「id」是图片参考的名称，图片参考的定义方式则和链接参考一样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[id]: url/to/image  &quot;Optional title attribute&quot;</span><br></pre></td></tr></table></figure><p>到目前为止， Markdown 还没有办法指定图片的宽高，如果你需要的话，你可以使用普通的 <code>&lt;img&gt;</code> 标签。</p><hr><h2 id="其它"><a class="headerlink" href="#其它"></a> 其它</h2><h3 id="自动链接"><a class="headerlink" href="#自动链接"></a> 自动链接</h3><p>Markdown 支持比较简短的自动连结形式来处理网址和电子邮件信箱，只要是用方括号包起来， Markdown 就会自动把它转成链接，链接的文字就和链接位置一样，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;http://example.com/&gt;</span><br></pre></td></tr></table></figure><p>Markdown 会转为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;http://example.com/&quot;&gt;http://example.com/&lt;/a&gt;</span><br></pre></td></tr></table></figure><p>邮址的自动链接也很类似，只是 Markdown 会先做一个编码转换的过程，把文字字符转成 16 进位码的 HTML 实体，这样的格式可以糊弄一些不好的邮址收集机器人，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;address@example.com&gt;</span><br></pre></td></tr></table></figure><p>Markdown 会转成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;&amp;#x6D;&amp;#x61;i&amp;#x6C;&amp;#x74;&amp;#x6F;:&amp;#x61;&amp;#x64;&amp;#x64;&amp;#x72;&amp;#x65;</span><br><span class="line">&amp;#115;&amp;#115;&amp;#64;&amp;#101;&amp;#120;&amp;#x61;&amp;#109;&amp;#x70;&amp;#x6C;e&amp;#x2E;&amp;#99;&amp;#111;</span><br><span class="line">&amp;#109;&quot;&gt;&amp;#x61;&amp;#x64;&amp;#x64;&amp;#x72;&amp;#x65;&amp;#115;&amp;#115;&amp;#64;&amp;#101;&amp;#120;&amp;#x61;</span><br><span class="line">&amp;#109;&amp;#x70;&amp;#x6C;e&amp;#x2E;&amp;#99;&amp;#111;&amp;#109;&lt;/a&gt;</span><br></pre></td></tr></table></figure><p>在浏览器里面，这段字符串（其实是 <code>&lt;a href=&quot;mailto:address@example.com&quot;&gt;address@example.com&lt;/a&gt;</code>）会变成一个可以点击的「address@example.com」链接。</p><p>（这种作法虽然可以糊弄不少的机器人，但并无法全部挡下来，不过这样也比什么都不做好些。无论如何，公开你的信箱终究会引来广告信件的。）</p><h3 id="反斜杠"><a class="headerlink" href="#反斜杠"></a> 反斜杠</h3><p>Markdown 可以利用反斜杠来插入一些在语法中有其它意义的符号，例如：如果你想要用星号加在文字旁边的方式来做出强调效果（但不用 <code>&lt;em&gt;</code> 标签），你可以在星号的前面加上反斜杠：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\*literal asterisks\*</span><br></pre></td></tr></table></figure><p>Markdown 支持在下面这些符号前面加上反斜杠来帮助插入普通的符号：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">\   反斜杠</span><br><span class="line">`   反引号</span><br><span class="line">*   星号</span><br><span class="line">_   底线</span><br><span class="line">&#123;&#125;  大括号</span><br><span class="line">[]  方括号</span><br><span class="line">()  括号</span><br><span class="line">#   井字号</span><br><span class="line">+    加号</span><br><span class="line">-    减号</span><br><span class="line">.   英文句点</span><br><span class="line">!   惊叹号</span><br></pre></td></tr></table></figure><h2 id="感谢"><a class="headerlink" href="#感谢"></a> 感谢</h2><p>感谢 <a href="https://twitter.com/#!/leafy7382" target="_blank" rel="noopener">leafy7382</a> 协助翻译，<a href="http://iamhlb.com/" target="_blank" rel="noopener">hlb</a>、<a href="http://twitter.com/randylien" target="_blank" rel="noopener">Randylien</a> 帮忙润稿，<a href="https://twitter.com/#!/ethantw" target="_blank" rel="noopener">ethantw</a> 的<a href="http://ethantw.net/projects/han/" target="_blank" rel="noopener">汉字标准格式・CSS Reset</a>， <a href="http://kidwm.net/" target="_blank" rel="noopener">WM</a> 回报文字错误。<br>因 gitcafe 被 coding 收购, 原来[markdown 中文][]翻译消失, 我们迁移到了 github 上</p>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
            <tag> 句法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发[1]-volatile关键字解析(在更新..)</title>
      <link href="/2018/09/03/thread-1/"/>
      <url>/2018/09/03/thread-1/</url>
      
        <content type="html"><![CDATA[<h2 id="前置"><a class="headerlink" href="#前置"></a> 前置</h2><ul><li><a href="https://theembers.gitee.io/2018/08/27/JVM-memory-model/" target="_blank" rel="noopener">JVM 内存模型</a></li></ul><h2 id="计算机内存模型"><a class="headerlink" href="#计算机内存模型"></a> 计算机内存模型</h2><p>每条指令都是在 CPU 中执行的，而执行指令过程中，势必涉及到数据的读取和写入。由于程序运行过程中的临时数据是存放在主存（物理内存）当中的，这时就存在一个问题：由于 CPU 执行速度很快，而从内存读取数据和向内存写入数据的过程跟 CPU 执行指令的速度比起来要慢的多，因此如果任何时候对数据的操作都要通过和内存的交互来进行，会大大降低指令执行的速度。因此，在 CPU 里面就有了 高速缓存（寄存器）。 在程序运行过程中，会将运算需要的数据从主存复制一份到 CPU 的高速缓存当中，那么， CPU 进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中。</p><p>但这种模式下就会存在 <strong>缓存一致性问题</strong> ，假设在主内存中有一个变量（n=0），这时有两个线程（a,b）同时读取了这个变量，其中 a 线程修改了这个变量（n=2），但这时新的值只是写在 a 线程的缓存中，b 线程是感知不到这个变化的，所以 b 线程依然在使用 n 的旧值（n=0），所以这时 b 线程可能在进行一个错误的过程。</p><p><img src="https://i.loli.net/2018/09/06/5b9095bd20812.png" alt="计算机内存模型.png"><span class="image-caption">计算机内存模型.png</span></p><p>为了解决缓存不一致性问题，在 硬件层面 上通常来说有以下两种解决方法：</p><ul><li>通过在 总线加 LOCK# 锁 的方式 （在软件层面，效果等价于使用 synchronized 关键字）；</li><li>通过 缓存一致性协议 （在软件层面，效果等价于使用 volatile 关键字）。</li></ul><p>相较于缓存一致性协议，总线锁在锁住总线期间，其他 CPU 无法访问内存，导致效率低下。而缓存一致性协议在 CPU 写数据时，如果发现操作的变量是共享变量，即在其他 CPU 中也存在该变量的副本，会发出信号通知其他 CPU 将该变量的缓存行置为无效状态。因此，当其他 CPU 需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取。</p><hr><h2 id="并发编程的核心概念"><a class="headerlink" href="#并发编程的核心概念"></a> 并发编程的核心概念</h2><h3 id="原子性"><a class="headerlink" href="#原子性"></a> 原子性</h3><p>即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。</p><h3 id="可见性"><a class="headerlink" href="#可见性"></a> 可见性</h3><p>当多个线程访问同一个共享变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</p><h3 id="有序性"><a class="headerlink" href="#有序性"></a> 有序性</h3><p>即程序执行的顺序按照代码的先后顺序执行。</p><p>在处理器运行时，为了提高效率可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。（<strong>最终一致性</strong>）</p><p>在多处理器环境下，倘若两条程序存在数据状态的依赖，但这两条程序不再同一个处理器中执行，那么就可能出现错误。</p><p>所以，指令重排序不会影响单个线程的执行，但是会影响到线程并发执行的正确性。也就是说，要想使并发程序正确地执行，必须要保证原子性、可见性以及有序性。只要有一个没有被保证，就有可能会导致程序运行不正确。</p><hr><h2 id="java-内存模型"><a class="headerlink" href="#java-内存模型"></a> Java 内存模型</h2><p>Java 内存模型 规定所有的变量都是存在主存当中（类似于前面说的物理内存），每个线程都有自己的工作内存（类似于前面的高速缓存）。线程对变量的所有操作都必须在工作内存中进行，而不能直接对主存进行操作，并且每个线程不能访问其他线程的工作内存。因此也存在着像硬件层一样的情况。</p><h3 id="原子性-2"><a class="headerlink" href="#原子性-2"></a> 原子性</h3><p>在 Java 中，对 <strong>基本数据类型</strong> 的变量的 <strong>读取</strong> 和 <strong>赋值</strong> 操作是原子性操作，即这些操作是不可被中断的：要么执行，要么不执行。<br>Java 内存模型只保证了基本读取和赋值是原子性操作，如果要实现更大范围操作的原子性，可以通过 synchronized 和 Lock 来实现。由于 synchronized 和 Lock 能够保证任一时刻只有一个线程执行该代码块，那么自然就不存在原子性问题了，从而保证了原子性。</p><h3 id="可见性-2"><a class="headerlink" href="#可见性-2"></a> 可见性</h3><p>Java 提供了 volatile 关键字 来保证可见性。</p><p>当一个共享变量被 volatile 修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。而普通的共享变量不能保证可见性，因为 <strong>普通共享变量被修改之后，什么时候被写入主存是不确定的</strong>，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。</p><p>另外，通过 synchronized 和 Lock 也能够保证可见性，synchronized 和 Lock 能保证同一时刻只有一个线程获取锁然后执行同步代码，并且 <strong>在释放锁之前会将对变量的修改刷新到主存当中</strong>，因此可以保证可见性。</p><h3 id="有序性-2"><a class="headerlink" href="#有序性-2"></a> 有序性</h3><p>在 Java 内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。</p><p>在 Java 中，可以通过 volatile 关键字来保证 <strong>一定的“有序性”</strong>。另外可以通过 synchronized 和 Lock 来保证 <strong>按顺序执行</strong>，但不是说明是保证“有序性”，也就是说，不能由于 synchronized 和 Lock 可以让线程串行执行同步代码，就说它们可以保证指令不会发生重排序，这根本不是一个粒度的问题。</p><h4 id="happens-before-原则"><a class="headerlink" href="#happens-before-原则"></a> happens-before 原则</h4><blockquote><p>Java 内存模型具备一些先天的“有序性”，即不需要通过任何手段就能够得到保证的有序性。</p></blockquote><ul><li><p>程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作；</p><p>需要强调的是这里所说的是在 <strong>一个线程里</strong>，也就是说这句话要表达的是最终一致性，所以在并发层面，这个条规则是不能保证有序性的。</p></li><li><p>锁定规则：一个 unLock 操作先行发生于后面对同一个锁额 lock 操作；</p><p>同一个锁如果出于被锁定的状态，那么必须先对锁进行了释放操作，后面才能继续进行 lock 操作。</p></li><li><p>volatile 变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作；</p><p>如果一个线程先去写一个变量，然后一个线程去进行读取，那么写入操作肯定会先行发生于读操作。</p></li><li><p>传递规则：如果操作 A 先行发生于操作 B，而操作 B 又先行发生于操作 C，则可以得出操作 A 先行发生于操作 C ；</p><p>传递性</p></li><li><p>线程启动规则：Thread 对象的 start()方法先行发生于此线程的每个一个动作；</p></li><li><p>线程中断规则：对线程 interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生；</p></li><li><p>线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过 Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行；</p></li><li><p>对象终结规则：一个对象的初始化完成先行发生于他的 finalize()方法的开始。</p></li></ul><h2 id="volatile-关键字"><a class="headerlink" href="#volatile-关键字"></a> volatile 关键字</h2><h3 id="语义"><a class="headerlink" href="#语义"></a> 语义</h3><ul><li><p>保证了不同线程对共享变量进行操作时的可见性，即一个线程修改了某个变量的值，这个新值对其他线程来说是 <strong>立即可见</strong> 的</p></li><li><p>禁止进行指令重排序</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> dev </category>
          
          <category> java </category>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 并发 </tag>
            
            <tag> 多线程 </tag>
            
            <tag> volatile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发[0]-二档起步：线程</title>
      <link href="/2018/09/01/thread-0/"/>
      <url>/2018/09/01/thread-0/</url>
      
        <content type="html"><![CDATA[<h2 id="前置所谓二挡起步"><a class="headerlink" href="#前置所谓二挡起步"></a> 前置（所谓“二挡起步”）</h2><ul><li><a href="https://theembers.gitee.io/2018/08/27/JVM-memory-model/" target="_blank" rel="noopener">JVM内存模型</a></li><li>基本线程概念认知</li></ul><h2 id="线程的生命周期"><a class="headerlink" href="#线程的生命周期"></a> 线程的生命周期</h2><table><thead><tr><th style="text-align:left">状态</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">NEW</td><td style="text-align:left">初始状态，线程被构建，但是还没有调用 start()方法</td></tr><tr><td style="text-align:left">RUNNABLE</td><td style="text-align:left">运行状态，Java 线程将操作系统中的就绪和运行两种状态笼统地称作“运行中”</td></tr><tr><td style="text-align:left">BLOCKED</td><td style="text-align:left">阻塞状态，表示线程阻塞于锁</td></tr><tr><td style="text-align:left">WAITING</td><td style="text-align:left">等待状态，表示线程进入等待状态，进入该状态表示当前线程需要等待其他线程做出一些特定动作（通知或中断）</td></tr><tr><td style="text-align:left">TIME_WAITING</td><td style="text-align:left">超时等待状态，该状态不同于 WAITING，它是可以在指定的时间自行返回的</td></tr><tr><td style="text-align:left">TERMINATED</td><td style="text-align:left">终止状态，表示当前线程已经执行完毕</td></tr></tbody></table><center><p><img src="https://i.loli.net/2018/09/01/5b8a7d293eb42.png" alt="线程状态变迁"><span class="image-caption">线程状态变迁</span></p></center><h2 id="上下文切换"><a class="headerlink" href="#上下文切换"></a> 上下文切换</h2><p>CPU在运行一个线程的过程中，转而去运行另外一个线程，这个叫做线程 上下文切换（对于进程也是类似）。</p><p>一般来说，线程上下文切换过程中会记录程序计数器、CPU寄存器状态等数据。</p><p>实质上， 线程的上下文切换就是存储和恢复CPU状态的过程，它使得线程执行能够从中断点恢复执行，这正是有程序计数器所支持的。</p><h2 id="线程的创建"><a class="headerlink" href="#线程的创建"></a> 线程的创建</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//使用继承Thread类的方式创建线程</span></span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"Thread"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用实现Runnable接口的方式创建线程</span></span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"Runnable"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//JVM 创建的主线程 main</span></span><br><span class="line">        System.out.println(<span class="string">"main"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>start()方法的作用是通知 “线程规划器” 该线程已经准备就绪，以便让系统安排一个时间来调用其 run()方法，也就是使线程得到运行。</strong></p><h2 id="thread-类详解"><a class="headerlink" href="#thread-类详解"></a> Thread 类详解</h2><h3 id="start-方法"><a class="headerlink" href="#start-方法"></a> start 方法</h3><p>start() 用来启动一个线程，当调用该方法后，相应线程就会进入就绪状态，该线程中的run()方法会在某个时机被调用。</p><h3 id="run-方法"><a class="headerlink" href="#run-方法"></a> run 方法</h3><p>run()方法是不需要用户来调用的。当通过start()方法启动一个线程之后，一旦线程获得了CPU执行时间，便进入run()方法体去执行具体的任务。注意，创建线程时必须重写run()方法，以定义具体要执行的任务。<br>一般来说，有两种方式可以达到重写run()方法的效果：</p><ul><li>直接重写：直接继承Thread类并重写run()方法；</li><li>间接重写：通过Thread构造函数传入Runnable对象 (注意，实际上重写的是 Runnable对象 的run() 方法)。</li></ul><h3 id="sleep-方法"><a class="headerlink" href="#sleep-方法"></a> sleep 方法</h3><p>作用是在指定的毫秒数内让当前正在执行的线程（即<code>currentThread()</code>方法所返回的线程）睡眠，并交出 CPU 让其去执行其他的任务。当线程睡眠时间满后，不一定会立即得到执行，因为此时 CPU 可能正在执行其他的任务。所以说，调用sleep方法相当于让线程进入阻塞状态。该方法有如下两条特征：</p><ul><li>如果调用了sleep方法，必须捕获InterruptedException异常或者将该异常向上层抛出；</li><li>sleep方法不会释放锁，也就是说如果当前线程持有对某个对象的锁，则即使调用sleep方法，其他线程也无法访问这个对象。</li></ul><h3 id="yield-方法"><a class="headerlink" href="#yield-方法"></a> yield 方法</h3><p>调用 yield()方法会让当前线程交出CPU资源，让CPU去执行其他的线程。但是yield()不能控制具体的交出CPU的时间。</p><ul><li>yield()方法只能让 拥有相同优先级的线程 有获取 CPU 执行时间的机会；</li><li>调用yield()方法并不会让线程进入阻塞状态，而是让线程重回就绪状态，它只需要等待重新得到 CPU 的执行；</li><li>它同样不会释放锁。</li></ul><h3 id="join-方法"><a class="headerlink" href="#join-方法"></a> join 方法</h3><p>假如在main线程中调用thread.join方法，则main线程会等待thread线程执行完毕或者等待一定的时间。详细地，如果调用的是无参join方法，则等待thread执行完毕；如果调用的是指定了时间参数的join方法，则等待一定的时间。join()方法有三个重载版本：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">long</span> millis)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;...&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">long</span> millis, <span class="keyword">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;...&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;...&#125;</span><br></pre></td></tr></table></figure><p>join()方法是通过wait()方法 (Object 提供的方法) 实现的。当 millis == 0 时，会进入 <code>while(isAlive())</code> 循环，并且只要子线程是活的，宿主线程就不停的等待。 <code>wait(0)</code> 的作用是让当前线程(宿主线程)等待，而这里的当前线程是指 <code>Thread.currentThread()</code> 所返回的线程。所以，虽然是子线程对象(锁)调用wait()方法，但是阻塞的是宿主线程。</p><ul><li>join方法同样会会让线程交出CPU执行权限；</li><li>join方法同样会让线程释放对一个对象持有的锁；</li><li>如果调用了join方法，必须捕获InterruptedException异常或者将该异常向上层抛出。</li></ul><h3 id="interrupt-方法"><a class="headerlink" href="#interrupt-方法"></a> interrupt 方法</h3><p>单独调用interrupt方法可以使得 处于阻塞状态的线程 抛出一个异常，也就是说，它可以用来中断一个正处于阻塞状态的线程；<br>另外，通过 interrupted()方法 和 isInterrupted()方法 可以停止正在运行的线程。</p><blockquote><p>直接调用interrupt() 方法不能中断正在运行中的线程。但是，如果配合 isInterrupted()/interrupted() 能够中断正在运行的线程，因为调用interrupt()方法相当于将中断标志位置为true，那么可以通过调用isInterrupted()/interrupted()判断中断标志是否被置位来中断线程的执行。<br>但是，一般情况下，不建议通过这种方式来中断线程，一般会在MyThread类中增加一个 volatile 属性 isStop 来标志是否结束 while 循环，然后再在 while 循环中判断 isStop 的值。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// interrupt 阻断线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadSafe</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">while</span> (!isInterrupted())&#123; <span class="comment">//非阻塞过程中通过判断中断标志来退出</span></span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                Thread.sleep(<span class="number">5</span>*<span class="number">1000</span>);<span class="comment">//阻塞过程捕获中断异常来退出</span></span><br><span class="line">            &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">//捕获到异常之后，执行break跳出循环。</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 退出标记 阻断线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadSafe</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> exit = <span class="keyword">false</span>; </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">while</span> (!exit)&#123;</span><br><span class="line">            <span class="comment">//do something</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="stop-方法"><a class="headerlink" href="#stop-方法"></a> stop 方法</h3><p>stop() 方法已经是一个<strong>废弃的</strong>方法，它是一个 <font color="red"> 不安全的 </font> 方法。因为调用 stop() 方法会直接终止run方法的调用，并且会抛出一个ThreadDeath错误，如果线程持有某个对象锁的话，会完全释放锁，导致对象状态不一致。所以， stop() 方法基本是不会被用到的。</p><h2 id="线程常用操作"><a class="headerlink" href="#线程常用操作"></a> 线程常用操作</h2><h3 id="获得代码调用者信息"><a class="headerlink" href="#获得代码调用者信息"></a> 获得代码调用者信息</h3><p><code>currentThread()</code> 方法返回代码段正在被哪个线程调用的信息。</p><h3 id="判断线程是否处于活动状态"><a class="headerlink" href="#判断线程是否处于活动状态"></a> 判断线程是否处于活动状态</h3><p><code>isAlive()</code> 的功能是判断调用该方法的线程是否处于活动状态。其中，活动状态指的是线程已经 start (无论是否获得CPU资源并运行) 且尚未结束。</p><h3 id="获取线程唯一标识"><a class="headerlink" href="#获取线程唯一标识"></a> 获取线程唯一标识</h3><p><code>getId()</code> 的作用是取得线程唯一标识，由JVM自动给出。</p><h3 id="线程名称-getname-和-setname"><a class="headerlink" href="#线程名称-getname-和-setname"></a> 线程名称 getName 和 setName</h3><p>用来得到或者设置线程名称。如果我们不手动设置线程名字，JVM会为该线程自动创建一个标识名，形式为： Thread-数字。</p><h3 id="优先级-getpriority-和-setpriority"><a class="headerlink" href="#优先级-getpriority-和-setpriority"></a> 优先级 getPriority 和 setPriority</h3><p>在操作系统中，线程可以划分优先级，优先级较高的线程得到的CPU资源较多，也就是CPU优先执行优先级较高的线程。设置线程优先级有助于帮助 “线程规划器” 确定在下一次选择哪个线程来获得CPU资源。特别地，在 Java 中，线程的优先级分为 1 ~ 10 这 10 个等级，如果小于 1 或大于 10，则 JDK 抛出异常 IllegalArgumentException ，该异常是 RuntimeException 的子类，属于不受检异常。JDK 中使用 3 个常量来预置定义优先级的值，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_PRIORITY = <span class="number">1</span>; </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NORM_PRIORITY = <span class="number">5</span>; </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_PRIORITY = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><ol><li>线程优先级的继承性<br>在 Java 中，线程的优先级具有继承性，比如 A 线程启动 B 线程， 那么 B 线程的优先级与 A 是一样的。</li><li>线程优先级的规则性和随机性<br>线程的优先级具有一定的规则性，也就是CPU尽量将执行资源让给优先级比较高的线程。特别地，高优先级的线程总是大部分先执行完，但并不一定所有的高优先级线程都能先执行完。</li></ol><h2 id="守护线程-daemon"><a class="headerlink" href="#守护线程-daemon"></a> 守护线程 (Daemon)</h2><p>当进程中不存在非守护线程时，则守护线程自动销毁，典型的守护线程就是垃圾回收线程。<br>只要当前JVM实例中存在任何一个非守护线程没有结束，守护线程就在工作；只有当最后一个非守护线程结束时，守护线程才随着JVM一同结束工作。</p><h2 id="小结"><a class="headerlink" href="#小结"></a> 小结</h2><p>对于上述线程的各项基本操作，其 <strong>所操作的对象</strong> 满足：</p><ul><li>若该操作是静态方法，也就是说，该方法属于类而非具体的某个对象，那么该操作的作用对象就是 currentThread() 方法所返回 Thread 对象；</li><li>若该操作是实例方法，也就是说，该方法属于对象，那么该操作的作用对象就是调用该方法的 Thread 对象。</li></ul><p>对于上述线程的各项基本操作，有：</p><ul><li>线程一旦被阻塞，就会释放 CPU；</li><li>当线程出现异常且没有捕获处理时，JVM会自动释放当前线程占用的锁，因此不会由于异常导致出现死锁现象。</li><li>对于一个线程，CPU 的释放 与 锁的释放没有必然联系。</li></ul>]]></content>
      
      
      <categories>
          
          <category> dev </category>
          
          <category> java </category>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 二档起步 </tag>
            
            <tag> 并发 </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM[4]-垃圾回收机制(GC)</title>
      <link href="/2018/08/31/JVM-4/"/>
      <url>/2018/08/31/JVM-4/</url>
      
        <content type="html"><![CDATA[<h2 id="前置"><a class="headerlink" href="#前置"></a> 前置</h2><p><a href="https://theembers.gitee.io/2018/08/27/JVM-memory-model/" target="_blank" rel="noopener">JVM[0]-运行时数据区</a></p><h2 id="意义"><a class="headerlink" href="#意义"></a> 意义</h2><p>堆(包括 Java 堆和方法区)是垃圾回收的主要对象</p><h2 id="stop-the-world"><a class="headerlink" href="#stop-the-world"></a> Stop-the-World</h2><p>Stop-the-world 意味着 JVM 由于要执行 GC 而停止了应用程序的执行，并且这种情形会在任何一种 GC 算法中发生。当 Stop-the-world 发生时，除了 GC 所需的线程以外，所有线程都处于等待状态直到 GC 任务完成。事实上，GC 优化很多时候就是指减少 Stop-the-world 发生的时间，从而使系统具有 高吞吐 、低停顿 的特点。</p><hr><h2 id="确定一个对象是否可以被回收"><a class="headerlink" href="#确定一个对象是否可以被回收"></a> 确定一个对象是否可以被回收</h2><h3 id="引用计数算法"><a class="headerlink" href="#引用计数算法"></a> 引用计数算法</h3><p>引用计数算法是通过判断对象的引用数量来决定对象是否可以被回收。<br>在这种方法中，堆中的每个对象实例都有一个引用计数。当一个对象被创建时，且将该对象实例分配给一个引用变量，该对象实例的引用计数设置为 1。当任何其它变量被赋值为这个对象的引用时，对象实例的引用计数加 1（a = b，则 b 引用的对象实例的计数器加 1），但当一个对象实例的某个引用超过了生命周期或者被设置为一个新值时，对象实例的引用计数减 1。特别地，当一个对象实例被垃圾收集时，它引用的任何对象实例的引用计数器均减 1。任何引用计数为 0 的对象实例可以被当作垃圾收集。</p><p>但是，这种方法无法回收对象实例相互引用的情况，因为他们的引用技术器无法被减为 0。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceCountingGC</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testGC</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        ReferenceCountingGC objA = <span class="keyword">new</span> ReferenceCountingGC ();</span><br><span class="line">        ReferenceCountingGC objB = <span class="keyword">new</span> ReferenceCountingGC ();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对象之间相互循环引用，对象objA和objB之间的引用计数永远不可能为 0</span></span><br><span class="line">        objB.instance = objA;</span><br><span class="line">        objA.instance = objB;</span><br><span class="line"></span><br><span class="line">        objA = <span class="keyword">null</span>;</span><br><span class="line">        objB = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="可达性分析算法"><a class="headerlink" href="#可达性分析算法"></a> 可达性分析算法</h3><p>可达性分析算法是通过判断对象的引用链是否可达来决定对象是否可以被回收。</p><p>可达性分析算法是从离散数学中的图论引入的，程序把所有的引用关系看作一张图，通过一系列的名为 “GC Roots” 的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain）。当一个对象到 GC Roots 没有任何引用链相连（用图论的话来说就是从 GC Roots 到这个对象不可达）时，则证明此对象是不可用的。在 Java 中，可作为 GC Root 的对象包括以下几种：</p><ul><li>虚拟机栈(栈帧中的局部变量表)中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中 Native 方法引用的对象</li></ul><hr><h2 id="垃圾收集算法"><a class="headerlink" href="#垃圾收集算法"></a> 垃圾收集算法</h2><h3 id="标记清除算法"><a class="headerlink" href="#标记清除算法"></a> 标记清除算法</h3><p>标记-清除算法分为标记和清除两个阶段。该算法首先从根集合进行扫描，对存活的对象对象标记，标记完毕后，再扫描整个空间中未被标记的对象并进行回收</p><center><p><img src="https://i.loli.net/2018/08/31/5b88b34c7d76f.jpg" alt="可达性分析算法.jpg"><span class="image-caption">可达性分析算法.jpg</span></p></center><p>标记-清除算法的主要不足有两个：</p><ul><li>效率问题：标记和清除两个过程的效率都不高;</li><li>空间问题：标记-清除算法不需要进行对象的移动，并且仅对不存活的对象进行处理，因此标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</li></ul><h3 id="复制算法"><a class="headerlink" href="#复制算法"></a> 复制算法</h3><p>复制算法将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。<br>**这种算法适用于对象存活率低的场景，比如新生代。**这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。<br><strong>现在商用的虚拟机都采用这种算法来回收新生代。</strong></p><blockquote><p>实践中会将新生代内存分为一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 和其中一块 Survivor。当回收时，将 Eden 和 Survivor 中还存活着的对象一次地复制到另外一块 Survivor 空间上，最后清理掉 Eden 和刚才用过的 Survivor 空间。HotSpot 虚拟机默认 Eden 和 Survivor 的大小比例是 8:1，也就是每次新生代中可用内存空间为整个新生代容量的 90% ( 80%+10% )，只有 10% 的内存会被“浪费”。</p></blockquote><h3 id="标记整理算法"><a class="headerlink" href="#标记整理算法"></a> 标记整理算法</h3><p>复制收集算法在对象存活率较高时就要进行较多的复制操作，效率将会变低。更关键的是，如果不想浪费 50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都 100%存活的极端情况，所以在老年代一般不能直接选用这种算法。<br>标记整理算法的标记过程类似标记清除算法，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存，类似于磁盘整理的过程，<strong>该垃圾回收算法适用于对象存活率高的场景（老年代）</strong></p><p>标记整理算法与标记清除算法最显著的区别是：标记清除算法不进行对象的移动，并且仅对不存活的对象进行处理；而标记整理算法会将所有的存活对象移动到一端，并对不存活对象进行处理，因此其不会产生内存碎片。</p><h3 id="分代收集算法"><a class="headerlink" href="#分代收集算法"></a> 分代收集算法</h3><p>分代收集算法是基于这样一个事实： <strong>不同的对象的生命周期(存活情况)是不一样的，而不同生命周期的对象位于堆中不同的区域，因此对堆内存不同区域采用不同的策略进行回收可以提高 JVM 的执行效率。</strong><br>当代商用虚拟机使用的都是分代收集算法：<strong>新生代对象存活率低，就采用复制算法；老年代存活率高，就用标记清除算法或者标记整理算法。</strong></p><h4 id="新生代young-generation"><a class="headerlink" href="#新生代young-generation"></a> 新生代（Young Generation）</h4><p>新生代的目标就是尽可能快速的收集掉那些生命周期短的对象，一般情况下，所有新生成的对象首先都是放在新生代的。新生代内存按照 8:1:1 的比例分为一个 eden 区和两个 survivor(survivor0，survivor1)区，大部分对象在 Eden 区中生成。在进行垃圾回收时，先将 eden 区存活对象复制到 survivor0 区，然后清空 eden 区，当这个 survivor0 区也满了时，则将 eden 区和 survivor0 区存活对象复制到 survivor1 区，然后清空 eden 和这个 survivor0 区，此时 survivor0 区是空的，然后交换 survivor0 区和 survivor1 区的角色（即下次垃圾回收时会扫描 Eden 区和 survivor1 区），即保持 survivor0 区为空，如此往复。特别地，当 survivor1 区也不足以存放 eden 区和 survivor0 区的存活对象时，就将存活对象直接存放到老年代。如果老年代也满了，就会触发一次 FullGC，也就是新生代、老年代都进行回收。</p><p>注意，新生代发生的 GC 也叫做 MinorGC，MinorGC 发生频率比较高，不一定等 Eden 区满了才触发。</p><h4 id="老年代old-generation"><a class="headerlink" href="#老年代old-generation"></a> 老年代（Old Generation）</h4><p>老年代存放的都是一些生命周期较长的对象，就像上面所叙述的那样，在新生代中经历了 N 次垃圾回收后仍然存活的对象就会被放到老年代中。此外，老年代的内存也比新生代大很多(大概比例是 2:1)，当老年代满时会触发 Major GC(Full GC)，老年代对象存活时间比较长，因此 FullGC 发生的频率比较低。<br>导致 Full GC 的原因包括：老年代被写满、永久代（Perm）被写满和 System.gc()被显式调用等。</p><h4 id="永久代permanent-generation"><a class="headerlink" href="#永久代permanent-generation"></a> <s>永久代（Permanent Generation）</s></h4><p>永久代主要用于存放静态文件，如 Java 类、方法等。永久代对垃圾回收没有显著影响，但是有些应用可能动态生成或者调用一些 class，例如使用反射、动态代理、CGLib 等 bytecode 框架时，在这种时候需要设置一个比较大的永久代空间来存放这些运行过程中新增的类。</p><blockquote><p>在 jdk1.8 中 永久代被 Metaspace 取代。元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。</p></blockquote><hr><h2 id="垃圾收集器"><a class="headerlink" href="#垃圾收集器"></a> 垃圾收集器</h2><blockquote><p>如果说垃圾收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。</p></blockquote><center><p><img src="https://i.loli.net/2018/08/31/5b88c4db449d9.jpg" alt="垃圾收集器.jpg"><span class="image-caption">垃圾收集器.jpg</span></p></center><p></p><h3 id="新生代收集器"><a class="headerlink" href="#新生代收集器"></a> 新生代收集器</h3><ul><li><p>Serial 收集器（复制算法): <strong>新生代单线程收集器</strong>，在进行垃圾回收的时候仅使用单条线程并且在回收的过程中会挂起所有的用户线程(Stop The World)。Serial 收集器是 JVM client 模式下默认的新生代收集器；</p></li><li><p>ParNew 收集器 (复制算法):<strong>新生代收并行集器</strong>，实际上是 Serial 收集器的多线程版本，在多核 CPU 环境下有着比 Serial 更好的表现；</p></li><li><p>Parallel Scavenge 收集器 (复制算法): <strong>新生代并行收集器</strong>，追求高吞吐量，高效利用 CPU。吞吐量 = 用户线程时间/(用户线程时间+GC 线程时间)，高吞吐量可以高效率的利用 CPU 时间，尽快完成程序的运算任务，适合后台应用等对交互相应要求不高的场景；</p></li></ul><h3 id="老年代收集器"><a class="headerlink" href="#老年代收集器"></a> 老年代收集器</h3><ul><li><p>Serial Old 收集器 (标记-整理算法): <strong>老年代单线程收集器</strong>，采用单线程和标记-整理算法来实现垃圾回收。在回收垃圾的时候同样会挂起所有用户线程，造成应用的停顿。一般来说，老年代的容量都比新生代要大，所以当发生老年代的垃圾回收时，STW 经历的时间会比新生代所用的时间长得多。该收集器是 JVM client 模式下默认的老年代收集器。</p></li><li><p>Parallel Old 收集器 (标记-整理算法)：<strong>老年代并行收集器</strong>，吞吐量优先，Parallel Scavenge 收集器的老年代版本；</p></li><li><p>CMS(Concurrent Mark Sweep)收集器（标记-清除算法）：<strong>老年代并行收集器</strong>，以获取最短回收停顿时间为目标的收集器，具有高并发、低停顿的特点，追求最短 GC 回收停顿时间。MS 收集器以获取最短回收停顿时间为目标，采用多线程并发以及标记-清除算法来实现垃圾回收。CMS 只在初始化标记和重新标记阶段需要挂起用户线程,造成一定的应用停顿(STW)，而其他阶段收集线程都可以与用户线程并发交替进行，不必挂起用户线程，所以并不会造成应用的停顿。CMS 收集器可以最大程度地减少因垃圾回收而造成应用停顿的时间。<br><img src="https://i.loli.net/2018/09/16/5b9e6ea354024.png" alt="show-cms-collector.png"><span class="image-caption">show-cms-collector.png</span><br>CMS 垃圾收集分为以下几个阶段：</p><ol><li>初始化标记 (inital mark)<br>这个阶段仅仅是标记了 GC Roots 能够直接关联到的对象，速度很快，所以基本上感受不到 STW 带来的停顿。</li><li>并发标记 (concurrent mark)<br>并发标记阶段完成的任务是从第一阶段收集到的对象引用开始，遍历所有其他的对象引用，并标记所有需要回收的对象。这个阶段，收集线程与用户线程并发交替执行，不必挂起用户线程，所以并不会造成应用停顿。</li><li>并发预清除 (concurrent-pre-clean)<br>并发预清除阶段是为了下一个阶段做准备，为的是尽量减少应用停顿的时间。</li><li>重新标记 (remark)<br>这个阶段将会修正并发标记期间因为用户程序继续运作而导致标记产生变动的那部分对象的标记记录(有可能对象重新被引用或者新对象可以被回收)。这个阶段的停顿时间比初始标记阶段要长一些，但是远比并发标记的时间短。</li><li>并发清除 (concurrent sweep)<br>这个阶段将真正执行垃圾回收，将那些不被使用的对象内存回收掉。</li><li>并发重置 (concurrent reset)<br>收集器做一些收尾的工作，以便下一次 GC 周期能有一个干净的状态。</li></ol></li><li><p>G1(Garbage First)收集器 (标记-整理算法)：<strong>Java 堆并行收集器</strong>，G1 收集器是 JDK1.7 提供的一个新收集器，G1 收集器基于“标记-整理”算法实现，也就是说不会产生内存碎片。此外，G1 收集器不同于之前的收集器的一个重要特点是：G1 回收的范围是整个 Java 堆(包括新生代，老年代)，而前六种收集器回收的范围仅限于新生代或老年代。</p></li></ul><hr><h2 id="内存分配与回收策略"><a class="headerlink" href="#内存分配与回收策略"></a> 内存分配与回收策略</h2><ul><li>对象优先在 Eden 分配，当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 MinorGC。</li><li>大对象直接进入老年代。<br>所谓的大对象是指，需要大量连续内存空间的 Java 对象，最典型的大对象就是那种很长的字符串以及数组。</li><li>长期存活的对象将进入老年代。<br>当对象在新生代中经历过一定次数（默认为 15）的 Minor GC 后，就会被晋升到老年代中。</li><li>动态对象年龄判定。<br>为了更好地适应不同程序的内存状况，虚拟机并不是永远地要求对象年龄必须达到了 MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 空间中相同年龄所有对象大小的总和大于 Survivor 空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到 MaxTenuringThreshold 中要求的年龄。</li></ul><hr><h2 id="java-中的内存泄露问题"><a class="headerlink" href="#java-中的内存泄露问题"></a> Java 中的内存泄露问题</h2><p>虽然 Java 拥有垃圾回收机制，但同样会出现内存泄露问题，比如下面提到的几种情况：</p><ul><li>诸如 HashMap、Vector 等集合类的静态使用最容易出现内存泄露，因为这些静态变量的生命周期和应用程序一致，所有的对象 Object 也不能被释放，因为他们也将一直被 Vector 等应用着。</li><li>各种资源连接包括数据库连接、网络连接、IO 连接等没有显式调用 close 关闭，不被 GC 回收导致内存泄露。</li><li>监听器的使用，在释放对象的同时没有相应删除监听器的时候也可能导致内存泄露。</li></ul><hr><h2 id="引用的种类及其定义"><a class="headerlink" href="#引用的种类及其定义"></a> 引用的种类及其定义</h2><ul><li><p>强引用(StrongReference)<br>如果一个对象具有强引用，那么垃圾回收器绝对不会回收它，当内存不足时宁愿抛出 OOM 错误，使得程序异常停止。</p></li><li><p>软引用(SoftReference)<br>如果一个对象只具有软引用，那么垃圾回收器在内存充足的时候不会回收它，而在内存不足时会回收这些对象。软引用对象被回收后，Java 虚拟机会把这个软引用加入到与之关联的引用队列中。</p></li><li><p>弱引用(WeakReference)<br>如果一个对象只具有弱引用，那么垃圾回收器在扫描到该对象时，无论内存充足与否，都会回收该对象的内存。与软引用相同，弱引用对象被回收后，Java 虚拟机会把这个弱引用加入到与之关联的引用队列中。</p></li><li><p>虚引用(PhantomReference)<br>虚引用并不决定对象生命周期，如果一个对象只具有虚引用，那么它和没有任何引用一样，任何时候都可能被回收。虚引用主要用来跟踪对象被垃圾回收器回收的活动。与软引用和弱引用不同的是，虚引用必须关联一个引用队列。</p><p>当垃圾回收器准备回收一个对象之前，如果发现它还具有虚引用，就会在对象回收前把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否加入了虚引用，来了解被引用的对象是否将要被回收，那么就可以在其被回收之前采取必要的行动。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 软引用</span></span><br><span class="line">SoftReference&lt;Person&gt; person0 = <span class="keyword">new</span> SoftReference&lt;Person&gt;(<span class="keyword">new</span> Person(<span class="string">"name"</span>));</span><br><span class="line"><span class="comment">// 弱引用</span></span><br><span class="line">WeakReference&lt;Person&gt; person1 = <span class="keyword">new</span> WeakReference&lt;Person&gt;(<span class="keyword">new</span> Person(<span class="string">"name"</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需引用</span></span><br><span class="line">Person person = <span class="keyword">new</span> Person(<span class="string">"nameTest"</span>, <span class="number">5</span>);</span><br><span class="line">ReferenceQueue&lt;Person&gt; rfq = <span class="keyword">new</span> ReferenceQueue&lt;Person&gt;();</span><br><span class="line">PhantomReference&lt;Person&gt; pph = <span class="keyword">new</span> PhantomReference&lt;Person&gt;(person, rfq);</span><br></pre></td></tr></table></figure><hr><h2 id="方法区的回收"><a class="headerlink" href="#方法区的回收"></a> 方法区的回收</h2><p>方法区的内存回收目标主要是针对 常量池的回收 和 对类型的卸载。回收废弃常量与回收 Java 堆中的对象非常类似。以常量池中字面量的回收为例，假如一个字符串“abc”已经进入了常量池中，但是当前系统没有任何一个 String 对象是叫做“abc”的，换句话说是没有任何 String 对象引用常量池中的“abc”常量，也没有其他地方引用了这个字面量，如果在这时候发生内存回收，而且必要的话，这个“abc”常量就会被系统“请”出常量池。常量池中的其他类（接口）、方法、字段的符号引用也与此类似。</p><p>判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要同时满足下面 3 个条件才能算是“无用的类”：</p><ol><li>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例；</li><li>加载该类的 ClassLoader 已经被回收；</li><li>该类对应的 <code>java.lang.Class</code> 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li></ol><p>虚拟机可以对满足上述 3 个条件的无用类进行回收(卸载)，这里说的仅仅是“可以”，而不是和对象一样，不使用了就必然会回收。特别地，在大量使用反射、动态代理、CGLib 等 bytecode 框架的场景，以及动态生成 JSP 和 OSGi 这类频繁自定义 ClassLoader 的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出。</p><hr><blockquote><p>引用：<a href="https://blog.csdn.net/justloveyou_" target="_blank" rel="noopener">https://blog.csdn.net/justloveyou_</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> dev </category>
          
          <category> java </category>
          
          <category> jvm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM[3]-类生命周期:加载时机与加载过程</title>
      <link href="/2018/08/30/JVM-3/"/>
      <url>/2018/08/30/JVM-3/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a class="headerlink" href="#概述"></a> 概述</h2><blockquote><p>虚拟机把描述类的数据从 Class 文件加载到内存，并对数据进行校验，转换解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型的过程就是虚拟机的 类加载机制。</p></blockquote><blockquote><p>在 Java 语言里面，类型的加载和连接都是在程序运行期间完成，这样会在类加载时稍微增加一些性能开销，但是却能为 Java 应用程序提供高度的灵活性，Java 中天生可以动态扩展的语言特性多态就是依赖运行期动态加载和动态链接这个特点实现的。</p></blockquote><hr><h2 id="类加载的时机"><a class="headerlink" href="#类加载的时机"></a> 类加载的时机</h2><center><p><img src="https://i.loli.net/2018/08/30/5b87e22331327.jpg" alt="类加载过程.jpg"><span class="image-caption">类加载过程.jpg</span></p></center><p></p><blockquote><p>加载、验证、准备、初始化和卸载这 5 个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班地开始，而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持 Java 语言的运行时绑定（也称为动态绑定或晚期绑定）。</p></blockquote><h3 id="类加载时机"><a class="headerlink" href="#类加载时机"></a> 类加载时机</h3><p>虚拟机规范中并没有对此进行强制约束，这点可以交给虚拟机的具体实现来自由把握。</p><h3 id="类初始化时机"><a class="headerlink" href="#类初始化时机"></a> 类初始化时机</h3><p>虚拟机规范指明 有且只有 五种情况必须立即对类进行初始化（而这一过程自然发生在加载、验证、准备之后）：</p><ol><li>遇到<code>new</code>、<code>getstatic</code>、<code>putstatic</code>或<code>invokestatic</code>这四条字节码指令（注意，newarray 指令触发的只是数组类型本身的初始化，而不会导致其相关类型的初始化，比如，<code>new String[]</code>只会直接触发 String[]类的初始化，也就是触发对类<code>Ljava.lang.String</code>的初始化，而直接不会触发 String 类的初始化）时，如果类没有进行过初始化，则需要先对其进行初始化。生成这四条指令的最常见的 Java 代码场景是：</li></ol><ul><li>使用 new 关键字实例化对象的时候；</li><li>读取或设置一个类的静态字段（被 final 修饰，已在编译器把结果放入常量池的静态字段除外）的时候；</li><li>调用一个类的静态方法的时候。</li></ul><ol start="2"><li>使用<code>java.lang.reflect</code>包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。</li><li>当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</li><li>当虚拟机启动时，用户需要指定一个要执行的主类（包含<code>main()</code>方法的那个类），虚拟机会先初始化这个主类。</li><li>当使用 jdk1.7 动态语言支持时，如果一个<code>java.lang.invoke.MethodHandle</code>实例最后的解析结果 REF_getstatic,REF_putstatic,REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行初始化，则需要先出触发其初始化。</li></ol><p><strong>注意</strong>，对于这五种会触发类进行初始化的场景，虚拟机规范中使用了一个很强烈的限定语：“有且只有”，这五种场景中的行为称为对一个类进行 <strong>主动引用</strong>。除此之外，所有引用类的方式，都不会触发初始化，称为 <strong>被动引用</strong>。</p><h3 id="被动引用的几种经典场景"><a class="headerlink" href="#被动引用的几种经典场景"></a> 被动引用的几种经典场景</h3><ol><li><p>通过子类引用父类的静态字段，不会导致子类初始化<br>对于静态字段，只有直接定义这个字段的类才会被初始化，因此通过其子类来引用父类中定义的静态字段，只会触发父类的初始化而不会触发子类的初始化。</p></li><li><p>通过数组定义来引用类，不会触发此类的初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotInitialization</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">      SClass[] sca = <span class="keyword">new</span> SClass[<span class="number">10</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述案例运行之后并没有任何输出，说明虚拟机并没有初始化类 SClass。但是，这段代码触发了另外一个名为<code>Lcn.edu.tju.rico.SClass</code>的类的初始化。从类名称我们可以看出，这个类代表了元素类型为 SClass 的一维数组，它是由虚拟机自动生成的，直接继承于 Object 的子类，创建动作由字节码指令 newarray 触发。</p></li><li><p>常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstClass</span></span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">static</span>&#123;</span><br><span class="line">     System.out.println(<span class="string">"ConstClass init!"</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">final</span> String CONSTANT = <span class="string">"hello world"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotInitialization</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(ConstClass.CONSTANT);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><hr><h2 id="类加载过程"><a class="headerlink" href="#类加载过程"></a> 类加载过程</h2><h3 id="加载loading"><a class="headerlink" href="#加载loading"></a> 加载（Loading）</h3><p>在加载阶段（可以参考<code>java.lang.ClassLoader的loadClass()</code>方法），虚拟机需要完成以下三件事情：</p><ol><li>通过一个类的全限定名来获取定义此类的二进制字节流（并没有指明要从一个 Class 文件中获取，可以从其他渠道，譬如：网络、动态生成、数据库等）；</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构；</li><li>在内存中(对于 HotSpot 虚拟就而言就是方法区)生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口；</li></ol><h3 id="验证verification"><a class="headerlink" href="#验证verification"></a> 验证（Verification）</h3><p>验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响。</p><h3 id="准备preparation"><a class="headerlink" href="#准备preparation"></a> 准备(Preparation)</h3><p>准备阶段是正式为类变量(static 成员变量)分配内存并设置类变量初始值（零值）的阶段，这些变量所使用的内存都将在方法区中进行分配。这时候进行内存分配的仅包括类变量，而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在堆中。</p><h3 id="解析resolution"><a class="headerlink" href="#解析resolution"></a> 解析(Resolution)</h3><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符 7 类符号引用进行。</p><h3 id="初始化initialization"><a class="headerlink" href="#初始化initialization"></a> 初始化(Initialization)</h3><p>在准备阶段，变量已经赋过一次系统要求的初始值(零值)；而在初始化阶段，则根据开发者通过程序制定的主观计划去初始化类变量和其他资源，或者更直接地说：初始化阶段是执行类构造器<code>&lt;clinit&gt;()</code>方法的过程。<code>&lt;clinit&gt;()</code>方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块<code>static{}</code>中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态语句块只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问。</p><p>类构造器<code>&lt;clinit&gt;()</code>与实例构造器<code>&lt;init&gt;()</code>不同，它不需要程序员进行显式调用，虚拟机会保证在子类类构造器<code>&lt;clinit&gt;()</code>执行之前，父类的类构造<code>&lt;clinit&gt;()</code>执行完毕。由于父类的构造器<code>&lt;clinit&gt;()</code>先执行，也就意味着父类中定义的静态语句块/静态变量的初始化要优先于子类的静态语句块/静态变量的初始化执行。特别地，类构造器<code>&lt;clinit&gt;()</code>对于类或者接口来说并不是必需的，如果一个类中没有静态语句块，也没有对类变量的赋值操作，那么编译器可以不为这个类生产类构造器<code>&lt;clinit&gt;()</code>。</p><blockquote><p>虚拟机会保证一个类的类构造器<code>&lt;clinit&gt;()</code>在多线程环境中被正确的加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的类构造器<code>&lt;clinit&gt;()</code>，其他线程都需要阻塞等待，直到活动线程执行<code>&lt;clinit&gt;()</code>方法完毕。</p></blockquote><blockquote><p>在同一个类加载器下，一个类型只会被初始化一次。</p></blockquote><p>类加载顺序</p><blockquote><p>父类的类构造器<code>&lt;clinit&gt;()</code> -&gt; 子类的类构造器<code>&lt;clinit&gt;()</code> -&gt; 父类的成员变量和实例代码块 -&gt; 父类的构造函数 -&gt; 子类的成员变量和实例代码块 -&gt; 子类的构造函数。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        staticFunction();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> StaticTest st = <span class="keyword">new</span> StaticTest();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;   <span class="comment">//静态代码块</span></span><br><span class="line">        System.out.println(<span class="string">"1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;       <span class="comment">// 实例代码块</span></span><br><span class="line">        System.out.println(<span class="string">"2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    StaticTest() &#123;    <span class="comment">// 实例构造器</span></span><br><span class="line">        System.out.println(<span class="string">"3"</span>);</span><br><span class="line">        System.out.println(<span class="string">"a="</span> + a + <span class="string">",b="</span> + b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">staticFunction</span><span class="params">()</span> </span>&#123;   <span class="comment">// 静态方法</span></span><br><span class="line">        System.out.println(<span class="string">"4"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">110</span>;    <span class="comment">// 实例变量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> b = <span class="number">112</span>;     <span class="comment">// 静态变量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">    2</span></span><br><span class="line"><span class="comment">    3</span></span><br><span class="line"><span class="comment">    a=110,b=0</span></span><br><span class="line"><span class="comment">    1</span></span><br><span class="line"><span class="comment">    4</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><hr><blockquote><p>引用：<a href="https://blog.csdn.net/justloveyou_" target="_blank" rel="noopener">https://blog.csdn.net/justloveyou_</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> dev </category>
          
          <category> java </category>
          
          <category> jvm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM[2]-类的初始化与实例化</title>
      <link href="/2018/08/30/JVM-2/"/>
      <url>/2018/08/30/JVM-2/</url>
      
        <content type="html"><![CDATA[<h2 id="前置"><a class="headerlink" href="#前置"></a> 前置</h2><p><a href="https://theembers.gitee.io/2018/08/29/JVM-1/" target="_blank" rel="noopener">JVM[1]-对象创建-基础</a></p><hr><h2 id="java-对象创建时机"><a class="headerlink" href="#java-对象创建时机"></a> Java 对象创建时机</h2><h3 id="由执行类实例创建表达式而引起的对象创建-new-关键字"><a class="headerlink" href="#由执行类实例创建表达式而引起的对象创建-new-关键字"></a> 由执行类实例创建表达式而引起的对象创建 (new 关键字)</h3><p>通过 new 关键词 调用对象类的构造函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Info info = <span class="keyword">new</span> Info();</span><br></pre></td></tr></table></figure><h3 id="反射机制"><a class="headerlink" href="#反射机制"></a> 反射机制</h3><ul><li>使用 Class 类的 newInstance 方法</li></ul><p>通过 Java 的反射机制使用 Class 类的 newInstance 方法来创建对象，<strong>事实上这个 newInstance 方法调用无参的构造器创建对象</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据类的限定名</span></span><br><span class="line">Info info = (Info)Class.forName(<span class="string">"com.xxx.Info"</span>).newInstance();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">Info info2 = Info.class.newInstance();</span><br></pre></td></tr></table></figure><ul><li>使用 Constructor 类的 newInstance 方法</li></ul><p><code>java.lang.relect.Constructor</code> 类里也有一个 newInstance 方法可以创建对象，该方法和 Class 类中的 newInstance 方法很像，但是相比之下 Constructor 类的 newInstance 方法更加强大，<strong>我们可以通过这个 newInstance 方法调用有参数的和私有的构造函数</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实例一个 参数为integer的有参构造函数</span></span><br><span class="line">Constructor&lt;Info&gt; constructor = Info.class.getConstructor(Integer.class);</span><br><span class="line">Info info3 = constructor.newInstance(<span class="number">123</span>);</span><br></pre></td></tr></table></figure><blockquote><p>事实上 Class 的 newInstance 方法内部调用的也是 Constructor 的 newInstance 方法</p></blockquote><h3 id="使用-clone-方法创建对象"><a class="headerlink" href="#使用-clone-方法创建对象"></a> 使用 Clone 方法创建对象</h3><p>要想使用 clone 方法，必须先实现 Cloneable 接口并实现其定义的 clone 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 先通过其他方法创建一个对象实例</span></span><br><span class="line">        Student stu3 = constructor.newInstance(<span class="number">123</span>);</span><br><span class="line">        <span class="comment">// 根据已有的对象实例 clone</span></span><br><span class="line">        Student stu4 = (Student) stu3.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用反序列化机制创建对象"><a class="headerlink" href="#使用反序列化机制创建对象"></a> 使用(反)序列化机制创建对象</h3><p>反序列化一个对象，需要类实现 Serializable 接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Constructor&lt;Student&gt; constructor = Student.class.getConstructor(Integer.class);</span><br><span class="line">        Student stu3 = constructor.newInstance(<span class="number">123</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 写对象</span></span><br><span class="line">        ObjectOutputStream output = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"student.bin"</span>));</span><br><span class="line">        output.writeObject(stu3);</span><br><span class="line">        output.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读对象</span></span><br><span class="line">        ObjectInputStream input = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"student.bin"</span>));</span><br><span class="line">        Student stu5 = (Student) input.readObject();</span><br><span class="line">        System.out.println(stu5);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了使用 java 自带的 Serializable 序列化方式以外,还可以通过 json 的方式</p><hr><h2 id="java-对象的创建过程"><a class="headerlink" href="#java-对象的创建过程"></a> Java 对象的创建过程</h2><p>当对象被创建时，虚拟机会为其分配内存来存放对象自己的实例变量及其从父类继承过来的实例变量(即使这些从超类继承过来的实例变量有可能被隐藏也会被分配空间) 在为这些实例变量分配内存的同时，这些实例变量也会被赋予默认值(零值)。<br>在内存分配完成之后，Java 虚拟机就会开始对新创建的对象按照程序设计者的意志进行初始化。在 Java 对象初始化过程中，主要涉及三种执行对象初始化的结构，分别是 实例变量初始化、实例代码块初始化 以及 构造函数初始化。</p><h3 id="实例变量初始化与实例代码块初始化"><a class="headerlink" href="#实例变量初始化与实例代码块初始化"></a> 实例变量初始化与实例代码块初始化</h3><p>在定义（声明）实例变量的同时，还可以直接对实例变量进行赋值或者使用实例代码块对其进行赋值。<br>如果以这两种方式为实例变量进行初始化，那么它们将 <strong>在构造函数执行之前完成</strong> 这些初始化操作。</p><blockquote><p>实际上，如果我们对实例变量直接赋值或者使用实例代码块赋值，那么编译器会将其中的代码放到类的构造函数中去，并且这些代码会被放在对超类构造函数的调用语句之后，构造函数本身的代码之前。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstanceVariableInitializer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> j = i + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InstanceVariableInitializer</span><span class="params">(<span class="keyword">int</span> var)</span></span>&#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">        System.out.println(j);</span><br><span class="line">        <span class="keyword">this</span>.i = var;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">        System.out.println(j);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实例代码块</span></span><br><span class="line">    &#123;</span><br><span class="line">        j += <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> InstanceVariableInitializer(<span class="number">8</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 输出： 1 5 8 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上边的代码相当于：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstanceVariableInitializer</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化0值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InstanceVariableInitializer</span><span class="params">(<span class="keyword">int</span> var)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 直接赋值</span></span><br><span class="line">        <span class="keyword">this</span>.i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">this</span>.j = i + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 执行 实例代码块</span></span><br><span class="line">        <span class="keyword">this</span>.j += <span class="number">3</span>;</span><br><span class="line">        <span class="comment">// 构造函数</span></span><br><span class="line">        System.out.println(i);</span><br><span class="line">        System.out.println(j);</span><br><span class="line">        <span class="keyword">this</span>.i = var;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">        System.out.println(j);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> InstanceVariableInitializer(<span class="number">8</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 输出： 1 5 8 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>需要注意的是，Java 是按照编程顺序来执行实例变量初始化器和实例初始化器中的代码的，并且不允许顺序靠前的实例代码块初始化在其后面定义的实例变量</p></blockquote><h3 id="构造函数初始化"><a class="headerlink" href="#构造函数初始化"></a> 构造函数初始化</h3><p>Java 中的对象都至少会有一个构造函数，如果我们没有显式定义构造函数，那么它将会有一个默认无参的构造函数。在编译生成的字节码中，这些构造函数会被命名成<init>()方法，参数列表与 Java 语言书写的构造函数的参数列表相同。</init></p><p>Java要求 <strong>在实例化类之前，必须先实例化其超类，以保证所创建实例的完整性。</strong> 这一点是在构造函数中保证的：<br>Java强制要求Object对象(Object是Java的顶层对象，没有超类)之外的所有对象构造函数的第一条语句必须是超类构造函数的调用语句或者是类中定义的其他的构造函数，如果我们既没有调用其他的构造函数，也没有显式调用超类的构造函数，那么编译器会为我们自动生成一个对超类构造函数的调用。</p><hr><h3 id="总结"><a class="headerlink" href="#总结"></a> 总结</h3><ul><li>实例化一个类的对象的过程是一个典型的递归过程。初始化一个对象先初始化其父类，直至Object对象</li><li>初始化顺序遵循：先依次执行实例变量初始化和实例代码块初始化，再执行构造函数初始化。</li></ul><hr><blockquote><p>引用：<a href="https://blog.csdn.net/justloveyou_" target="_blank" rel="noopener">https://blog.csdn.net/justloveyou_</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> dev </category>
          
          <category> java </category>
          
          <category> jvm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM[1]-对象创建-基础</title>
      <link href="/2018/08/29/JVM-1/"/>
      <url>/2018/08/29/JVM-1/</url>
      
        <content type="html"><![CDATA[<h2 id="过程"><a class="headerlink" href="#过程"></a> 过程</h2><center><p><img src="https://i.loli.net/2018/08/30/5b875ffc9c7a5.png" alt="检查类加载过程.png"><span class="image-caption">检查类加载过程.png</span></p></center><p></p><h3 id="检查类加载"><a class="headerlink" href="#检查类加载"></a> 检查类加载</h3><p>检查虚拟机是否加载了所要 new 的类，若没加载，则首先执行相应的类加载过程。虚拟机遇到 new 指令时，首先去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个引用代表的类是否已经被加载、解析和初始化过。</p><h3 id="内存分配"><a class="headerlink" href="#内存分配"></a> 内存分配</h3><p>在类加载检查通过后，对象所需内存的大小在类加载完成后便可完全确定，虚拟机就会为新生对象分配内存。一般来说，根据 Java 堆中内存是否绝对规整，内存的分配有两种方式：</p><ul><li><strong>指针碰撞</strong>：如果 Java 堆中内存绝对规整，所有用过的内存放在一边，空闲内存放在另一边，中间一个指针作为分界点的指示器，那分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相同的距离。</li><li><strong>空闲列表</strong>：如果 Java 堆中内存并不规整，那么虚拟机就需要维护一个列表，记录哪些内存块是可用的，以便在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录。</li></ul><p>除了如何划分可用空间之外，还需要考虑修改指针 (该指针用于划分内存使用空间和空闲空间)时的线程安全问题，因为存在可能出现正在给对象 A 分配内存，指针还未修改，对象 B 又同时使用原来的指针分配内存的情况。解决这个问题有两种方案：</p><ul><li>对分配内存空间的动作进行同步处理：采用 CAS+失败重试的方式保证更新操作的原子性；</li><li>把内存分配的动作按照线程划分的不同的空间中：每个线程在 Java 堆中预先分配一小块内存，称为本地线程分配缓冲（TLAB），哪个线程要分配内存，就在自己的 TLAB 上分配，如果 TLAB 用完并分配新的 TLAB 时，再加同步锁定。</li></ul><h3 id="内存空间初始化"><a class="headerlink" href="#内存空间初始化"></a> 内存空间初始化</h3><p>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值。如果使用 TLAB，也可以提前到 TLAB 分配时进行。这一步操作保证了对象的实例字段在 Java 代码中可以不赋初值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</p><h3 id="init方法执行"><a class="headerlink" href="#init方法执行"></a> <code>&lt;init&gt;</code>方法执行</h3><p>在上面的工作完成之后，从虚拟机的角度来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象的创建才刚刚开始，此时会执行<code>&lt;init&gt;</code>方法把对象按照程序员的意愿进行初始化，从而产生一个真正可用的对象。</p><hr><h2 id="访问定位"><a class="headerlink" href="#访问定位"></a> 访问定位</h2><p>创建对象是为了使用对象，我们的 Java 程序通过栈上的 reference 数据来操作堆上的具体对象。在虚拟机规范中，reference 类型中只规定了一个指向对象的引用，并没有定义这个引用使用什么方式去定位、访问堆中的对象的具体位置。目前的主流的访问方式有使用句柄访问和直接指针访问两种。</p><ul><li><strong>句柄访问</strong>：Java 堆中会划分出一块内存作为句柄池，栈中的 reference 指向对象的句柄地址，句柄中包含了对象实例数据和类型数据各自的具体地址信息。</li><li><strong>直接指针访问</strong>：reference 中存储的就是对象地址。</li></ul><p>总的来说，这两种对象访问定位方式各有千秋。<br>使用句柄访问的最大好处就是 reference 中存储的是稳定的句柄地址，对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，reference 本身不需要修改；<br>而使用直接指针访问的最大好处就是速度快，节省了一次指针定位的时间开销。</p><hr><blockquote><p>引用：<a href="https://blog.csdn.net/justloveyou_" target="_blank" rel="noopener">https://blog.csdn.net/justloveyou_</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> dev </category>
          
          <category> java </category>
          
          <category> jvm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM[0]-运行时数据区</title>
      <link href="/2018/08/27/JVM-0/"/>
      <url>/2018/08/27/JVM-0/</url>
      
        <content type="html"><![CDATA[<h2 id="jvm-运行时数据区"><a class="headerlink" href="#jvm-运行时数据区"></a> JVM 运行时数据区</h2><center><p><img src="/2018/08/27/JVM-0/1.png" alt="JVM-memory"><span class="image-caption">JVM-memory</span></p></center><p></p><h3 id="程序计数器"><a class="headerlink" href="#程序计数器"></a> 程序计数器</h3><p>线程私有 作用是标示下一条需要执行的指令的位置，分支、循环、跳转、异常处理、线程恢复等基础功能都是依赖程序计数器完成</p><p>如果线程正在执行的是一个 java 方法,这个计数器记录的是正在执行的虚拟机字节码指令地址;如果真正执行的是一个 native 方法,这个计数器值则为空(undifined)</p><p>此区域是 Java 虚拟机规范中没有规定任何 OutOfMenoryError 情况的区域</p><h3 id="java-虚拟机栈"><a class="headerlink" href="#java-虚拟机栈"></a> java 虚拟机栈</h3><p>线程私有 生命周期与线程一致 描述的是 java 方法执行的内存模型: 每个方法在执行的同时都会创建一个栈帧(stack frame) 用于存储 局部变量表;操作数栈;动态链接;方法出口等信息</p><p>每个方法的执行过程就对应着一个栈帧在虚拟机中入栈出栈的过程</p><h4 id="局部变量表"><a class="headerlink" href="#局部变量表"></a> 局部变量表</h4><p>局部变量表 存放各种基本数据类型(boolean byte char short int long float double)和对象引用(reference 类型)还有 returnAddress 类型(指向一条字节码指令的地址)</p><p>局部变量表所需的内存空间在编译期间完成分配,在方法运行期间不会改变局部变量表的大小</p><p>当线程请求的栈深度大于虚拟机所允许的深度,将抛出 StackOverflowError 异常;<br>当可拓展的虚拟机栈无法申请到足够的内存时 抛出 OutOfMemoryError 异常</p><h3 id="本地方法栈"><a class="headerlink" href="#本地方法栈"></a> 本地方法栈</h3><p>作用类似于虚拟机栈</p><h3 id="java-堆"><a class="headerlink" href="#java-堆"></a> Java 堆</h3><p>所有线程共享的内存区域 在 jvm 启动时创建 用于存放几乎所有的对象(几乎:JIT 技术的发展,栈上分配,标量替换等等)和数组对象</p><p>GC 的主要区域 从内存回收的角度来看,java 堆可以细分为新生代/老生代;再细分有 eden 空间/from survivor/to survivor/</p><p><code>-Xmx</code> <code>-Xms</code><br>抛出 OutOfMemoryError 异常</p><h3 id="方法区"><a class="headerlink" href="#方法区"></a> 方法区</h3><p>所有线程共享的内存区域 存放加载的类信息/常量/静态变量/即时编译器编译的代码等数据<br>所谓&quot;永久代&quot;</p><p>抛出 OutOfMemoryError 异常</p><h3 id="运行时常量池"><a class="headerlink" href="#运行时常量池"></a> 运行时常量池</h3><p>方法区的一部分 Class 文件除了类的版本/字段/方法/接口等描述信息外,还有一些常量池,用于存放编译期生成的各种字面变量和符号引用 在类加载后进入方法区的运行时常量池存放</p><p>动态性 可以在运行期间加入新的常量(String intern()方法)</p><p>抛出 OutOfMemoryError 异常</p><h3 id="直接内存"><a class="headerlink" href="#直接内存"></a> 直接内存</h3><p>虚拟机以外的数据区<br>Channel NIO Buffer 通过 native 函数调用堆外内存</p><p>抛出 OutOfMemoryError 异常</p>]]></content>
      
      
      <categories>
          
          <category> dev </category>
          
          <category> java </category>
          
          <category> jvm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-静态代理/jdk动态代理/cglib动态代理</title>
      <link href="/2018/08/21/java-proxy/"/>
      <url>/2018/08/21/java-proxy/</url>
      
        <content type="html"><![CDATA[<h1 id="代理模式"><a class="headerlink" href="#代理模式"></a> 代理模式</h1><h2 id="定义"><a class="headerlink" href="#定义"></a> 定义</h2><p>给目标对象提供一个代理对象,并由代理对象控制对目标对象的引用</p><h2 id="意义"><a class="headerlink" href="#意义"></a> 意义</h2><p>通过引入代理对象的方式来间接访问目标对象,防止直接访问目标对象给系统带来的不必要复杂性</p><h1 id="实现"><a class="headerlink" href="#实现"></a> 实现</h1><h2 id="静态代理"><a class="headerlink" href="#静态代理"></a> 静态代理</h2><p>静态代理由业务实现类/业务代理类两部分组成.</p><ul><li>业务实现类负责实现主要的业务方法.</li><li>业务代理类负责对调用的业务方法作拦截/过滤/等预处理.</li></ul><p>在需要调用业务时,不是直接通过业务实现类来调用的,而是通过业务代理类的同名方法来调用被处理过的业务方法</p><h3 id="代码实现"><a class="headerlink" href="#代码实现"></a> 代码实现</h3><ol><li>定义业务接口</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IBookStore</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">addBook</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>定义业务实现类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookStoreImpl</span> <span class="keyword">implements</span> <span class="title">IBookStore</span></span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBook</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// dosomething</span></span><br><span class="line">    System.out.println(<span class="string">"add a new book."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>定义业务代理类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookStoreProxy</span> <span class="keyword">implements</span> <span class="title">IBookStore</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> BookStoreImpl bookStoreImpl;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">BookStoreProxy</span><span class="params">(BookStoreImpl bookStoreImpl)</span></span>&#123;</span><br><span class="line">     <span class="keyword">this</span>.bookStoreImpl = bookStoreImpl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBook</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="comment">// do more things before</span></span><br><span class="line">     bookStoreImpl.addBook();</span><br><span class="line">     <span class="comment">// do more things after</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>调用</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    IBookStore bookstore = <span class="keyword">new</span> BookStoreImpl();</span><br><span class="line">    BookStoreProxy proxy = <span class="keyword">new</span> BookStoreProxy(bookstore);</span><br><span class="line">    proxy.addBook();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="缺点"><a class="headerlink" href="#缺点"></a> 缺点</h3><p>静态代理的缺点很明显: 一个代理类只能对一个业务接口的实现类进行包装, 如果有多个业务接口的话就要定义很多实现类和代理类才行. 而且如果代理类对业务方法的预处理/调用后操作都是一样的(比如: 调用前输出提示、调用后自动关闭连接),则多个代理类就会有很多重复代码.<br>这时我们可以定义这样一个代理类, 它能代理所有实现类的方法调用: 根据传进来的业务实现类和方法名进行具体调用. - 这就是动态代理.</p><h2 id="jdk-动态代理"><a class="headerlink" href="#jdk-动态代理"></a> JDK 动态代理</h2><p>JDK 动态代理所用到的代理类在程序调用到代理类对象时才由 JVM 真正创建,JVM 根据传进来的&quot;业务实现类对象&quot;以及&quot;方法名&quot;,动态地创建了一个代理类的 class 文件并被字节码引擎执行,然后通过该代理类对象进行方法调用.<br>我们需要做的只需指定代理类的预处理/调用后操作即可.</p><h3 id="代码实现-2"><a class="headerlink" href="#代码实现-2"></a> 代码实现</h3><ol><li>定义业务接口 (同上)</li><li>定义业务实现类 (同上)</li><li>创建动态代理类 实现 调用管理接口 <code>InvocationHandler</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意 这里假设是实现 book 业务相关的代理,表示相关的处理逻辑 不是作为 bookstore 专属的代理</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 被代理对象</span></span><br><span class="line">  <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 绑定对象 返回代理对象</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">bind</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 参数: ClassLoader loader 加载 被代理类的 类加载器</span></span><br><span class="line">    <span class="comment">// 参数: Class&lt;?&gt;[] interfaces 被代理类 要实现的接口列表</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Proxy.newProxyInstance(target.getClass().getClassLoader(),target.getClass().getInterfaces(), <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 包装调用方法:进行预处理/调用后处理</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    Object result = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// do more things before</span></span><br><span class="line">    result = method.invoke(target, args);</span><br><span class="line">    <span class="comment">// do more things after</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>调用</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  BookStoreImpl bookStoreImpl = <span class="keyword">new</span> BookStoreImpl();</span><br><span class="line">  BookProxy proxy = <span class="keyword">new</span> BookProxy();</span><br><span class="line">  IBookStore bookStore = (IBookStore) proxy.bind(bookStoreImpl);</span><br><span class="line">  bookStore.addBook();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="缺点-2"><a class="headerlink" href="#缺点-2"></a> 缺点</h3><p>JDK 动态代理的代理对象在创建时需要使用业务实现类所实现的接口作为参数.<br>如果业务实现类是没有实现接口而是直接定义业务方法的话, 就无法使用 JDK 动态代理了.<br>而且 如果业务实现类中新增了接口中没有的方法, 这些方法是无法被代理的(因为无法被调用)</p><h2 id="cglib-动态代理"><a class="headerlink" href="#cglib-动态代理"></a> cglib 动态代理</h2><p>cglib 是针对类来实现代理的, 原理是对指定的业务类生成一个子类, 并覆盖其中的业务方法来实现代理. <strong>因为采用的是继承, 所以不能对<code>final</code>修饰的类进行代理.</strong></p><h3 id="代码实现-3"><a class="headerlink" href="#代码实现-3"></a> 代码实现</h3><ol><li>定义业务类 <strong>无需实现接口</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookStoreImpl2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBook</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"BookStoreImpl2.addBook ..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delBook</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"BookStoreImpl2.delBook ..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>创建代理类 实现 <code>MethodInterceptor</code> 方法代理接口</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookCglib</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Object target; <span class="comment">// 业务类对象，供代理方法中进行真正的业务方法调用</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 相当于JDK动态代理中的绑定</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">getInstance</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.target = target;  <span class="comment">// 给业务对象赋值</span></span><br><span class="line">      Enhancer enhancer = <span class="keyword">new</span> Enhancer(); <span class="comment">// 创建加强器，用来创建动态代理类</span></span><br><span class="line">      enhancer.setSuperclass(<span class="keyword">this</span>.target.getClass());  <span class="comment">// 为加强器指定要代理的业务类</span></span><br><span class="line">      <span class="comment">// 设置回调：对于代理类上所有方法的调用，都会调用CallBack，而Callback则需要实现intercept() 方法进行拦截</span></span><br><span class="line">      enhancer.setCallback(<span class="keyword">this</span>);</span><br><span class="line">      <span class="comment">// 创建动态代理类对象并返回</span></span><br><span class="line">      <span class="keyword">return</span> enhancer.create();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">      <span class="comment">// do more things before</span></span><br><span class="line">      methodProxy.invokeSuper(o, objects); <span class="comment">// 调用业务类(父类)的方法</span></span><br><span class="line">      <span class="comment">// do more things after</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>调用</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  BookStoreImpl2 bookStore = <span class="keyword">new</span> BookStoreImpl2()；</span><br><span class="line">  BookCglib cglib = <span class="keyword">new</span> BookCglib();</span><br><span class="line">  BookStoreImpl2 bookStoreCglib = (BookStoreImpl2)cglib.getInstance(bookStore);</span><br><span class="line">  bookStoreCglib.addBook();</span><br><span class="line">  bookStoreCglib.delBook();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="缺点-3"><a class="headerlink" href="#缺点-3"></a> 缺点</h3><p>因为 cglib 动态代理的实现原理是生成子类, 所以对于 <code>final</code> 修饰的方法无法代理.</p>]]></content>
      
      
      <categories>
          
          <category> dev </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> proxy </tag>
            
            <tag> 代理模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring 事务管理</title>
      <link href="/2018/08/20/spring-transaction/"/>
      <url>/2018/08/20/spring-transaction/</url>
      
        <content type="html"><![CDATA[<h1 id="事务特性"><a class="headerlink" href="#事务特性"></a> 事务特性</h1><p>确保数据的完整性和一致性</p><ul><li>原子性(Atomicity)：事务是一个原子操作,由一系列动作组成.事务的原子性确保动作要么全部完成,要么完全不起作用.</li><li>一致性(Consistency)：一旦事务完成(不管成功还是失败),系统必须确保它所建模的业务处于一致的状态,而不会是部分完成部分失败.在现实中的数据不应该被破坏.</li><li>隔离性(Isolation)：可能有许多事务会同时处理相同的数据,因此每个事务都应该与其他事务隔离开来,防止数据损坏.</li><li>持久性(Durability)：一旦事务完成,无论发生什么系统错误,它的结果都不应该受到影响,这样就能从任何系统崩溃中恢复过来.通常情况下,事务的结果被写到持久化存储器中.</li></ul><h1 id="spring-事务的隔离级别"><a class="headerlink" href="#spring-事务的隔离级别"></a> Spring 事务的隔离级别</h1><p>在<code>TransactionDefinition</code>接口中定义了五个不同的事务隔离级别</p><ul><li>ISOLATION_DEFAULT<br>这是一个 PlatfromTransactionManager 默认的隔离级别,使用数据库默认的事务隔离级别.另外四个与 JDBC 的隔离级别相对应</li><li>ISOLATION_READ_UNCOMMITTED<br>这是事务最低的隔离级别,它允许另外一个事务可以看到这个事务未提交的数据.这种隔离级别会产生脏读,不可重复读和幻像读</li><li>ISOLATION_READ_COMMITTED<br>保证一个事务修改的数据提交后才能被另外一个事务读取.另外一个事务不能读取该事务未提交的数据.这种事务隔离级别可以避免脏读出现,但是可能会出现不可重复读和幻像读</li><li>ISOLATION_REPEATABLE_READ<br>这种事务隔离级别可以防止脏读/不可重复读.但是可能出现幻像读.它除了保证一个事务不能读取另一个事务未提交的数据外,还保证了避免不可重复读</li><li>ISOLATION_SERIALIZABLE<br>这是花费最高代价但是最可靠的事务隔离级别,事务被处理为顺序执行.除了防止脏读,不可重复读外,还避免了幻像读</li></ul><h1 id="spring-事务的传播属性"><a class="headerlink" href="#spring-事务的传播属性"></a> Spring 事务的传播属性</h1><p>在<code>TransactionDefinition</code>接口中定义了七个事务传播行为</p><ul><li>PROPAGATION_REQUIRED<br>如果存在一个事务,则支持当前事务.如果没有事务则开启一个新的事务.</li><li>PROPAGATION_SUPPORTS<br>如果存在一个事务,支持当前事务.如果没有事务,则非事务的执行.但是对于事务同步的事务管理器,<code>PROPAGATION_SUPPORTS</code>与不使用事务有少许不同.</li><li>PROPAGATION_MANDATORY<br>如果已经存在一个事务,支持当前事务.如果没有一个活动的事务,则抛出异常.</li><li>PROPAGATION_REQUIRES_NEW<br>总是开启一个新的事务.如果一个事务已经存在,则将这个存在的事务挂起.</li><li>PROPAGATION_NOT_SUPPORTED<br>总是非事务地执行,并挂起任何存在的事务.</li><li>PROPAGATION_NEVER<br>总是非事务地执行,如果存在一个活动事务,则抛出异常</li><li>PROPAGATION_NESTED<br>如果一个活动的事务存在,则运行在一个嵌套的事务中.如果没有活动事务, 则按<code>TransactionDefinition.PROPAGATION_REQUIRED</code>属性执行</li></ul><h1 id="transactiona-注解"><a class="headerlink" href="#transactiona-注解"></a> @Transactiona 注解</h1><p><code>@Transactional</code> 默认情况下会对运行期例外(RunTimeException)进行事务回滚.这个例外是 unchecked</p><ul><li><p>让 <strong>checked</strong> 例外也回滚:在方法前加上 <code>@Transactional(rollbackFor=Exception.class)</code></p></li><li><p>让 <strong>unchecked</strong> 例外不回滚:在方法前加上 <code>@Transactional(notRollbackFor=RunTimeException.class)</code></p></li><li><p>不需要事务管理的(只查询的)方法:<code>@Transactional(propagation=Propagation.NOT_SUPPORTED)</code></p></li><li><p>还可以加上:<code>@Transactional(propagation=Propagation.NOT_SUPPORTED,readOnly=true)</code>,这样就做成一个只读事务可以提高效率</p></li></ul><p><strong>注意</strong> 如下代码片段 d1 调用 d2 方法,其中 d1 中 <code>userDao.insert(userPO)</code> 执行成功 d2 中 <code>userDao.insert2(userPO)</code> 执行失败</p><ul><li>情况一:<br>d2 <font color="red">没有</font><code>@Transactional</code> 注解 (标记 3)<br>d1 catch 没有 throw 异常 (标记 2)<br>这时 userDao.insert <font color="red">不会 rollback</font><br>控制台没有异常信息</li><li>情况二:<br>d2 <font color="red">有</font><code>@Transactional</code> 注解 (标记 3)<br>d1 catch 没有 throw 异常 (标记 2)<br>这时 userDao.insert <font color="red">会 rollback</font><br>控制台异常信息: <code>org.springframework.transaction.UnexpectedRollbackException: Transaction rolled back because it has been marked as rollback-only</code></li></ul><p>原因:<br>情况二 中 spring 切面在 在执行 d2 后 优先 catch 住了异常 并进行 throw 所以整个方法回滚,<br>而在情况一 中 d2 异常但是 <strong>没有抛出异常</strong> 所以不会触发 rollback</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TestService testService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span>(rollbackFor = &#123;Exception.class&#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">d1</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        UserPO userPO = <span class="keyword">new</span> UserPO();</span><br><span class="line">        userPO.setName(<span class="string">"u1"</span>);</span><br><span class="line">        userDao.insert(userPO); <span class="comment">//success</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            testService.d2();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"error"</span>);</span><br><span class="line"><span class="comment">//            throw new Exception();                    // ---&gt; 2</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    @Transactional(rollbackFor = &#123;Throwable.class&#125;)   // ---&gt; 3</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">d2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        UserPO userPO = <span class="keyword">new</span> UserPO();</span><br><span class="line">        userPO.setName(<span class="string">"u2"</span>);</span><br><span class="line">        userDao.insert2(userPO); <span class="comment">// error</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> dev </category>
          
          <category> java </category>
          
          <category> spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> spring </tag>
            
            <tag> spring transaction </tag>
            
            <tag> spring事务管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 性能测试的四项原则</title>
      <link href="/2018/08/17/performance-test/"/>
      <url>/2018/08/17/performance-test/</url>
      
        <content type="html"><![CDATA[<p>在软件开发过程中，性能测试往往在开发前期容易被忽略。直到有一天问题暴露后，开发人员被迫的直面这个问题，大多数情况下，这是令开发人员感觉到非常痛苦事情。所以在软件开发前期以及开发过程中性能测试的考量是必要的，那么具备相应理论知识和实践方法也是一个优秀工程师所应当具备的素养，这里我们概括有四项原则，这些原则可以帮助开发人员丰富、充实测试理论，系统的开展性能测试工作，从而获得更有价值的结果。</p><a id="more"></a><h2 id="实际项目中的性能测试才有意义"><a class="headerlink" href="#实际项目中的性能测试才有意义"></a> 实际项目中的性能测试才有意义</h2><p>第一个原则就是性能测试只有在实际项目中实施才是有意义的，这样才使得测试工作具有针对性，而且目标会更加明确。这个原则中有三个类别的基准可以指导开发人员度量性能测试的结果，但是每一种方法都有它的优点和劣势。</p><h3 id="微观基准"><a class="headerlink" href="#微观基准"></a> 微观基准</h3><p>可以理解为在某一个方法或某一个组件中进行的单元性能测试。比如检测一个线程同步和一个非线程同步的方法运行时所需要的时间。或者对比创建一个单独线程和使用一个线程池的性能开销。或者对比执行一个算法中的某一个迭代过程所需要的时间。当我们遇到这些情况时，我们常常会选择做一个方法层面的性能测试。这些情况的性能测试，都可以尝试使用微观基准的方法进行性能测试。</p><h3 id="宏观基准"><a class="headerlink" href="#宏观基准"></a> 宏观基准</h3><p>当我们测量应用程序性能时，应当纵览整个系统，影响应用程序性能的原因可能是多方面的，不能片面的认为性能瓶颈只会在程序本身上。</p><h3 id="折衷基准"><a class="headerlink" href="#折衷基准"></a> 折衷基准</h3><p>相比微观基准和宏观基准，一个单独功能模块的性能测试，或者一系列特定操作的性能测试被称为折衷基准。它是介于微观基准和宏观基准之间的折衷方案。基于微观基准测试的正确性是较难把握的，性能瓶颈的判断绝不能仅仅依赖于此。如果我们要使用微观基准作为性能的测量方法，那么不妨在此之前先尝试基于宏观基准的测试。它可以帮助我们了解系统以及代码是如何工作的，从而形成一个系统整体逻辑结构图。接下来可以考虑基于折衷基准的测试，来真正发现潜在的性能瓶颈。需要明确的是折衷基准的测试方法并不是完整应用程序测试的替代方法，更多情况下我们认为它更适用于一个功能模块的自动测试。</p><h2 id="批量吞吐量和响应时间的测量方法"><a class="headerlink" href="#批量吞吐量和响应时间的测量方法"></a> 批量，吞吐量和响应时间的测量方法</h2><p>性能测试中的第二个重要的原则是引入多样的测量方法来分析程序的性能。</p><h3 id="批量"><a class="headerlink" href="#批量"></a> 批量</h3><p>批量执行所用时间的测量方法（耗时法），这是种简单而快速有效的方法，通过测量完成特定任务所消耗的时间来测量整体性能。但是需要特别注意，假如所测试的应用程序中使用缓存数据技术来为了获得更好的性能表现时，多次循环使用该方法可能无法完全反应性能问题。那么可以尝试在初始状态开始时应用耗时法做一次性能的评估，然后当缓存建立后，再次尝试此方法。</p><h3 id="吞吐量"><a class="headerlink" href="#吞吐量"></a> 吞吐量</h3><p>吞吐量的测量方法，在一段时间内考察完成任务的数量的能力，被称为吞吐量测量方法。在测试客户服务器的应用程序时，吞吐量的测量意味着客户端发送请求到服务器是没有任何延迟的，当客户端接收到响应后，应当立即发出新的请求，直到最终结束，统计客户端完成任务的总数。这种相对理想的测试方法通常称之为“Zero-think-time”。可是通常情况下，客户端可能会有多个线程做同一件事情，吞吐量则意味着每秒钟内所有客户端的操作数，而不是测量的某一个时段内的所有操作总数。这种测量经常称为每秒事务/(TPS)，每秒请求 (RPS)，或每秒操作数 (OPS)。</p><h3 id="响应时间"><a class="headerlink" href="#响应时间"></a> 响应时间</h3><p>响应时间的测量方法，响应时间的测量方法是指客户端发出一个请求后直到接收到服务器的响应返回后的时间消耗。响应时间测量方法不同于吞吐量测量方法，在响应时间测试过程中，客户端线程可能会在操作的过程中某一时刻休眠，这就引出“think-time”这个关键词，当“think-time”被引入到测试过程中，也就是意味着待处理任务量是固定的，测量的是服务器响应请求的速率是怎样的。大多数情况下，响应时间的测量方法用来模拟用户真实操作，从而测量应用程序的性能。</p><h2 id="多变性"><a class="headerlink" href="#多变性"></a> 多变性</h2><p>性能测试的第三个原则是理解测试结果如何随时间改变，即使每一次测试使用同样的数据，可能获得的结果也是不同的。一些客观因素，比如后台运行的进程，网络的负载情况，这些都可能带来测试结果的不同，所以在测试过程中存在着一些随机性的因素。</p><h2 id="尽早测试经常测试"><a class="headerlink" href="#尽早测试经常测试"></a> 尽早测试，经常测试</h2><p>第四个原则就是工程师应该视性能测试是整个开发过程必要的部分，尽早进行性能测试，经常进行性能的测试，是一个好的工程师应该做到的。在代码提交到代码库之前，就应当做性能测试，因为性能问题也会导致回归测试失败。所以提早发现问题会提高整个项目的质量，减小交付的风险性。</p><p>尽早测试性能有以下四点可作为指导：</p><ul><li><p>提早准备测试用户以及测试环境的设计和创建；</p></li><li><p>性能测试应该考虑尽量用脚本来完成；</p></li><li><p>通过性能监控工具尽量收集有可能得到的运行信息，为将来分析提供便利；</p></li><li><p>一定要在一个能真实模拟多数用户的机器环境下进行性能测试。</p></li></ul><blockquote><p>原文: <a href="https://www.ibm.com/developerworks/cn/java/j-lo-java-performance-testing/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-lo-java-performance-testing/index.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> dev </category>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> back-end </tag>
            
            <tag> test </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>写给自己的序</title>
      <link href="/2018/08/16/preface/"/>
      <url>/2018/08/16/preface/</url>
      
        <content type="html"><![CDATA[<h2 id="题记"><a class="headerlink" href="#题记"></a> 题记</h2><p>我想说我是一个有情怀的人。记得从小就喜欢写作文，记录一些故事或者瞎编一些故事，后来我喜欢抒发一些感情，再后来喜欢分享一下想法。<br>然而这个世界总喜欢时过境迁，往往我们在某处留下的回忆总随着潮流“被遗忘”，有时候在想“真的是我们习惯于以为，还是被迫去以为而习惯？”但这些都不得而知。</p><a id="more"></a><h2 id="1"><a class="headerlink" href="#1"></a> 1</h2><p>作为一个码农，写点技术 blog 貌似是件很酷的事。然而我这人比较懒，基本不大会花太多心思去整理一些东西出来，而且我又鄙视去 copy 别人的东西这件事,因为本质上不是自己的东西最起码不是自己思考出来的东西，所以就特别少。<br>但好的东西总归是要分享啊，这个时代的可贵之处也在于知识共享与技术共享，大家都喜欢开源的东西，其实也好理解，当大家的技术都趋于统一。那么对于个人来说未尝不是一件好事，就像代码一样讲求复用性通用性,大家的技术都是互通了,对于技术本身就可迭代发展,个人的职业规划和发展也就不言而喻了。所以能分享的我有时间就好好整理下吧。</p><h2 id="2"><a class="headerlink" href="#2"></a> 2</h2><p>虽说互联网行业加班是常态，像大多数人一样，日常都是在 <strong>起床上班回家吃饭晃悠晃悠睡觉</strong> 间循环。我们年少时畅想过诗和远方，亲近自然环游世界，但终究逃不开现实生活。</p><center><p><img src="/2018/08/16/preface/1.png" alt="想想这都是为了什么"><span class="image-caption">想想这都是为了什么</span></p></center><p></p><p><strong>我想着，倘若人生本该如此，那么为什么在学龄时代我们要被赋予对未来的憧憬？这个问题可以向下延伸“到底是生活本该如此，还是我们没有准备好过好这一生？”</strong><br>无论这个问题的答案到底是什么，但我总归不想是第一种可能，倘若生活本该如此，那真的太可悲太绝望了。相比来说第二种可能还尚存希望，我们还这么<s>年纪轻轻</s>不可以这么现世主义啊。</p><h2 id="3"><a class="headerlink" href="#3"></a> 3</h2><p><strong>留下些什么吧 假如怀旧的话</strong> 😃</p>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
          <category> 碎碎念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用 DllPlugin 和 DllReferencePlugin 提高 webpack 构建 Vue 项目的速度</title>
      <link href="/2018/07/13/webpack-build-fast/"/>
      <url>/2018/07/13/webpack-build-fast/</url>
      
        <content type="html"><![CDATA[<h2 id="效果"><a class="headerlink" href="#效果"></a> 效果:</h2><p>提升<font color="#ff0000">63%</font>(第一次 build 会创建本地缓存文件,比理论值稍慢一些,后续不会)</p><a id="more"></a><ul><li><p>before:<br><img src="/2018/07/13/webpack-build-fast/before.jpg" alt="before.jpg"><span class="image-caption">before.jpg</span></p></li><li><p>after:<br><img src="/2018/07/13/webpack-build-fast/after.jpg" alt="after.jpg"><span class="image-caption">after.jpg</span></p></li></ul><h2 id="配置"><a class="headerlink" href="#配置"></a> 配置:</h2><ol><li><p>在 build 文件夹中新建 webpack.dll.conf.js<br><img src="/2018/07/13/webpack-build-fast/config.jpg" alt="config.jpg"><span class="image-caption">config.jpg</span></p></li><li><p>package.json 中配置命令<br><img src="/2018/07/13/webpack-build-fast/package.jpg" alt="package.jpg"><span class="image-caption">package.jpg</span></p></li></ol><ol start="3"><li>执行 npm run build:dll 命令来生成 vendor.dll.js 和 vendor-manifest.json<br><img src="/2018/07/13/webpack-build-fast/vendor.jpg" alt="vendor.jpg"><span class="image-caption">vendor.jpg</span></li></ol><ol start="4"><li>在 index.html 引入 vendor.dll.js<br><img src="/2018/07/13/webpack-build-fast/index.jpg" alt="package.jpg"><span class="image-caption">package.jpg</span></li></ol><ol start="5"><li>在 webpack.prod.config.js 中添加 DllReferencePlugin 插件(在开发模式下会报错,所以需要配置在生产环境下)<br><img src="/2018/07/13/webpack-build-fast/DllReferencePlugin.jpg" alt="package.jpg"><span class="image-caption">package.jpg</span></li></ol><ol start="6"><li>用 ParallelUglifyPlugin 替换默认压缩工具<br><img src="/2018/07/13/webpack-build-fast/ParallelUglifyPlugin.jpg" alt="package.jpg"><span class="image-caption">package.jpg</span></li></ol><p>收尾:</p><ol><li>ParallelUglifyPlugin 会生成.cache 文件夹存放缓存,所有需要在.gitignore 添加忽略项<br><img src="/2018/07/13/webpack-build-fast/ignore.jpg" alt="package.jpg"><span class="image-caption">package.jpg</span></li></ol><ol start="2"><li>引入的新组件如果也不需要反复构建,需要在 webpack.dll.conf.js 的 enter.vender 中添加 并执行 npm run build:dll 重构 vendor.dll.js 和 vendor-manifest.json</li></ol>]]></content>
      
      
      <categories>
          
          <category> dev </category>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> nodeJs </tag>
            
            <tag> fore-end </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue-动态高可配表单设计</title>
      <link href="/2018/06/14/vue-1/"/>
      <url>/2018/06/14/vue-1/</url>
      
        <content type="html"><![CDATA[<h2 id="demo"><a class="headerlink" href="#demo"></a> demo:</h2><p>表单配置<br><img src="https://image-1257148187.cos.ap-chengdu.myqcloud.com/picgo_img/20191216113318.png" alt=""><br>校验配置<br><img src="https://image-1257148187.cos.ap-chengdu.myqcloud.com/picgo_img/20191216113350.png" alt=""><br>属性流flow配置<br><img src="https://image-1257148187.cos.ap-chengdu.myqcloud.com/picgo_img/20191216113404.png" alt=""><br>生成表单交互 .gif<br><img src="/2018/06/14/vue-1/demo.gif" alt=""></p><h2 id="技术栈"><a class="headerlink" href="#技术栈"></a> 技术栈:</h2><p>vue+elementui+springboot+mybatis+mysql</p><h2 id="特性"><a class="headerlink" href="#特性"></a> 特性:</h2><ol><li>支持自定义属性</li><li>支持基于async-validator的值校验</li><li>支持父子属性</li><li>支持属性流程设置</li><li>支持多值</li></ol><h2 id="数据库设计"><a class="headerlink" href="#数据库设计"></a> 数据库设计:</h2><p><img src="https://image-1257148187.cos.ap-chengdu.myqcloud.com/picgo_img/20191216113813.png" alt=""></p><h2 id="关键数据结构"><a class="headerlink" href="#关键数据结构"></a> 关键数据结构:</h2><p>属性对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EntityAttrInfoVO</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="keyword">private</span> String parentId;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 中文名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String cname;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 英文名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String ename;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 短名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String shortName;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否复合对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Boolean compounded;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer dataType;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 描述</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String comment;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 排序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> sort;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否有效</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Boolean valid;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 校验规则</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String rule;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否支持流属性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Boolean flow;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否为流属性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Boolean forFlow;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否支持多个</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Boolean multi;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 显示定位code</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String pointCode;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;EntityAttrInfoVO&gt; childrenAtrr;</span><br><span class="line">    <span class="keyword">private</span> List&lt;RdEntityAttrFlowInfoVO&gt; attrFlowList;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 枚举类型数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;RdEnumDicInfoVO&gt; enumOptions;</span><br><span class="line">    <span class="comment">// get set</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>属性流对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RdEntityAttrFlowInfoVO</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String attrId;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 触发类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer triggerType;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 监听值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String checkKey;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 流属性ids</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Set&lt;String&gt; nextAttrIds;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 流属性对象集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;EntityAttrInfoVO&gt; nextAttrInfo;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//get set</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="期望"><a class="headerlink" href="#期望"></a> 期望:</h2><ol><li>校验支持flow属性</li><li>自动填表 表单项联动监听</li><li>减少递归函数</li><li>性能优化,懒加载可行性</li><li>移动端支持</li></ol><h2 id="值得探讨的问题"><a class="headerlink" href="#值得探讨的问题"></a> 值得探讨的问题:</h2><ol><li><p>为什么子属性(childrenAttr)不和流程属性(flowAttr)合并?<br>理论上childrenAttr属于元属性,作为主体的基本属性必须存在,即便值为空,而flowAttr是动态的,不一定会存在</p></li><li><p>flowAttr为什么要通过json string 类型存储?<br>前期的设想是想按照id-&gt;value的方式存储,但这样很难找到原有的对应关系,因为数据库读取是批量的,数据结构的构建都是在内存完成的</p></li><li><p>是否支持组件化?<br>目前该模块在公司项目中尚未抽离出来,但这并不复杂.前端计划脱离elementui减少依赖,组件化和一些功能优化会在后期逐步完成</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> dev </category>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Netty In Action 阅读指南</title>
      <link href="/2018/05/26/netty-in-action-0/"/>
      <url>/2018/05/26/netty-in-action-0/</url>
      
        <content type="html"><![CDATA[<center><p><img src="/2018/05/26/netty-in-action-0/1.jpg" alt="Netty in action"><span class="image-caption">Netty in action</span></p></center><p></p><h3 id="阅读时长"><a class="headerlink" href="#阅读时长"></a> 阅读时长</h3><ul><li>40h+ (一刷)</li></ul><h3 id="前置基础知识"><a class="headerlink" href="#前置基础知识"></a> 前置基础知识</h3><ul><li>nio 非阻塞异步 io</li><li>concurrent 并发多线程相关</li><li>websocket 相关概念</li></ul><h3 id="jdk-版本"><a class="headerlink" href="#jdk-版本"></a> jdk 版本</h3><ul><li>1.8</li></ul><h3 id="netty-版本"><a class="headerlink" href="#netty-版本"></a> netty 版本</h3><ul><li>建议 netty-all version: 4.0.9Final.最新(5.x)方法与书中不同容易搞混,4.1.x 系列版本中部分方法被标记为清除.</li></ul><h3 id="建议章节阅读顺序"><a class="headerlink" href="#建议章节阅读顺序"></a> 建议章节阅读顺序</h3><ul><li>[ 1 --&gt; 3 ]–&gt;[ 6 --&gt; 7 --&gt; 8 --&gt; 5 ] --&gt; 2 --&gt; 11,12,…</li><li>总分总+拓展</li><li>如果需要对 netty 有一个直观的认知可以先看第二章和第三章</li></ul><h3 id="重点章节"><a class="headerlink" href="#重点章节"></a> 重点章节</h3><ul><li>3,5,6,7,8</li></ul>]]></content>
      
      
      <categories>
          
          <category> dev </category>
          
          <category> java </category>
          
          <category> netty </category>
          
      </categories>
      
      
        <tags>
            
            <tag> netty </tag>
            
            <tag> nio </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>emoji-for-markdown</title>
      <link href="/2018/04/13/emoji-for-markdown/"/>
      <url>/2018/04/13/emoji-for-markdown/</url>
      
        <content type="html"><![CDATA[<p>在 markdown 中添加 Emoji 表情: 😃 😈 🐱 🐶 💗</p><a id="more"></a><p>将对应 emoji 表情的符号码复制后输入你的 markdown 文本即可显示 emoji 表情。<br>如<code>:blush:</code>，显示为😊</p><h2 id="人物"><a class="headerlink" href="#人物"></a> 人物</h2><p><code>:smile:</code>😄<br><code>:laughing:</code>😆<br><code>:blush:</code>😊<br><code>:smiley:</code>😃<br><code>:relaxed:</code>☺️<br><code>:smirk:</code>😏<br><code>:heart_eyes:</code>😍<br><code>:kissing_heart:</code>😘<br><code>:kissing_closed_eyes:</code>😚<br><code>:flushed:</code>😳<br><code>:relieved:</code>😌<br><code>:satisfied:</code>😆<br><code>:grin:</code>😁<br><code>:wink:</code>😉<br><code>:stuck_out_tongue_winking_eye:</code>😜<br><code>:stuck_out_tongue_closed_eyes:</code>😝<br><code>:grinning:</code>😀<br><code>:kissing:</code>😗<br><code>:kissing_smiling_eyes:</code>😙<br><code>:stuck_out_tongue:</code>😛<br><code>:sleeping:</code>😴<br><code>:worried:</code>😟<br><code>:frowning:</code>😦<br><code>:anguished:</code>😧<br><code>:open_mouth:</code>😮<br><code>:grimacing:</code>😬<br><code>:confused:</code>😕<br><code>:hushed:</code>😯<br><code>:expressionless:</code>😑<br><code>:unamused:</code>😒<br><code>:sweat_smile:</code>😅<br><code>:sweat:</code>😓<br><code>:disappointed_relieved:</code>😥<br><code>:weary:</code>😩<br><code>:pensive:</code>😔<br><code>:disappointed:</code>😞<br><code>:confounded:</code>😖<br><code>:fearful:</code>😨<br><code>:cold_sweat:</code>😰<br><code>:persevere:</code>😣<br><code>:cry:</code>😢<br><code>:sob:</code>😭<br><code>:joy:</code>😂<br><code>:astonished:</code>😲<br><code>:scream:</code>😱<br><code>:neckbeard:</code>:neckbeard:<br><code>:tired_face:</code>😫<br><code>:angry:</code>😠<br><code>:rage:</code>😡<br><code>:triumph:</code>😤<br><code>:sleepy:</code>😪<br><code>:yum:</code>😋<br><code>:mask:</code>😷<br><code>:sunglasses:</code>😎<br><code>:dizzy_face:</code>😵<br><code>:imp:</code>👿<br><code>:smiling_imp:</code>😈<br><code>:neutral_face:</code>😐<br><code>:no_mouth:</code>😶<br><code>:innocent:</code>😇<br><code>:alien:</code>👽<br><code>:yellow_heart:</code>💛<br><code>:blue_heart:</code>💙<br><code>:purple_heart:</code>💜<br><code>:heart:</code>❤️<br><code>:green_heart:</code>💚<br><code>:broken_heart:</code>💔<br><code>:heartbeat:</code>💓<br><code>:heartpulse:</code>💗<br><code>:two_hearts:</code>💕<br><code>:revolving_hearts:</code>💞<br><code>:cupid:</code>💘<br><code>:sparkling_heart:</code>💖<br><code>:sparkles:</code>✨<br><code>:star:</code>⭐️<br><code>:star2:</code>🌟<br><code>:dizzy:</code>💫<br><code>:boom:</code>💥<br><code>:collision:</code>💥<br><code>:anger:</code>💢<br><code>:exclamation:</code>❗️<br><code>:question:</code>❓<br><code>:grey_exclamation:</code>❕<br><code>:grey_question:</code>❔<br><code>:zzz:</code>💤<br><code>:dash:</code>💨<br><code>:sweat_drops:</code>💦<br><code>:notes:</code>🎶<br><code>:musical_note:</code>🎵<br><code>:fire:</code>🔥<br><code>:hankey:</code>💩<br><code>:poop:</code>💩<br><code>::</code>💩<br><code>:+1:</code>👍<br><code>:thumbsup:</code>👍<br><code>:-1:</code>👎<br><code>:thumbsdown:</code>👎<br><code>:ok_hand:</code>👌<br><code>:punch:</code>👊<br><code>:facepunch:</code>👊<br><code>:fist:</code>✊<br><code>:v:</code>✌️<br><code>:wave:</code>👋<br><code>:hand:</code>✋<br><code>:raised_hand:</code>✋<br><code>:open_hands:</code>👐<br><code>:point_up:</code>☝️<br><code>:point_down:</code>👇<br><code>:point_left:</code>👈<br><code>:point_right:</code>👉<br><code>:raised_hands:</code>🙌<br><code>:pray:</code>🙏<br><code>:point_up_2:</code>👆<br><code>:clap:</code>👏<br><code>:muscle:</code>💪<br><code>:metal:</code>🤘<br><code>:fu:</code>🖕<br><code>:walking:</code>🚶<br><code>:runner:</code>🏃<br><code>:running:</code>🏃<br><code>:couple:</code>👫<br><code>:family:</code>👪<br><code>:two_men_holding_hands:</code>👬<br><code>:two_women_holding_hands:</code>👭<br><code>:dancer:</code>💃<br><code>:dancers:</code>👯<br><code>:ok_woman:</code>🙆<br><code>:no_good:</code>🙅<br><code>:information_desk_person:</code>💁<br><code>:raising_hand:</code>🙋<br><code>:bride_with_veil:</code>👰<br><code>:person_with_pouting_face:</code>🙎<br><code>:person_frowning:</code>🙍<br><code>:bow:</code>🙇<br><code>:couplekiss:</code>:couplekiss:<br><code>:couple_with_heart:</code>💑<br><code>:massage:</code>💆<br><code>:haircut:</code>💇<br><code>:nail_care:</code>💅<br><code>:boy:</code>👦<br><code>:girl:</code>👧<br><code>:woman:</code>👩<br><code>:man:</code>👨<br><code>:baby:</code>👶<br><code>:older_woman:</code>👵<br><code>:older_man:</code>👴<br><code>:person_with_blond_hair:</code>👱<br><code>:man_with_gua_pi_mao:</code>👲<br><code>:man_with_turban:</code>👳<br><code>:construction_worker:</code>👷<br><code>:cop:</code>👮<br><code>:angel:</code>👼<br><code>:princess:</code>👸<br><code>:smiley_cat:</code>😺<br><code>:smile_cat:</code>😸<br><code>:heart_eyes_cat:</code>😻<br><code>:kissing_cat:</code>😽<br><code>:smirk_cat:</code>😼<br><code>:scream_cat:</code>🙀<br><code>:crying_cat_face:</code>😿<br><code>:joy_cat:</code>😹<br><code>:pouting_cat:</code>😾<br><code>:japanese_ogre:</code>👹<br><code>:japanese_goblin:</code>👺<br><code>:see_no_evil:</code>🙈<br><code>:hear_no_evil:</code>🙉<br><code>:speak_no_evil:</code>🙊<br><code>:guardsman:</code>💂<br><code>:skull:</code>💀<br><code>:feet:</code>🐾<br><code>:lips:</code>👄<br><code>:kiss:</code>💋<br><code>:droplet:</code>💧<br><code>:ear:</code>👂<br><code>:eyes:</code>👀<br><code>:nose:</code>👃<br><code>:tongue:</code>👅<br><code>:love_letter:</code>💌<br><code>:bust_in_silhouette:</code>👤<br><code>:busts_in_silhouette:</code>👥<br><code>:speech_balloon:</code>💬<br><code>:thought_balloon:</code>💭<br><code>:feelsgood:</code>:feelsgood:<br><code>:finnadie:</code>:finnadie:<br><code>:goberserk:</code>:goberserk:<br><code>:godmode:</code>:godmode:<br><code>:hurtrealbad:</code>:hurtrealbad:<br><code>:rage1:</code>:rage1:<br><code>:rage2:</code>:rage2:<br><code>:rage3:</code>:rage3:<br><code>:rage4:</code>:rage4:<br><code>:suspect:</code>:suspect:<br><code>:trollface:</code>:trollface:</p><h2 id="自然"><a class="headerlink" href="#自然"></a> 自然</h2><p>:-------::—:<br><code>:sunny:</code>☀️<br><code>:umbrella:</code>☔️<br><code>:cloud:</code>☁️<br><code>:snowflake:</code>❄️<br><code>:snowman:</code>⛄️<br><code>:zap:</code>⚡️<br><code>:cyclone:</code>🌀<br><code>:foggy:</code>🌁<br><code>:ocean:</code>🌊<br><code>:cat:</code>🐱<br><code>:dog:</code>🐶<br><code>:mouse:</code>🐭<br><code>:hamster:</code>🐹<br><code>:rabbit:</code>🐰<br><code>:wolf:</code>🐺<br><code>:frog:</code>🐸<br><code>:tiger:</code>🐯<br><code>:koala:</code>🐨<br><code>:bear:</code>🐻<br><code>:pig:</code>🐷<br><code>:pig_nose:</code>🐽<br><code>:cow:</code>🐮<br><code>:boar:</code>🐗<br><code>:monkey_face:</code>🐵<br><code>:monkey:</code>🐒<br><code>:horse:</code>🐴<br><code>:racehorse:</code>🐎<br><code>:camel:</code>🐫<br><code>:sheep:</code>🐑<br><code>:elephant:</code>🐘<br><code>:panda_face:</code>🐼<br><code>:snake:</code>🐍<br><code>:bird:</code>🐦<br><code>:baby_chick:</code>🐤<br><code>:hatched_chick:</code>🐥<br><code>:hatching_chick:</code>🐣<br><code>:chicken:</code>🐔<br><code>:penguin:</code>🐧<br><code>:turtle:</code>🐢<br><code>:bug:</code>🐛<br><code>:honeybee:</code>🐝<br><code>:ant:</code>🐜<br><code>:beetle:</code>🐞<br><code>:snail:</code>🐌<br><code>:octopus:</code>🐙<br><code>:tropical_fish:</code>🐠<br><code>:fish:</code>🐟<br><code>:whale:</code>🐳<br><code>:whale2:</code>🐋<br><code>:dolphin:</code>🐬<br><code>:cow2:</code>🐄<br><code>:ram:</code>🐏<br><code>:rat:</code>🐀<br><code>:water_buffalo:</code>🐃<br><code>:tiger2:</code>🐅<br><code>:rabbit2:</code>🐇<br><code>:dragon:</code>🐉<br><code>:goat:</code>🐐<br><code>:rooster:</code>🐓<br><code>:dog2:</code>🐕<br><code>:pig2:</code>🐖<br><code>:mouse2:</code>🐁<br><code>:ox:</code>🐂<br><code>:dragon_face:</code>🐲<br><code>:blowfish:</code>🐡<br><code>:crocodile:</code>🐊<br><code>:dromedary_camel:</code>🐪<br><code>:leopard:</code>🐆<br><code>:cat2:</code>🐈<br><code>:poodle:</code>🐩<br><code>:paw_prints:</code>🐾<br><code>:bouquet:</code>💐<br><code>:cherry_blossom:</code>🌸<br><code>:tulip:</code>🌷<br><code>:four_leaf_clover:</code>🍀<br><code>:rose:</code>🌹<br><code>:sunflower:</code>🌻<br><code>:hibiscus:</code>🌺<br><code>:maple_leaf:</code>🍁<br><code>:leaves:</code>🍃<br><code>:fallen_leaf:</code>🍂<br><code>:herb:</code>🌿<br><code>:mushroom:</code>🍄<br><code>:cactus:</code>🌵<br><code>:palm_tree:</code>🌴<br><code>:evergreen_tree:</code>🌲<br><code>:deciduous_tree:</code>🌳<br><code>:chestnut:</code>🌰<br><code>:seedling:</code>🌱<br><code>:blossom:</code>🌼<br><code>:ear_of_rice:</code>🌾<br><code>:shell:</code>🐚<br><code>:globe_with_meridians:</code>🌐<br><code>:sun_with_face:</code>🌞<br><code>:full_moon_with_face:</code>🌝<br><code>:new_moon_with_face:</code>🌚<br><code>:new_moon:</code>🌑<br><code>:waxing_crescent_moon:</code>🌒<br><code>:first_quarter_moon:</code>🌓<br><code>:full_moon:</code>🌕<br><code>:waning_gibbous_moon:</code>🌖<br><code>:last_quarter_moon:</code>🌗<br><code>:waning_crescent_moon:</code>🌘<br><code>:last_quarter_moon_with_face:</code>🌜<br><code>:first_quarter_moon_with_face:</code>🌛<br><code>:moon:</code>🌔<br><code>:earth_africa:</code>🌍<br><code>:earth_americas:</code>🌎<br><code>:earth_asia:</code>🌏<br><code>:volcano:</code>🌋<br><code>:milky_way:</code>🌌<br><code>:partly_sunny:</code>⛅️<br><code>:octocat:</code>:octocat:<br><code>:squirrel:</code>:squirrel:<br><code>:waxing_gibbous_moon:</code>🌔</p><h2 id="物体"><a class="headerlink" href="#物体"></a> 物体</h2><p>:-------::—:<br><code>:bamboo:</code>🎍<br><code>:gift_heart:</code>💝<br><code>:dolls:</code>🎎<br><code>:school_satchel:</code>🎒<br><code>:mortar_board:</code>🎓<br><code>:flags:</code>🎏<br><code>:fireworks:</code>🎆<br><code>:sparkler:</code>🎇<br><code>:wind_chime:</code>🎐<br><code>:rice_scene:</code>🎑<br><code>:jack_o_lantern:</code>🎃<br><code>:ghost:</code>👻<br><code>:santa:</code>🎅<br><code>:christmas_tree:</code>🎄<br><code>:gift:</code>🎁<br><code>:bell:</code>🔔<br><code>:no_bell:</code>🔕<br><code>:tanabata_tree:</code>🎋<br><code>:tada:</code>🎉<br><code>:confetti_ball:</code>🎊<br><code>:balloon:</code>🎈<br><code>:crystal_ball:</code>🔮<br><code>:cd:</code>💿<br><code>:dvd:</code>📀<br><code>:floppy_disk:</code>💾<br><code>:camera:</code>📷<br><code>:video_camera:</code>📹<br><code>:movie_camera:</code>🎥<br><code>:computer:</code>💻<br><code>:tv:</code>📺<br><code>:iphone:</code>📱<br><code>:phone:</code>☎️<br><code>:telephone:</code>☎️<br><code>:telephone_receiver:</code>📞<br><code>:pager:</code>📟<br><code>:fax:</code>📠<br><code>:minidisc:</code>💽<br><code>:vhs:</code>📼<br><code>:sound:</code>🔉<br><code>:speaker:</code>🔈<br><code>:mute:</code>🔇<br><code>:loudspeaker:</code>📢<br><code>:mega:</code>📣<br><code>:hourglass:</code>⌛️<br><code>:hourglass_flowing_sand:</code>⏳<br><code>:alarm_clock:</code>⏰<br><code>:watch:</code>⌚️<br><code>:radio:</code>📻<br><code>:satellite:</code>📡<br><code>:loop:</code>➿<br><code>:mag:</code>🔍<br><code>:mag_right:</code>🔎<br><code>:unlock:</code>🔓<br><code>:lock:</code>🔒<br><code>:lock_with_ink_pen:</code>🔏<br><code>:closed_lock_with_key:</code>🔐<br><code>:key:</code>🔑<br><code>:bulb:</code>💡<br><code>:flashlight:</code>🔦<br><code>:high_brightness:</code>🔆<br><code>:low_brightness:</code>🔅<br><code>:electric_plug:</code>🔌<br><code>:battery:</code>🔋<br><code>:calling:</code>📲<br><code>:email:</code>✉️<br><code>:mailbox:</code>📫<br><code>:postbox:</code>📮<br><code>:bath:</code>🛀<br><code>:bathtub:</code>🛁<br><code>:shower:</code>🚿<br><code>:toilet:</code>🚽<br><code>:wrench:</code>🔧<br><code>:nut_and_bolt:</code>🔩<br><code>:hammer:</code>🔨<br><code>:seat:</code>💺<br><code>:moneybag:</code>💰<br><code>:yen:</code>💴<br><code>:dollar:</code>💵<br><code>:pound:</code>💷<br><code>:euro:</code>💶<br><code>:credit_card:</code>💳<br><code>:money_with_wings:</code>💸<br><code>:e-mail:</code>📧<br><code>:inbox_tray:</code>📥<br><code>:outbox_tray:</code>📤<br><code>:envelope:</code>✉️<br><code>:incoming_envelope:</code>📨<br><code>:postal_horn:</code>📯<br><code>:mailbox_closed:</code>📪<br><code>:mailbox_with_mail:</code>📬<br><code>:mailbox_with_no_mail:</code>📭<br><code>:door:</code>🚪<br><code>:smoking:</code>🚬<br><code>:bomb:</code>💣<br><code>:gun:</code>🔫<br><code>:hocho:</code>🔪<br><code>:pill:</code>💊<br><code>:syringe:</code>💉<br><code>:page_facing_up:</code>📄<br><code>:page_with_curl:</code>📃<br><code>:bookmark_tabs:</code>📑<br><code>:bar_chart:</code>📊<br><code>:chart_with_upwards_trend:</code>📈<br><code>:chart_with_downwards_trend:</code>📉<br><code>:scroll:</code>📜<br><code>:clipboard:</code>📋<br><code>:calendar:</code>📆<br><code>:date:</code>📅<br><code>:card_index:</code>📇<br><code>:file_folder:</code>📁<br><code>:open_file_folder:</code>📂<br><code>:scissors:</code>✂️<br><code>:pushpin:</code>📌<br><code>:paperclip:</code>📎<br><code>:black_nib:</code>✒️<br><code>:pencil2:</code>✏️<br><code>:straight_ruler:</code>📏<br><code>:triangular_ruler:</code>📐<br><code>:closed_book:</code>📕<br><code>:green_book:</code>📗<br><code>:blue_book:</code>📘<br><code>:orange_book:</code>📙<br><code>:notebook:</code>📓<br><code>:notebook_with_decorative_cover:</code>📔<br><code>:ledger:</code>📒<br><code>:books:</code>📚<br><code>:bookmark:</code>🔖<br><code>:microscope:</code>🔬<br><code>:telescope:</code>🔭<br><code>:name_badge:</code>📛<br><code>:newspaper:</code>📰<br><code>:football:</code>🏈<br><code>:basketball:</code>🏀<br><code>:soccer:</code>⚽️<br><code>:baseball:</code>⚾️<br><code>:tennis:</code>🎾<br><code>:8ball:</code>🎱<br><code>:rugby_football:</code>🏉<br><code>:bowling:</code>🎳<br><code>:golf:</code>⛳️<br><code>:mountain_bicyclist:</code>🚵<br><code>:bicyclist:</code>🚴<br><code>:horse_racing:</code>🏇<br><code>:snowboarder:</code>🏂<br><code>:swimmer:</code>🏊<br><code>:surfer:</code>🏄<br><code>:ski:</code>🎿<br><code>:spades:</code>♠️<br><code>:hearts:</code>♥️<br><code>:clubs:</code>♣️<br><code>:diamonds:</code>♦️<br><code>:gem:</code>💎<br><code>:ring:</code>💍<br><code>:trophy:</code>🏆<br><code>:musical_score:</code>🎼<br><code>:musical_keyboard:</code>🎹<br><code>:violin:</code>🎻<br><code>:space_invader:</code>👾<br><code>:video_game:</code>🎮<br><code>:black_joker:</code>🃏<br><code>:flower_playing_cards:</code>🎴<br><code>:game_die:</code>🎲<br><code>:dart:</code>🎯<br><code>:mahjong:</code>🀄️<br><code>:clapper:</code>🎬<br><code>:memo:</code>📝<br><code>:pencil:</code>📝<br><code>:book:</code>📖<br><code>:art:</code>🎨<br><code>:microphone:</code>🎤<br><code>:headphones:</code>🎧<br><code>:trumpet:</code>🎺<br><code>:saxophone:</code>🎷<br><code>:guitar:</code>🎸<br><code>:shoe:</code>👞<br><code>:sandal:</code>👡<br><code>:high_heel:</code>👠<br><code>:lipstick:</code>💄<br><code>:boot:</code>👢<br><code>:shirt:</code>👕<br><code>:tshirt:</code>👕<br><code>:necktie:</code>👔<br><code>:womans_clothes:</code>👚<br><code>:dress:</code>👗<br><code>:running_shirt_with_sash:</code>🎽<br><code>:jeans:</code>👖<br><code>:kimono:</code>👘<br><code>:bikini:</code>👙<br><code>:ribbon:</code>🎀<br><code>:tophat:</code>🎩<br><code>:crown:</code>👑<br><code>:womans_hat:</code>👒<br><code>:mans_shoe:</code>👞<br><code>:closed_umbrella:</code>🌂<br><code>:briefcase:</code>💼<br><code>:handbag:</code>👜<br><code>:pouch:</code>👝<br><code>:purse:</code>👛<br><code>:eyeglasses:</code>👓<br><code>:fishing_pole_and_fish:</code>🎣<br><code>:coffee:</code>☕️<br><code>:tea:</code>🍵<br><code>:sake:</code>🍶<br><code>:baby_bottle:</code>🍼<br><code>:beer:</code>🍺<br><code>:beers:</code>🍻<br><code>:cocktail:</code>🍸<br><code>:tropical_drink:</code>🍹<br><code>:wine_glass:</code>🍷<br><code>:fork_and_knife:</code>🍴<br><code>:pizza:</code>🍕<br><code>:hamburger:</code>🍔<br><code>:fries:</code>🍟<br><code>:poultry_leg:</code>🍗<br><code>:meat_on_bone:</code>🍖<br><code>:spaghetti:</code>🍝<br><code>:curry:</code>🍛<br><code>:fried_shrimp:</code>🍤<br><code>:bento:</code>🍱<br><code>:sushi:</code>🍣<br><code>:fish_cake:</code>🍥<br><code>:rice_ball:</code>🍙<br><code>:rice_cracker:</code>🍘<br><code>:rice:</code>🍚<br><code>:ramen:</code>🍜<br><code>:stew:</code>🍲<br><code>:oden:</code>🍢<br><code>:dango:</code>🍡<br><code>:egg:</code>🥚<br><code>:bread:</code>🍞<br><code>:doughnut:</code>🍩<br><code>:custard:</code>🍮<br><code>:icecream:</code>🍦<br><code>:ice_cream:</code>🍨<br><code>:shaved_ice:</code>🍧<br><code>:birthday:</code>🎂<br><code>:cake:</code>🍰<br><code>:cookie:</code>🍪<br><code>:chocolate_bar:</code>🍫<br><code>:candy:</code>🍬<br><code>:lollipop:</code>🍭<br><code>:honey_pot:</code>🍯<br><code>:apple:</code>🍎<br><code>:green_apple:</code>🍏<br><code>:tangerine:</code>🍊<br><code>:lemon:</code>🍋<br><code>:cherries:</code>🍒<br><code>:grapes:</code>🍇<br><code>:watermelon:</code>🍉<br><code>:strawberry:</code>🍓<br><code>:peach:</code>🍑<br><code>:melon:</code>🍈<br><code>:banana:</code>🍌<br><code>:pear:</code>🍐<br><code>:pineapple:</code>🍍<br><code>:sweet_potato:</code>🍠<br><code>:eggplant:</code>🍆<br><code>:tomato:</code>🍅<br><code>:corn:</code>🌽</p><h2 id="地点"><a class="headerlink" href="#地点"></a> 地点</h2><p>:-------::—:<br><code>:house:</code>🏠<br><code>:house_with_garden:</code>🏡<br><code>:school:</code>🏫<br><code>:office:</code>🏢<br><code>:post_office:</code>🏣<br><code>:hospital:</code>🏥<br><code>:bank:</code>🏦<br><code>:convenience_store:</code>🏪<br><code>:love_hotel:</code>🏩<br><code>:hotel:</code>🏨<br><code>:wedding:</code>💒<br><code>:church:</code> ⛪️<br><code>:department_store:</code>🏬<br><code>:european_post_office:</code>🏤<br><code>:city_sunrise:</code>🌇<br><code>:city_sunset:</code>🌆<br><code>:japanese_castle:</code>🏯<br><code>:european_castle:</code>🏰<br><code>:tent:</code>⛺️<br><code>:factory:</code> 🏭<br><code>:tokyo_tower:</code>🗼<br><code>:japan:</code>🗾<br><code>:mount_fuji:</code>🗻<br><code>:sunrise_over_mountains:</code>🌄<br><code>:sunrise:</code>🌅<br><code>:stars:</code>🌠<br><code>:statue_of_liberty:</code>🗽<br><code>:bridge_at_night:</code>🌉<br><code>:carousel_horse:</code>🎠<br><code>:rainbow:</code>🌈<br><code>:ferris_wheel:</code>🎡<br><code>:fountain:</code>⛲️<br><code>:roller_coaster:</code>🎢<br><code>:ship:</code>🚢<br><code>:speedboat:</code> 🚤<br><code>:boat:</code> ⛵️<br><code>:sailboat:</code>⛵️<br><code>:rowboat:</code>🚣<br><code>:anchor:</code>⚓️<br><code>:rocket:</code>🚀<br><code>:airplane:</code>✈️<br><code>:helicopter:</code>🚁<br><code>:steam_locomotive:</code>🚂<br><code>:tram:</code>🚊<br><code>:mountain_railway:</code>🚞<br><code>:bike:</code>🚲<br><code>:aerial_tramway:</code>🚡<br><code>:suspension_railway:</code>🚟<br><code>:mountain_cableway:</code>🚠<br><code>:tractor:</code>🚜<br><code>:blue_car:</code>🚙<br><code>:oncoming_automobile:</code>🚘<br><code>:car:</code>🚗<br><code>:red_car:</code> 🚗<br><code>:taxi:</code>🚕<br><code>:oncoming_taxi:</code>🚖<br><code>:articulated_lorry:</code>🚛<br><code>:bus:</code>🚌<br><code>:oncoming_bus:</code>🚍<br><code>:rotating_light:</code>🚨<br><code>:police_car:</code>🚓<br><code>:oncoming_police_car:</code>🚔<br><code>:fire_engine:</code>🚒<br><code>:ambulance:</code>🚑<br><code>:minibus:</code>🚐<br><code>:truck:</code> 🚚<br><code>:train:</code> 🚋<br><code>:station:</code> 🚉<br><code>:train2:</code> 🚆<br><code>:bullettrain_front:</code>🚅<br><code>:bullettrain_side:</code> 🚄<br><code>:light_rail:</code> 🚈<br><code>:monorail:</code> 🚝<br><code>:railway_car:</code> 🚃<br><code>:trolleybus:</code> 🚎<br><code>:ticket:</code>🎫<br><code>:fuelpump:</code> ⛽️<br><code>:vertical_traffic_light:</code> 🚦<br><code>:traffic_light:</code> 🚥<br><code>:warning:</code> ⚠️<br><code>:construction:</code> 🚧<br><code>:beginner:</code>🔰<br><code>:atm:</code> 🏧<br><code>:slot_machine:</code> 🎰<br><code>:busstop:</code> 🚏<br><code>:barber:</code> 💈<br><code>:hotsprings:</code> ♨️<br><code>:checkered_flag:</code> 🏁<br><code>:crossed_flags:</code> 🎌<br><code>:izakaya_lantern:</code> 🏮<br><code>:moyai:</code>🗿<br><code>:circus_tent:</code> 🎪<br><code>:performing_arts:</code> 🎭<br><code>:round_pushpin:</code> 📍<br><code>:triangular_flag_on_post:</code> 🚩<br><code>:jp:</code> 🇯🇵<br><code>:kr:</code>🇰🇷<br><code>:cn:</code> 🇨🇳<br><code>:us:</code> 🇺🇸<br><code>:fr:</code> 🇫🇷<br><code>:es:</code>🇪🇸<br><code>:it:</code> 🇮🇹<br><code>:ru:</code>🇷🇺<br><code>:gb:</code> 🇬🇧<br><code>:uk:</code> 🇬🇧<br><code>:de:</code>🇩🇪</p><h2 id="符号"><a class="headerlink" href="#符号"></a> 符号</h2><p>:-------::—:<br><code>:one:</code>1️⃣<br><code>:two:</code>2️⃣<br><code>:three:</code>3️⃣<br><code>:four:</code>4️⃣<br><code>:five:</code>5️⃣<br><code>:six:</code> 6️⃣<br><code>:seven:</code> 7️⃣<br><code>:eight:</code> 8️⃣<br><code>:nine:</code> 9️⃣<br><code>:keycap_ten:</code> 🔟<br><code>:1234:</code> 🔢<br><code>:zero:</code> 0️⃣<br><code>:hash:</code>#️⃣<br><code>:symbols:</code> 🔣<br><code>:arrow_backward:</code> ◀️<br><code>:arrow_down:</code> ⬇️<br><code>:arrow_forward:</code> ▶️<br><code>:arrow_left:</code> ⬅️<br><code>:capital_abcd:</code> 🔠<br><code>:abcd:</code> 🔡<br><code>:abc:</code> 🔤<br><code>:arrow_lower_left:</code>↙️<br><code>:arrow_lower_right:</code> ↘️<br><code>:arrow_right:</code> ➡️<br><code>:arrow_up:</code> ⬆️<br><code>:arrow_upper_left:</code> ↖️<br><code>:arrow_upper_right:</code> ↗️<br><code>:arrow_double_down:</code>⏬<br><code>:arrow_double_up:</code> ⏫<br><code>:arrow_down_small:</code> 🔽<br><code>:arrow_heading_down:</code> ⤵️<br><code>:arrow_heading_up:</code> ⤴️<br><code>:leftwards_arrow_with_hook:</code> ↩️<br><code>:arrow_right_hook:</code>↪️<br><code>:left_right_arrow:</code> ↔️<br><code>:arrow_up_down:</code> ↕️<br><code>:arrow_up_small:</code> 🔼<br><code>:arrows_clockwise:</code> 🔃<br><code>:arrows_counterclockwise:</code> 🔄<br><code>:rewind:</code> ⏪<br><code>:fast_forward:</code> ⏩<br><code>:information_source:</code> ℹ️<br><code>:ok:</code>🆗<br><code>:twisted_rightwards_arrows:</code> 🔀<br><code>:repeat:</code> 🔁<br><code>:repeat_one:</code> 🔂<br><code>:new:</code> 🆕<br><code>:top:</code> 🔝<br><code>:up:</code>🆙<br><code>:cool:</code>🆒<br><code>:free:</code> 🆓<br><code>:ng:</code>🆖<br><code>:cinema:</code>🎦<br><code>:koko:</code> 🈁<br><code>:signal_strength:</code> 📶<br><code>:u5272:</code> :u5272:<br><code>:u5408:</code> :u5408:<br><code>:u55b6:</code> :u55b6:<br><code>:u6307:</code> :u6307:<br><code>:u6708:</code> :u6708:<br><code>:u6709:</code> :u6709:<br><code>:u6e80:</code> 🈵<br><code>:u7121:</code> :u7121:<br><code>:u7533:</code> :u7533:<br><code>:u7a7a:</code> :u7a7a:<br><code>:u7981:</code> :u7981:<br><code>:sa:</code>🈂️<br><code>:restroom:</code> 🚻<br><code>:mens:</code> 🚹<br><code>:womens:</code> 🚺<br><code>:baby_symbol:</code> 🚼<br><code>:no_smoking:</code> 🚭<br><code>:parking:</code>🅿️<br><code>:wheelchair:</code> ♿️<br><code>:metro:</code> 🚇<br><code>:baggage_claim:</code> 🛄<br><code>:accept:</code> 🉑<br><code>:wc:</code> 🚾<br><code>:potable_water:</code>🚰<br><code>:put_litter_in_its_place:</code> 🚮<br><code>:secret:</code> ㊙️<br><code>:congratulations:</code> ㊗️<br><code>:m:</code> Ⓜ️<br><code>:passport_control:</code> 🛂<br><code>:left_luggage:</code>🛅<br><code>:customs:</code> 🛃<br><code>:ideograph_advantage:</code> 🉐<br><code>:cl:</code> 🆑<br><code>:sos:</code> 🆘<br><code>:id:</code> 🆔<br><code>:no_entry_sign:</code> 🚫<br><code>:underage:</code> 🔞<br><code>:no_mobile_phones:</code> 📵<br><code>:do_not_litter:</code> 🚯<br><code>:non-potable_water:</code> 🚱<br><code>:no_bicycles:</code> 🚳<br><code>:no_pedestrians:</code>🚷<br><code>:children_crossing:</code> 🚸<br><code>:no_entry:</code> ⛔️<br><code>:eight_spoked_asterisk:</code> ✳️<br><code>:eight_pointed_black_star:</code> ✴️<br><code>:heart_decoration:</code> 💟<br><code>:vs:</code> 🆚<br><code>:vibration_mode:</code> 📳<br><code>:mobile_phone_off:</code> 📴<br><code>:chart:</code> 💹<br><code>:currency_exchange:</code> 💱<br><code>:aries:</code> ♈️<br><code>:taurus:</code> ♉️<br><code>:gemini:</code>♊️<br><code>:cancer:</code> ♋️<br><code>:leo:</code>♌️<br><code>:virgo:</code> ♍️<br><code>:libra:</code> ♎️<br><code>:scorpius:</code> ♏️<br><code>:sagittarius:</code> ♐️<br><code>:capricorn:</code> ♑️<br><code>:aquarius:</code> ♒️<br><code>:pisces:</code> ♓️<br><code>:ophiuchus:</code> ⛎<br><code>:six_pointed_star:</code> 🔯<br><code>:negative_squared_cross_mark:</code> ❎<br><code>:a:</code> 🅰️<br><code>:b:</code>🅱️<br><code>:ab:</code> 🆎<br><code>:o2:</code> 🅾️<br><code>:diamond_shape_with_a_dot_inside:</code> 💠<br><code>:recycle:</code> ♻️<br><code>:end:</code> 🔚<br><code>:on:</code> 🔛<br><code>:soon:</code> 🔜<br><code>:clock1:</code> 🕐<br><code>:clock130:</code>🕜<br><code>:clock10:</code> 🕙<br><code>:clock1030:</code> 🕥<br><code>:clock11:</code> 🕚<br><code>:clock1130:</code> 🕦<br><code>:clock12:</code> 🕛<br><code>:clock1230:</code> 🕧<br><code>:clock2:</code> 🕑<br><code>:clock230:</code>🕝<br><code>:clock3:</code> 🕒<br><code>:clock330:</code> 🕞<br><code>:clock4:</code> 🕓<br><code>:clock430:</code>🕟<br><code>:clock5:</code> 🕔<br><code>:clock530:</code> 🕠<br><code>:clock6:</code>🕕<br><code>:clock630:</code> 🕡<br><code>:clock7:</code> 🕖<br><code>:clock730:</code>🕢<br><code>:clock8:</code> 🕗<br><code>:clock830:</code> 🕣<br><code>:clock9:</code> 🕘<br><code>:clock930:</code>🕤<br><code>:heavy_dollar_sign:</code> 💲<br><code>:copyright:</code> ©️<br><code>:registered:</code> ®️<br><code>:tm:</code> ™️<br><code>:x:</code>❌<br><code>:heavy_exclamation_mark:</code>❗️<br><code>:bangbang:</code>‼️<br><code>:interrobang:</code>⁉️<br><code>:o:</code> ⭕️<br><code>:heavy_multiplication_x:</code> ✖️<br><code>:heavy_plus_sign:</code> ➕<br><code>:heavy_minus_sign:</code> ➖<br><code>:heavy_division_sign:</code>➗<br><code>:white_flower:</code> 💮<br><code>:100:</code> 💯<br><code>:heavy_check_mark:</code>✔️<br><code>:ballot_box_with_check:</code>☑️<br><code>:radio_button:</code> 🔘<br><code>:link:</code> 🔗<br><code>:curly_loop:</code>➰<br><code>:wavy_dash:</code> 〰️<br><code>:part_alternation_mark:</code> 〽️<br><code>:trident:</code>🔱<br><code>:black_large_square:</code>⬛️<br><code>:white_large_square:</code> ⬜️<br><code>:white_check_mark:</code>✅<br><code>:white_square_button:</code> 🔳<br><code>:black_square_button:</code> 🔲<br><code>:black_circle:</code> ⚫️<br><code>:white_circle:</code> ⚪️<br><code>:red_circle:</code> 🔴<br><code>:large_blue_circle:</code> 🔵<br><code>:large_blue_diamond:</code> 🔷<br><code>:large_orange_diamond:</code> 🔶<br><code>:small_blue_diamond:</code> 🔹<br><code>:small_orange_diamond:</code> 🔸<br><code>:small_red_triangle:</code> 🔺<br><code>:small_red_triangle_down:</code>🔻<br><code>:shipit:</code> :shipit:</p>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
            <tag> emoji </tag>
            
            <tag> 表情 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>又是一年逝去</title>
      <link href="/2018/01/02/annual-report-2017/"/>
      <url>/2018/01/02/annual-report-2017/</url>
      
        <content type="html"><![CDATA[<p>又是一年逝去</p><p>例行年初扯犊子 超开心 der ～</p><a id="more"></a><p>本来是准备着想以前一样去总结一些东西来 check 一下那些计划或者意外所带来的成长，但是到头来发现没什么太多的兴致。</p><p>如果说 16 年是学校到工作的过渡期，那么 17 年我算是真正意义上完成了这样一个转变。全新的环境，全新的人际。</p><p>17 年也是领域知识积累的开端，也是我一直以来所希望自己可以养成的习惯：</p><p>开始静心看书，不分类别应该读完了 30+本，老实说这比我再向前 4 年的都多。</p><p>开始知识管理，为知会员到期以后所有笔记全部迁移印象，400+条笔记删减到 100+ 除了懒得整理以外有一些东西确实不具有记录价值索性就删掉了</p><p>开始领域转型，从单纯后端业务 Java 工程师到真正的岗位被设为“全栈工程师”，这一点有点小自豪，不枉费我那无数个凌晨苟在家里研究 angularjs 研究 Vue 研究 nodejs 研究 es6 研究 jvm 研究各种源码 啊。好在一切都特么是值得的都特么变现了</p><p>这些习惯已是习惯，好的习惯难养成我只想对自己说“苟住，再接再厉”。</p><p>所谓『终生学习』一词其实我不大敢讲，毕竟在鸡汤和成功这类字眼已经不再具有绝对褒义的年代，你再和别人大谈 to be better man 会被嘲的。但实际『终生学习』实为我所崇敬的，在后来的生活中遇到的厉害人物在事业上确实是付出了许多的时间和精力。最大的感触就是，所有的牛逼真不是天赋和运气，那背后是不为人知的努力啊。</p><p>这一年所有专注全部事业相关，其他有的没的没必要废话，该做的努力都尝试都做了，但有些事不是努努力就可以的，也明白有些事也不是我所能决定的。</p><p>依旧，2017 感谢相伴，不忘初心</p>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
          <category> 年终总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 年终总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常识之外的规范——阿里java开发手册笔记(全章节)</title>
      <link href="/2017/10/15/ali-java-standard/"/>
      <url>/2017/10/15/ali-java-standard/</url>
      
        <content type="html"><![CDATA[<h3 id="说明"><a class="headerlink" href="#说明"></a> 说明</h3><p>这篇文章是我第一次（认真）阅读<a href="https://yq.aliyun.com/attachment/download/?id=2023" target="_blank" rel="noopener">《阿里巴巴 Java 开发手册(终极版)》</a>的笔记。<strong>手册本身对规范的讲解已经非常详细了，如果你已经有一定的开发经验并且有良好的编码习惯和意识，会发现大部分规范是符合常识的。所以本文不会再去做重复的说明，只是对其中一些可能没留意到的或者说不在（我的）常识之内的一些规范进行整理记录</strong>。当然每家公司都有自己的一套规范标准，所以大家也没必要过分追究。</p><a id="more"></a><p>其中或许会有遗漏或者理解错误，希望各位担待提点。</p><ol><li>重点我会用<strong>黑体</strong>标注。</li><li>引用部分为《阿里巴巴 Java 开发手册(终极版)》原文</li><li>更新时间：2017-10-17</li></ol><hr><h3 id="插件"><a class="headerlink" href="#插件"></a> 插件</h3><p>ide 插件已发布：<a href="https://yq.aliyun.com/articles/224817?spm=5176.100239.blogcont224345.17.BgD4xd" target="_blank" rel="noopener">《阿里巴巴 Java 开发手册》IDEA 插件与 Eclipse 插件使用指南</a></p><hr><h3 id="第一节-编程规约"><a class="headerlink" href="#第一节-编程规约"></a> 第一节 编程规约</h3><h4 id="1-命名规范"><a class="headerlink" href="#1-命名规范"></a> 1 命名规范</h4><blockquote><p>8.【强制】POJO 类中布尔类型的变量，都不要加 is，否则部分框架解析会引起序列化错误。</p></blockquote><blockquote><p>反例：定义为基本数据类型 Boolean isDeleted;的属性，它的方法也是 isDeleted()，<strong>RPC 框架在反向解析的时候，“以为”对应的属性名称是 deleted，导致属性获取不到，进而抛出异常。</strong></p></blockquote><blockquote><p>16.【参考】各层命名规约：<br>A) Service/DAO 层方法命名规约<br>1） 获取单个对象的方法用 get 做前缀。<br><strong>2） 获取多个对象的方法用 list 做前缀。</strong>（我习惯写成 getXxxList）<br>3） 获取统计值的方法用 count 做前缀。<br>4） 插入的方法用 save/insert 做前缀。<br>5） 删除的方法用 remove/delete 做前缀。<br>6） 修改的方法用 update 做前缀。</p></blockquote><h4 id="2-常量定义"><a class="headerlink" href="#2-常量定义"></a> 2 常量定义</h4><blockquote><p>1.【强制】不允许任何魔法值（即未经定义的常量）直接出现在代码中。<br>反例：<br><code>String key = &quot;Id#taobao_&quot; + tradeId;</code> &gt; <code>cache.put(key, value);</code></p></blockquote><p><em>魔法值：是指在代码中直接出现的数值，而只有在这个数值记述的那部分代码中才能明确了解其含义。</em><br>也就是我们常说的[硬编码]或者[写死]，这类代码需要定义常量来明确其含义。</p><h4 id="3-代码格式"><a class="headerlink" href="#3-代码格式"></a> 3 代码格式</h4><blockquote><p>5.【强制】采用 4 个空格缩进，禁止使用 tab 字符。<br><strong>说明：如果使用 tab 缩进，必须设置 1 个 tab 为 4 个空格。IDEA 设置 tab 为 4 个空格时，请勿勾选 Use tab character；而在 eclipse 中，必须勾选 insert spaces for tabs。</strong></p></blockquote><p><strong>有些同学可能会对这一条不以为然。如果是协调开发，两个工程师的格式化规则不一致很可能 A 同学无意把 B 同学的代码重新格式化并提交，导致后边查看 svn 变更记录时傻逼了。</strong></p><blockquote><p>7.【强制】<strong>单行字符数限制不超过 120 个</strong>，超出需要换行，换行时遵循如下原则：<br>1） 第二行相对第一行缩进 4 个空格，从第三行开始，不再继续缩进，参考示例。<br>2） 运算符与下文一起换行。<br>3） 方法调用的点符号与下文一起换行。<br>4） 方法调用时，多个参数，需要换行时，在逗号后进行。<br>5） 在括号前不要换行，见反例。</p></blockquote><p>120 这个长度限制很有意思，如图：<br><img src="/2017/10/15/ali-java-standard/length120.png" alt="ali-java-standard.png"><span class="image-caption">ali-java-standard.png</span><br>这个长度大概是 15 寸笔记本 1080 分辨率字体 14 号左右的最佳可视长度。当然应该也不一定非要这么精准吧。。</p><h4 id="4-oop-规约"><a class="headerlink" href="#4-oop-规约"></a> 4 OOP 规约</h4><blockquote><p>7.【强制】所有的相同类型的包装类对象之间值的比较，全部使用 equals 方法比较。<br>说明：<strong>对于 Integer var = ? 在-128 至 127 范围内的赋值</strong>，Integer 对象是在 IntegerCache.cache 产生，会复用已有对象，这个区间内的 Integer 值可以直接使用==进行判断，但是这个区间之外的所有数据，都会在堆上产生，并不会复用已有对象，这是一个大坑，推荐使用 equals 方法进行判断。</p></blockquote><blockquote><p>12.【强制】POJO 类必须写 toString 方法。使用 IDE 的中工具：source&gt; generate toString 时，<strong>如果继承了另一个 POJO 类，注意在前面加一下 super.toString。</strong><br>说明：在方法执行抛出异常时，可以直接调用 POJO 的 toString()方法打印其属性值，便于排查问题。</p></blockquote><p>~~ 吐槽：“使用 IDE <strong>的中</strong>工具” 码字错误哦！~~</p><blockquote><p>13.【推荐】使用索引访问用 String 的 split 方法得到的数组时，需做最后一个分隔符后有无内容的检查，<strong>否则会有抛 IndexOutOfBoundsException 的风险。</strong><br>说明：<br><code>String str = &quot;a,b,c,,&quot;;</code> &gt;<code>String[] ary = str.split(&quot;,&quot;);</code> &gt;<code>// 预期大于 3，结果是 3</code> &gt;<code>System.out.println(ary.length);</code></p></blockquote><p>最好的做法是对集合类型的变量本身进行判空校验或者大小判断，不要想当然。</p><h4 id="5-集合处理"><a class="headerlink" href="#5-集合处理"></a> 5 集合处理</h4><blockquote><p>2.【强制】ArrayList 的 subList 结果不可强转成 ArrayList，否则会抛出 ClassCastException 异常，即 java.util.RandomAccessSubList cannot be cast to java.util.ArrayList.<br>说明：subList 返回的是 ArrayList 的内部类 SubList，并不是 ArrayList ，而是 ArrayList 的一个视图，对于 SubList 子列表的所有操作最终会反映到原列表上。</p></blockquote><blockquote><p>5.【强制】使用工具类 Arrays.asList()把数组转换成集合时，不能使用其修改集合相关的方法，它的 add/remove/clear 方法会抛出 UnsupportedOperationException 异常。<br>说明：<strong>asList 的返回对象是一个 Arrays 内部类，并没有实现集合的修改方法。Arrays.asList 体现的是适配器模式，只是转换接口，后台的数据仍是数组。</strong> &gt;<code>String[] str = new String[] { &quot;you&quot;, &quot;wu&quot; };</code> &gt;<code>List list = Arrays.asList(str);</code><br>第一种情况：list.add(“yangguanbao”); 运行时异常。<br>第二种情况：str[0] = “gujin”; 那么 list.get(0)也会随之修改。</p></blockquote><blockquote><p>10.【推荐】使用 entrySet 遍历 Map 类集合 KV，而不是 keySet 方式进行遍历。<br>说明：keySet 其实是遍历了 2 次，一次是转为 Iterator 对象，另一次是从 hashMap 中取出 key 所对应的 value。而 entrySet 只是遍历了一次就把 key 和 value 都放到了 entry 中，效率更高。如果是 JDK8，使用 Map.foreach 方法。<br>正例：values()返回的是 V 值集合，是一个 list 集合对象；keySet()返回的是 K 值集合，是一个 Set 集合对象；entrySet()返回的是 K-V 值组合集合。</p></blockquote><p>java8 是个好东西~</p><h4 id="6-并发处理"><a class="headerlink" href="#6-并发处理"></a> 6 并发处理</h4><blockquote><p>5.【强制】<strong>SimpleDateFormat 是线程不安全的类</strong>，一般不要定义为 static 变量，如果定义为 static，必须加锁，或者使用 DateUtils 工具类。<br>正例：注意线程安全，使用 DateUtils。亦推荐如下处理：<br><code>private static final ThreadLocal&lt;DateFormat&gt; df = new ThreadLocal&lt;DateFormat&gt;() {</code> &gt;<code>@Override</code> &gt;<code>protected DateFormat initialValue() {</code> &gt;<code>return new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);</code> &gt;<code>}</code> &gt;<code>};</code><br>说明：如果是 JDK8 的应用，可以使用 Instant 代替 Date，LocalDateTime 代替 Calendar，DateTimeFormatter 代替 SimpleDateFormat，官方给出的解释：simple beautiful strong immutable thread-safe。</p></blockquote><p>再说一遍，java8 是个好东西！<a href="http://docs.oracle.com/javase/8/docs/api/java/time/LocalDateTime.html" target="_blank" rel="noopener">LocalDateTime 相关 API</a><br>附赠一个 java.util.Date 和 LocalDateTime 互转的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private static Date localDateTimeToUDate(LocalDateTime localDateTime) &#123;</span><br><span class="line">    ZoneId zone = ZoneId.systemDefault();</span><br><span class="line">    Instant instant = localDateTime.atZone(zone).toInstant();</span><br><span class="line">    return Date.from(instant);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static LocalDateTime uDateToLocalDate(Date date) &#123;</span><br><span class="line">    Instant instant = date.toInstant();</span><br><span class="line">    ZoneId zone = ZoneId.systemDefault();</span><br><span class="line">    LocalDateTime localDateTime = LocalDateTime.ofInstant(instant, zone);</span><br><span class="line">    return localDateTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>14.【参考】 <strong>HashMap 在容量不够进行 resize 时由于高并发可能出现死链</strong>，导致 CPU 飙升，在开发过程中可以使用其它数据结构或加锁来规避此风险。</p></blockquote><h4 id="7-控制语句"><a class="headerlink" href="#7-控制语句"></a> 7 控制语句</h4><blockquote><p>3.【推荐】表达异常的分支时，少用 if-else 方式，这种方式可以改写成：<br><code>if (condition) {</code> &gt; <code>...</code> &gt;<code>return obj;</code> &gt;<code>}</code> &gt;<code>// 接着写 else 的业务逻辑代码;</code><br>说明：如果非得使用 if()…else if()…else…方式表达逻辑，【强制】避免后续代码维护困难，请勿超过 3 层。<br>正例：超过 3 层的 if-else 的逻辑判断代码可以使用卫语句、策略模式、状态模式等来实现…</p></blockquote><p>我们公司 codeReview 时经常看到有些同学的代码是<code>if(){}else if(){} else if(){}else{}</code> 除了看上去 low 更主要的原因是过多的大括号层级不便于阅读很容易搞混，尤其是跳出代码块的时候，连续几个<code>}}}</code>基本就不知道跳到哪了彻底懵逼，还得折叠代码或者滚上去重新回忆一下。</p><blockquote><p>6.【推荐】接口入参保护，这种场景常见的是用于做批量操作的接口。<br>解释一下，<code>接口入参保护</code>就是对入参进行校验，包括允许的最大值或者其他范围或边界。防止请求大量数据导致接口“爆炸”。比如限制返回数据最大条数，超过限制直接 return 或者抛异常。</p></blockquote><h4 id="8-注释规约"><a class="headerlink" href="#8-注释规约"></a> 8 注释规约</h4><p>感觉没啥好说的。。</p><h4 id="9-其它"><a class="headerlink" href="#9-其它"></a> 9 其它</h4><blockquote><p>1.【强制】在使用正则表达式时，利用好其预编译功能，可以有效加快正则匹配速度。<br>说明：不要在方法体内定义：Pattern pattern = Pattern.compile(规则);</p></blockquote><p>就是说定义成全局变量。</p><hr><h3 id="第二节-异常日志"><a class="headerlink" href="#第二节-异常日志"></a> 第二节 异常日志</h3><h4 id="1-异常处理"><a class="headerlink" href="#1-异常处理"></a> 1 异常处理</h4><blockquote><p>3.【强制】对大段代码进行 try-catch，这是不负责任的表现。<strong>catch 时请分清稳定代码和非稳定代码</strong>，稳定代码指的是无论如何不会出错的代码。对于非稳定代码的 catch 尽可能进行区分异常类型，再做对应的异常处理。</p></blockquote><blockquote><p>9.【推荐】<strong>方法的返回值可以为 null，不强制返回空集合，或者空对象等</strong>，必须添加注释充分说明什么情况下会返回 null 值。调用方需要进行 null 判断防止 NPE 问题。说明：本手册明确防止 NPE 是调用者的责任。即使被调用方法返回空集合或者空对象，对调用者来说，也并非高枕无忧，必须考虑到远程调用失败、序列化失败、运行时异常等场景返回 null 的情况。</p></blockquote><p>需要说明的是是否可以返回 null 是需要根据接口约定来判断的，如果明确的返回对象的结构类型，一定要返回这个对象，但他的属性值可以是 null，比如 page 对象：<code>{data:null,pageNum:0,count:0}</code></p><h4 id="2-日志规约"><a class="headerlink" href="#2-日志规约"></a> 2 日志规约</h4><blockquote><p>4.【强制】对 trace/debug/info 级别的日志输出，必须使用条件输出形式或者使用占位符的方式。<br><strong>说明：logger.debug(&quot;Processingtradewithid: &quot; + id+ &quot;andsymbol: &quot; + symbol);如果日志级别是 warn，上述日志不会打印，但是会执行字符串拼接操作，如果 symbol 是对象，会执行 toString()方法，浪费了系统资源，执行了上述操作，最终日志却没有打印。</strong><br>正例：（条件）if (logger.isDebugEnabled()) { logger.debug(&quot;Processing trade with id: &quot; + id + &quot; and symbol: &quot; + symbol); }<br>正例：（占位符）logger.debug(&quot;Processing trade with id: {} and symbol : {} &quot;, id, symbol);</p></blockquote><hr><h3 id="第三节-单元测试"><a class="headerlink" href="#第三节-单元测试"></a> 第三节 单元测试</h3><blockquote><p>4.【强制】单元测试是可以重复执行的，不能受到外界环境的影响。<br>说明：单元测试通常会被放到持续集成中，每次有代码 check in 时单元测试都会被执行。如果单测对外部环境（网络、服务、中间件等）有依赖，容易导致持续集成机制的不可用。<br>正例：为了不受外界环境影响，要求<strong>设计代码时就把 SUT 的依赖改成注入</strong>，在测试时用 spring 这样的 DI 框架注入一个本地（内存）实现或者 Mock 实现。</p></blockquote><blockquote><p>15.【参考】为了更方便地进行单元测试，业务代码应避免以下情况：<br>构造方法中做的事情过多。 存在过多的全局变量和静态方法。<br>存在过多的外部依赖。<br>存在过多的条件语句。<strong>说明：多层条件语句建议使用卫语句、策略模式、状态模式等方式重构。</strong></p></blockquote><p>和第一节 if-else 提到的一样，避免多层代码块嵌套</p><blockquote><p>16.【参考】不要对单元测试存在如下误解：<br>那是测试同学干的事情。本文是开发手册，凡是本文内容都是与开发同学强相关的。<br>单元测试代码是多余的。汽车的整体功能与各单元部件的测试正常与否是强相关的。<br>单元测试代码不需要维护。一年半载后，那么单元测试几乎处于废弃状态。<br>单元测试与线上故障没有辩证关系。好的单元测试能够最大限度地规避线上故障。</p></blockquote><p>测试开发相亲相爱是一家~</p><hr><h3 id="第四节-安全规约"><a class="headerlink" href="#第四节-安全规约"></a> 第四节 安全规约</h3><blockquote><p>4.【强制】<strong>用户请求传入的任何参数必须做有效性验证</strong>。<br>说明：忽略参数校验可能导致：<br>pagesize 过大导致内存溢出<br>恶意 orderby 导致数据库慢查询<br>任意重定向 SQL 注入<br>反序列化注入<br>正则输入源串拒绝服务 ReDoS<br>说明：Java 代码用正则来验证客户端的输入，有些正则写法验证普通用户输入没有问题，但是如果攻击人员使用的是特殊构造的字符串来验证，有可能导致死循环的结果。</p></blockquote><p>老生常谈的问题，但在工作中有时会忽略。</p><hr><h3 id="第五节-mysql-数据库"><a class="headerlink" href="#第五节-mysql-数据库"></a> 第五节 MySQL 数据库</h3><h4 id="1-建表规约"><a class="headerlink" href="#1-建表规约"></a> 1. 建表规约</h4><blockquote><p>8.【强制】varchar 是可变长字符串，不预先分配存储空间，<strong>长度不要超过 5000，如果存储长度大于此值，定义字段类型为 text，独立出来一张表</strong>，用主键来对应，避免影响其它字段索引效率。</p></blockquote><p>大字段建外连表，避免影响索引效率。难点在于如何说服主工程师（滑稽）。</p><blockquote><p>13.【推荐】字段允许适当冗余，以提高查询性能，但必须考虑数据一致。<br>冗余字段应遵循：<br>1）<strong>不是频繁修改的字段。</strong><br>2）<strong>不是 varchar 超长字段，更不能是 text 字段。</strong><br>正例：商品类目名称使用频率高，字段长度短，名称基本一成不变，可在相关联的表中冗余存储类目名称，避免关联查询。</p></blockquote><p>讲一个笑话。公司老王出差去拉项目，对方博士生问“这个数据库设计为什么不符合三范式？”<br>真事。</p><blockquote><p>14.【推荐】<strong>单表行数超过 500 万行或者单表容量超过 2GB，才推荐进行分库分表。</strong><br>说明：如果预计三年后的数据量根本达不到这个级别，请不要在创建表时就分库分表。</p></blockquote><h4 id="2-索引规约"><a class="headerlink" href="#2-索引规约"></a> 2. 索引规约</h4><blockquote><p>3.【强制】在 varchar 字段上建立索引时，<strong>必须指定索引长度，没必要对全字段建立索引</strong>，根据实际文本区分度决定索引长度即可。<br>说明：索引的长度与区分度是一对矛盾体，一般对字符串类型数据，长度为 20 的索引，区分度会高达 90%以上，可以使用 count(distinctleft(列名, 索引长度))/count(*)的区分度来确定。</p></blockquote><blockquote><p>5.【推荐】如果有 orderby 的场景，请注意利用索引的有序性。orderby 最后的字段是组合索引的一部分，并且放在索引组合顺序的最后，避免出现 file_sort 的情况，影响查询性能。<br>正例：wherea=? andb=? orderbyc;索引：a_b_c<br>反例：索引中有范围查找，那么索引有序性无法利用，如：WHEREa&gt;10 ORDERBYb;索引 a_b 无法排序。</p></blockquote><blockquote><p>6.【推荐】利用覆盖索引来进行查询操作，避免回表。<br>说明：如果一本书需要知道第 11 章是什么标题，会翻开第 11 章对应的那一页吗？目录浏览一下就好，这个目录就是起到覆盖索引的作用。<br>正例：能够建立索引的种类：主键索引、唯一索引、普通索引，而覆盖索引是一种查询的一种效果，用 explain 的结果，extra 列会出现：usingindex。</p></blockquote><h4 id="3-sql-语句"><a class="headerlink" href="#3-sql-语句"></a> 3. SQL 语句</h4><blockquote><p>1.【强制】<strong>不要使用 count(列名)或 count(常量)来替代 count(*)</strong>，count(<em>)是 SQL92 定义的标准统计行数的语法，跟数据库无关，跟 NULL 和非 NULL 无关。<br>说明：**count(</em>)会统计值为 NULL 的行，而 count(列名)不会统计此列为 NULL 值的行。**</p></blockquote><p>乖乖滚回 count(*)</p><blockquote><p>【推荐】<strong>in 操作能避免则避免，若实在避免不了，需要仔细评估 in 后边的集合元素数量，控制在 1000 个之内。</strong></p></blockquote><h4 id="4-orm-映射"><a class="headerlink" href="#4-orm-映射"></a> 4. ORM 映射</h4><blockquote><p>3.【强制】<strong>不要用 resultClass 当返回参数</strong>，即使所有类属性名与数据库字段一一对应，也需要定义；反过来，每一个表也必然有一个与之对应。<br>说明：配置映射关系，使字段与 DO 类解耦，方便维护。</p></blockquote><p>编程一时爽，维护两行泪~</p><blockquote><p>5.【强制】iBATIS 自带的 queryForList(StringstatementName,intstart,intsize)不推荐使用。<br>说明：其实现方式是<strong>在数据库取到 statementName 对应的 SQL 语句的所有记录，再通过 subList 取 start,size 的子集合</strong>。<br>正例：<br><code>Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();</code> &gt; <code>map.put(&quot;start&quot;, start);</code><br><code>map.put(&quot;size&quot;, size);</code></p></blockquote><p>没想到你是这样的 iBATIS！</p><hr><h3 id="第六节-工程结构"><a class="headerlink" href="#第六节-工程结构"></a> 第六节 工程结构</h3><h4 id="1-应用分层"><a class="headerlink" href="#1-应用分层"></a> 1. 应用分层</h4><blockquote><p>2.【参考】（分层异常处理规约）在 DAO 层，产生的异常类型有很多，无法用细粒度的异常进行 catch，使用 catch(Exceptione)方式，并 thrownewDAOException(e)，不需要打印日志，因为日志在 Manager/Service 层一定需要捕获并打到日志文件中去，如果同台服务器再打日志，浪费性能和存储。在 Service 层出现异常时，必须记录出错日志到磁盘，尽可能带上参数信息，相当于保护案发现场。如果 Manager 层与 Service 同机部署，日志方式与 DAO 层处理一致，如果是单独部署，则采用与 Service 一致的处理方式。Web 层绝不应该继续往上抛异常，因为已经处于顶层，如果意识到这个异常将导致页面无法正常渲染，那么就应该直接跳转到友好错误页面，加上用户容易理解的错误提示信息。开放接口层要将异常处理成错误码和错误信息方式返回。</p></blockquote><h4 id="2-二方库依赖"><a class="headerlink" href="#2-二方库依赖"></a> 2. 二方库依赖</h4><blockquote><p>10.【参考】为避免应用二方库的依赖冲突问题，二方库发布者应当遵循以下原则：<br>1）**精简可控原则。**移除一切不必要的 API 和依赖，只包含 ServiceAPI、必要的领域模型对象、Utils 类、常量、枚举等。如果依赖其它二方库，尽量是 provided 引入，让二方库使用者去依赖具体版本号；无 log 具体实现，只依赖日志框架。<br>2）**稳定可追溯原则。**每个版本的变化应该被记录，二方库由谁维护，源码在哪里，都需要能方便查到。除非用户主动升级版本，否则公共二方库的行为不应该发生变化。</p></blockquote><h4 id="3-服务器"><a class="headerlink" href="#3-服务器"></a> 3. 服务器</h4><blockquote><p>4.【推荐】在线上生产环境，JVM 的 Xms 和 Xmx 设置一样大小的内存容量，避免在 GC 后调整堆大小带来的压力。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> dev </category>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dev </tag>
            
            <tag> back-end </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2016：意料之外的意料之中</title>
      <link href="/2016/12/31/annual-report-2016/"/>
      <url>/2016/12/31/annual-report-2016/</url>
      
        <content type="html"><![CDATA[<p>吐槽：此处应有鸡汤。但是抱歉，不知道从什么时候开始对于这类文字极其反感。把处境与结果直接相连而忽略方法过程，再或者就是什么无脑的“加油”，“坚持”，“做自己”云云的，简直都是放。。只想说，还是做自己年龄段该做的事吧。别用所谓的鸡汤来验证或者辩护自己是不是在套路上。</p><a id="more"></a><center><p><img src="/2016/12/31/annual-report-2016/1.jpg" alt="before.jpg"><span class="image-caption">before.jpg</span></p></center><p></p><center>这汤有毒。。这汤有d。。</center>### 一 2016年我都折腾了些啥先说一下去年的期盼吧。我记得去年过生日时许愿说想找个15k的工作，但当时真心只是瞎bb啊，然而我特么真的在上半年没有好好的认认真真的安安稳稳的整存整取的拿过工资。看着从各大银行发来的工资短信，我只能说“这波不亏”，东奔西走了几家公司最大的收获就是认识了几个有趣的人，见识了一个公司可以有多坑，还有什么叫做 真.一脸懵逼。。当然还有，从事一份真正热爱的工作是一种怎样的体验。如果说“变得喜欢”是一种幸福，那么“遇见真爱”就是一种眷顾。<center><p><img src="/2016/12/31/annual-report-2016/2.jpg" alt="before.jpg"><span class="image-caption">before.jpg</span></p></center><p></p><center><p>❤️</p></center><p>这种眷顾让人感到卑微和不安，但也因此而欣慰这半年的折腾和遭遇都很值得，很值得。以至于我依旧可以以一种傲娇的姿态说“宝宝换工作从来都是看心情”。。我做到了，但不想再做了。。至于那个愿望，貌似还差一点。嗯，今年我还要许这个愿望。</p><h3 id="二-2016-年与生老病死有关的一些事"><a class="headerlink" href="#二-2016-年与生老病死有关的一些事"></a> 二 2016 年与生老病死有关的一些事</h3><p>三观毁了！灾后重建一般的毁了！</p><p>过去我可能是个屌丝单身狗，但是现在不一样了。。我现在有词缀了，“不要脸的屌丝单身狗”。这几个字是传奇紫的。。</p><center><p><img src="/2016/12/31/annual-report-2016/3.jpg" alt="before.jpg"><span class="image-caption">before.jpg</span></p></center><p></p><center>我一旦睡着，世界就安静了我一旦睡着，世界就安静了</center><p>这种进阶可能源于对单身属性的理解，以前以为这是个 debuff，走到哪里都会有伤害加成脆弱得很。</p><p>但现在我认为，从时间维度来讲自然界中所有物质所拥有的时间刻度都是一样的，而狗在其中投入于自身的时间比例较高，满足于自身满意度的效率则更高，而充实度。。因狗而异。应该是这个道理吧。。所以从某种意义上讲，这是值得且必要的。这个解释不牵强吧？反正。。我不管！我说是就是。</p><p>我不知道为啥在这类问题上我是这个遭遇，我只知道，不管之前多么溃不成军有多狼狈，但不好意思，这局，我要赢。</p><h3 id="三-2016-年感悟"><a class="headerlink" href="#三-2016-年感悟"></a> 三 2016 年感悟</h3><p>我以为这一年会回归平淡。</p><p>不会有 15 年离开学生时代的惆怅。不会有 14 年那年的不欢而散。不会有 13 年的患得患失。</p><p>然而这一年却以一种哭笑不得或者自我感动的方式变得更为难忘。</p><p>这使得我更加坚信并值得再次提及：每一件事都有它发生的意义。这些经历势必让一个人的人格得以完善或者跑偏。而尊重并忠实它的结局则是最好的方式。</p><p>无论是否如愿，都挺好的。</p><center><p><img src="/2016/12/31/annual-report-2016/4.jpg" alt="before.jpg"><span class="image-caption">before.jpg</span></p></center><p></p><center>孤独？惬意？你说了算孤独？惬意？你说了算</center><p>最后。<br>“勿忘初心”真心不是什么屁话。无论是否同意，我希望这四个字最本质的意义是被理解的。仔细想想，当你再次遇见一个很久不见的人，如何才能保持第一次见面时的那种感觉？很难。</p><p>以上。2016，感谢相伴。</p><center><p><img src="/2016/12/31/annual-report-2016/5.jpg" alt="before.jpg"><span class="image-caption">before.jpg</span></p></center><p></p><center>阳光的味道～阳光的味道～</center>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
          <category> 年终总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 年终总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一个更好的结束</title>
      <link href="/2015/12/31/annual-report-2015/"/>
      <url>/2015/12/31/annual-report-2015/</url>
      
        <content type="html"><![CDATA[<p><em>若我已逝，有谁忆。。</em></p><p>如果说，2015 是一首离歌，悄然的离别庆幸没有掀起太多的伤感。宴席终究是散去了，尽兴或者不都已经没有了意义，毕竟知道有些事单方面的努力是苍白的。好在我一直都是莫名的自信，总是知道一切都是毕然且有意义的，嗯，都是自然规律。。</p><a id="more"></a><p><em>“成就你的从来都不是你经历的事，而是你对这些事的态度。”</em><br>毕竟，看气质嘛。。</p><p>我思考过一个问题：<br>为什么那些事实上很无所谓再或者至多也是尽力而为就好的事情，会被一些人如此看中，即使他们并不是痛并快乐着？为什么事实上那些可以轻易获得刚好的生活状态的牛 X 人士不会因此而放弃一些本该“死掉”的事物，而是乐观的坚信 everything will be ok.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 大概就是这个意思 */</span></span><br><span class="line"><span class="function">Public List&lt;ProblemPOJO&gt; <span class="title">life</span><span class="params">(Object strength,Object passion)</span></span>&#123;</span><br><span class="line">  Map&lt;String,Object&gt; everyThing = <span class="keyword">new</span> HashMap&lt;String,Object&gt;();</span><br><span class="line">  List&lt;ProblemPOJO&gt; porList = <span class="keyword">new</span> ArrayList&lt;ProblemPOJO&gt;();</span><br><span class="line">  <span class="keyword">if</span>(<span class="number">1</span>=<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">for</span>(ProblemPOJO por: porList)&#123;</span><br><span class="line">      everyThing.put(“strength”, strength);</span><br><span class="line">      everyThing.put(“passion”, passion);</span><br><span class="line">      por.setEveryThing(everyThing);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  System.out.println(<span class="string">"Bingo！ o(*≧▽≦)ツ "</span>);</span><br><span class="line">  System.out.println(<span class="string">"我就不抛异常。。打我！"</span>);</span><br><span class="line">  <span class="keyword">return</span> porList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>可能这就是所谓的“事业心”吧。</em></p><p>此至年末，令我惊奇的事情无非有三： 1.学生与白领角色切换得竟是如此的从容！ 2.衣带渐宽终不悔,为伊消得人憔悴。啊？！ 3.每周都有鱼吃的生活期盼真的实现了！！</p><p>以上。2015，感谢相伴 😃</p>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
          <category> 年终总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 年终总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一个离开</title>
      <link href="/2015/04/26/graduation/"/>
      <url>/2015/04/26/graduation/</url>
      
        <content type="html"><![CDATA[<p><em>若我已逝，有谁忆。。</em></p><p>放下了论文，放下来实习。终于可以坐下来无事可做了。。<br>昨天看了《速 7》，片尾的 see you again 整个人就不好了。（我真的泪点很低无法自拔。。）也借着这种情绪可以写点什么。。<br>真的是“我尝试着写作，却没有了当年的情怀。”</p><a id="more"></a><p>以上内容写于 4.18<br>——题记<br>(------------04.26 更)<br>你有没有一种感觉：<br>伴随着成长，本该感悟伤怀的事情逐渐变得淡然处之？而这样一种感觉却被误以为感情淡了或者。。本来感情就很淡？<br>至少我是这种感觉。<br>这应该是个伤感的季节，应该去悼念大学的时光，悼念过去的青春，悼念过去的事，悼念过去的人。而你问我什么感觉，我说：<br>“还好吧。”<br>嗯，在这个本该煽情的时刻我更愿意用理智去解释什么让我们（我）如此 whatever。<br><strong>这里不要满腹诗词的惆怅，不要空洞狗血的鸡汤。</strong><br><strong>这里只要“事实就是这样。”</strong></p><p>一。这一次真的长大了。<br>（去，思维太跳，刚才想的什么忘记了。。占坑再更吧）<br>(---------04.27 零时 更)<br>如何定义成长？私以为真正的成长源于心智而非年龄。多少次我们切身感觉到长大或者从别人口中得知长大，这些外在的反馈给到的只是“你处在了什么年龄”而非“你要承受怎样的责任”。<br>**责任。**这一次我们失去了庇护，你无法想象真正的一无是处所带来的无依无靠真的会死！成为一个社会人就要顶天立地的生根发芽，这事我们没有经验，所以要准备准备啊。<br>**准备。**忙着论文，保证顺利的离开不被拖累，这个拖累从广义上讲包括以前欠下的幼稚债。忙着找工作，保证从庇护所粗来口以有个安身立命的地儿，不至于没有了学业压力而变得无所事事。学业与事业的切换不是说变得就变的呢。<br>**毕业。**毕业什么的不要太多好伐。。我们经历过多少个毕业，幼儿园毕业得茫然，小学毕业得朝气蓬勃，初中毕业得夏草芬芳，高中毕业得。。呵呵（哒）。唯这次不同，这次告别的是一个时代，一个角色。<br>**事业。**要不要尝试努力回想一下下自己第一次去幼儿园的情景？记不清了吧～没关系，这次你也不会记得太清。角色的切换从来都是不情愿的——你从婴儿转为学生，和你从学生转为社会人是同样的体验。这种体验是麻木的。<br>现在，接着来看待什么是“长大”。<br>责任，准备，毕业，事业。<br><strong>不管你愿不愿意，该来的都来了。</strong></p><p>二。放下的与放不下的。<br>（愚蠢的人类，别以为这就完了！我会回来的。。）<br>（---------04.28 更）<br>先来思考这样一个问题：“为什么存在“放下”与“放不下”这样的概念？<br>其核心就是一个词“care”。（最近超喜欢用一个词来概括一件事，这是论文后遗症么？）当你热衷于某事、人、物的时候就会在内心形成一个有关于此的“舒适区”，然后有关于此的任何事件都会令你心起波澜。而这种事件将导致两种结果：满意度饱和与满意度未饱和，再向外映射就是“放下”与“放不下”了。<br>有多少的事因为放下了你感到充实，有多少事你放不下感到空虚。三载春秋变迁，何必耿耿于怀？因为：<br><strong>时光本不该被纪念，回忆只是不尽兴的梦。</strong>（这句话我自己都要用吐了，但真的好有道理！）<br>所有，放不下因为不尽兴，不尽兴因为不努力，不努力。。不努力你怪我咯~<br>我们都努力吧，把握当前的事件才具有真正意义上的“价值”，不然你又该不尽兴放不下呢。。<br>（说好的不鸡汤的啊喂！没办法就这尿[sui，这个字应该念 sui，我考证了]性，不然你从屏幕爬出来打我啊~）</p><p><strong>当放下这些不甘心，还有什么好伤感的？</strong><br>我用两年的时间祭奠逝去的珍贵，也用两年的时间埋葬本该拥有的成就。再用一年的时间努力争取回来，但永远再也无法得到的却是时间。</p><p>放不下的“能且只能”是时间。</p><p>三。第一个离开。<br>（我怎么会破坏经典的“三部曲”式写作风格~）<br>（04.29 更）</p><p>我曾经路过你们的校门，<br>与你们一同排着长队去领期待已久的包裹；</p><p>我曾经路过你们的寝室，<br>在一起的嬉笑与吐槽可以传遍整个角落；</p><p>我曾经路过你们的操场，<br>也要在幽幽灯光下看活力与激情的拼搏；</p><p>我曾经路过你们的教室，<br>去努力认知马太效应却挡不住老师的热火；</p><p>我曾经路过你们的聚会，<br>静静仰望那些才华横溢的朋友成就今晚的自我；</p><p>我曾经路过你们的友情，<br>无时无刻形影不离还相互挖坑各种欢乐；（话说这里开始不押韵了-.-)</p><p>我曾经路过你们的爱情，<br>看到在那花与叶在最好的季节绽放。（算，书读少没办法。。）</p><p>太多的包裹，却美好；<br>太多的角落，却美好；<br>太多的拼搏，却美好；<br>太多的热火，却美好；</p><p>太多的自我，那么美好；<br>太多的欢乐，那么美好；<br>太多的绽放，那么美好；</p><p>太多的美好，我怕忘不掉，走不了。<br>我曾经路过却想第一个离开。</p><p><strong>“为什么不说声再见？”</strong><br><strong>“怎么说得出口。”</strong><br>——《速 7》</p><p>（完）</p>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
          <category> 碎碎念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学生时代 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>人生有始,光影无终</title>
      <link href="/2008/12/07/life-movie/"/>
      <url>/2008/12/07/life-movie/</url>
      
        <content type="html"><![CDATA[<h2 id="序"><a class="headerlink" href="#序"></a> 序</h2><blockquote><p>时这篇文章最早是发表在 QQ 空间上的,而今已经 10 年过去了…</p></blockquote><h2 id="正文"><a class="headerlink" href="#正文"></a> 正文</h2><p>人生,仿佛一道道光影在以每秒 16 格的速度闪烁不止。这是一场没有结局的电影，却有许多的开始。 于是，1、2、3,action(开机)……­</p><a id="more"></a><h3 id="第一幕开始的友谊"><a class="headerlink" href="#第一幕开始的友谊"></a> 第一幕：开始的友谊</h3><p>开始的友谊——“友谊”的另一头是一个我叫不上名字的朋友牵着的。我也许该窃笑，也该被窃笑——不知道名字，从和谈得上“朋友”？但这却是事实，不容遮藏，那的确是我第一个朋友。第一次让我尝试“友谊”的开始。­</p><p>时光逆流……­</p><p>秋天的金色下，第一眼就看见她独自坐在跷跷板的一头“自娱自乐”。说是“娱”和“乐”，其实她挺孤单。压起跷跷板空无一人的另一头看着其他小朋友玩，半着他们笑声，展开自己可爱地笑——轻笑。­<br>我走上前去，说出了一句令我自己都感到鬼使神差的话：“我可以和你一起玩吗？”我惊讶，因为我从未与陌生人主动交谈——这是第一次。­<br>她转过头惊异地看着我，犹豫。“好啊。”她放平跷跷板的另一头……­<br>城市的公园里是秋天的金色，城市的夕阳也是金色。这片金色笼罩着公园的我和我的朋友。这片金色仿佛照透了我的心灵，换还有她的心灵。­<br>公园的草坪上跷跷板一上一下，和两个小小的身影斜斜地伴着朗朗地笑声映向远方……­</p><p>那一年我五岁。­</p><p>时光至此，光影定格。这些镜头多么温馨！­</p><h3 id="第二幕青春的面无表情"><a class="headerlink" href="#第二幕青春的面无表情"></a> 第二幕：青春的面无表情</h3><p>曾经憧憬过青春，娜梦中的青春是诗一样的浪漫，像歌一样的悠扬。而我真正得到青春的“合格证”时，真正地做到身临其境时才发现自己骗了自己——没有诗，没有歌。­</p><p>年华别样，没有像曾经一样整天想着家里有几块甜点，学校又交了几个新朋友。现在想起，才理解什么才叫做“生活中自由的小鸟”——这是童年作文中常有的最愉快的比喻可这“自由的小鸟”只有短短的十年的胶片，而且已经用过了。好像却没有珍惜过。­<br>年华别样，青春别样。我每天每夜只是面无表情。我每天好像都在表演 montage（蒙太奇）一般——事喜则喜，事忧则忧。其实，我那是一张疲惫的脸，木滞的脸。谈不上“沧桑”，毕竟我经历的不是沧海桑田。只是疲惫，疲惫中我不断认清了世界，除了通话的幸福美好外，仿佛更多的是丑恶与不幸。­</p><p>时光至此，光影定格。这场戏何时停机？­</p><h3 id="第三幕我在人生的有终无终间"><a class="headerlink" href="#第三幕我在人生的有终无终间"></a> 第三幕：我在人生的有终无终间</h3><p>我的生命从零岁开始，终将结束于 n 岁。而这不是人生的结束，这里的“终将结束”只属于我的和我同年同月同日死的人。人生的电影没有结局的，光影中没有绝对的主角，而我们只是自己这段戏的“男一号”和“女一号”。别人戏中的配角或者群众演员。­<br>人生。光影。我们的人生。我们的光影。­</p><p>没有人说停机，也没有人说过第一个，action……­</p><h2 id="后记"><a class="headerlink" href="#后记"></a> 后记</h2><blockquote><p>耳边响起了：­<br>假如我告诉你，想拍一部好电影 ­<br>你会否告诉我，想到医科大明星 ­<br>好莱坞在哪里，只要没想就可以 ­<br>来约定在这人间做给天使看得戏……­<br>——谢霆锋《给天使看的戏》­</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
          <category> 碎碎念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 年终总结 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
